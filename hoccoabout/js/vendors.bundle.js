/*! jQuery v3.3.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function (e, t) { "use strict"; "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function (e) { if (!e.document) throw new Error("jQuery requires a window with a document"); return t(e) } : t(e) }("undefined" != typeof window ? window : this, function (e, t) { "use strict"; var n = [], r = e.document, i = Object.getPrototypeOf, o = n.slice, a = n.concat, s = n.push, u = n.indexOf, l = {}, c = l.toString, f = l.hasOwnProperty, p = f.toString, d = p.call(Object), h = {}, g = function e(t) { return "function" == typeof t && "number" != typeof t.nodeType }, y = function e(t) { return null != t && t === t.window }, v = { type: !0, src: !0, noModule: !0 }; function m(e, t, n) { var i, o = (t = t || r).createElement("script"); if (o.text = e, n) for (i in v) n[i] && (o[i] = n[i]); t.head.appendChild(o).parentNode.removeChild(o) } function x(e) { return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? l[c.call(e)] || "object" : typeof e } var b = "3.3.1", w = function (e, t) { return new w.fn.init(e, t) }, T = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; w.fn = w.prototype = { jquery: "3.3.1", constructor: w, length: 0, toArray: function () { return o.call(this) }, get: function (e) { return null == e ? o.call(this) : e < 0 ? this[e + this.length] : this[e] }, pushStack: function (e) { var t = w.merge(this.constructor(), e); return t.prevObject = this, t }, each: function (e) { return w.each(this, e) }, map: function (e) { return this.pushStack(w.map(this, function (t, n) { return e.call(t, n, t) })) }, slice: function () { return this.pushStack(o.apply(this, arguments)) }, first: function () { return this.eq(0) }, last: function () { return this.eq(-1) }, eq: function (e) { var t = this.length, n = +e + (e < 0 ? t : 0); return this.pushStack(n >= 0 && n < t ? [this[n]] : []) }, end: function () { return this.prevObject || this.constructor() }, push: s, sort: n.sort, splice: n.splice }, w.extend = w.fn.extend = function () { var e, t, n, r, i, o, a = arguments[0] || {}, s = 1, u = arguments.length, l = !1; for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == typeof a || g(a) || (a = {}), s === u && (a = this, s--); s < u; s++)if (null != (e = arguments[s])) for (t in e) n = a[t], a !== (r = e[t]) && (l && r && (w.isPlainObject(r) || (i = Array.isArray(r))) ? (i ? (i = !1, o = n && Array.isArray(n) ? n : []) : o = n && w.isPlainObject(n) ? n : {}, a[t] = w.extend(l, o, r)) : void 0 !== r && (a[t] = r)); return a }, w.extend({ expando: "jQuery" + ("3.3.1" + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (e) { throw new Error(e) }, noop: function () { }, isPlainObject: function (e) { var t, n; return !(!e || "[object Object]" !== c.call(e)) && (!(t = i(e)) || "function" == typeof (n = f.call(t, "constructor") && t.constructor) && p.call(n) === d) }, isEmptyObject: function (e) { var t; for (t in e) return !1; return !0 }, globalEval: function (e) { m(e) }, each: function (e, t) { var n, r = 0; if (C(e)) { for (n = e.length; r < n; r++)if (!1 === t.call(e[r], r, e[r])) break } else for (r in e) if (!1 === t.call(e[r], r, e[r])) break; return e }, trim: function (e) { return null == e ? "" : (e + "").replace(T, "") }, makeArray: function (e, t) { var n = t || []; return null != e && (C(Object(e)) ? w.merge(n, "string" == typeof e ? [e] : e) : s.call(n, e)), n }, inArray: function (e, t, n) { return null == t ? -1 : u.call(t, e, n) }, merge: function (e, t) { for (var n = +t.length, r = 0, i = e.length; r < n; r++)e[i++] = t[r]; return e.length = i, e }, grep: function (e, t, n) { for (var r, i = [], o = 0, a = e.length, s = !n; o < a; o++)(r = !t(e[o], o)) !== s && i.push(e[o]); return i }, map: function (e, t, n) { var r, i, o = 0, s = []; if (C(e)) for (r = e.length; o < r; o++)null != (i = t(e[o], o, n)) && s.push(i); else for (o in e) null != (i = t(e[o], o, n)) && s.push(i); return a.apply([], s) }, guid: 1, support: h }), "function" == typeof Symbol && (w.fn[Symbol.iterator] = n[Symbol.iterator]), w.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) { l["[object " + t + "]"] = t.toLowerCase() }); function C(e) { var t = !!e && "length" in e && e.length, n = x(e); return !g(e) && !y(e) && ("array" === n || 0 === t || "number" == typeof t && t > 0 && t - 1 in e) } var E = function (e) { var t, n, r, i, o, a, s, u, l, c, f, p, d, h, g, y, v, m, x, b = "sizzle" + 1 * new Date, w = e.document, T = 0, C = 0, E = ae(), k = ae(), S = ae(), D = function (e, t) { return e === t && (f = !0), 0 }, N = {}.hasOwnProperty, A = [], j = A.pop, q = A.push, L = A.push, H = A.slice, O = function (e, t) { for (var n = 0, r = e.length; n < r; n++)if (e[n] === t) return n; return -1 }, P = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", M = "[\\x20\\t\\r\\n\\f]", R = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+", I = "\\[" + M + "*(" + R + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + R + "))|)" + M + "*\\]", W = ":(" + R + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + I + ")*)|.*)\\)|)", $ = new RegExp(M + "+", "g"), B = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"), F = new RegExp("^" + M + "*," + M + "*"), _ = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"), z = new RegExp("=" + M + "*([^\\]'\"]*?)" + M + "*\\]", "g"), X = new RegExp(W), U = new RegExp("^" + R + "$"), V = { ID: new RegExp("^#(" + R + ")"), CLASS: new RegExp("^\\.(" + R + ")"), TAG: new RegExp("^(" + R + "|[*])"), ATTR: new RegExp("^" + I), PSEUDO: new RegExp("^" + W), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"), bool: new RegExp("^(?:" + P + ")$", "i"), needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i") }, G = /^(?:input|select|textarea|button)$/i, Y = /^h\d$/i, Q = /^[^{]+\{\s*\[native \w/, J = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, K = /[+~]/, Z = new RegExp("\\\\([\\da-f]{1,6}" + M + "?|(" + M + ")|.)", "ig"), ee = function (e, t, n) { var r = "0x" + t - 65536; return r !== r || n ? t : r < 0 ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320) }, te = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, ne = function (e, t) { return t ? "\0" === e ? "\ufffd" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e }, re = function () { p() }, ie = me(function (e) { return !0 === e.disabled && ("form" in e || "label" in e) }, { dir: "parentNode", next: "legend" }); try { L.apply(A = H.call(w.childNodes), w.childNodes), A[w.childNodes.length].nodeType } catch (e) { L = { apply: A.length ? function (e, t) { q.apply(e, H.call(t)) } : function (e, t) { var n = e.length, r = 0; while (e[n++] = t[r++]); e.length = n - 1 } } } function oe(e, t, r, i) { var o, s, l, c, f, h, v, m = t && t.ownerDocument, T = t ? t.nodeType : 9; if (r = r || [], "string" != typeof e || !e || 1 !== T && 9 !== T && 11 !== T) return r; if (!i && ((t ? t.ownerDocument || t : w) !== d && p(t), t = t || d, g)) { if (11 !== T && (f = J.exec(e))) if (o = f[1]) { if (9 === T) { if (!(l = t.getElementById(o))) return r; if (l.id === o) return r.push(l), r } else if (m && (l = m.getElementById(o)) && x(t, l) && l.id === o) return r.push(l), r } else { if (f[2]) return L.apply(r, t.getElementsByTagName(e)), r; if ((o = f[3]) && n.getElementsByClassName && t.getElementsByClassName) return L.apply(r, t.getElementsByClassName(o)), r } if (n.qsa && !S[e + " "] && (!y || !y.test(e))) { if (1 !== T) m = t, v = e; else if ("object" !== t.nodeName.toLowerCase()) { (c = t.getAttribute("id")) ? c = c.replace(te, ne) : t.setAttribute("id", c = b), s = (h = a(e)).length; while (s--) h[s] = "#" + c + " " + ve(h[s]); v = h.join(","), m = K.test(e) && ge(t.parentNode) || t } if (v) try { return L.apply(r, m.querySelectorAll(v)), r } catch (e) { } finally { c === b && t.removeAttribute("id") } } } return u(e.replace(B, "$1"), t, r, i) } function ae() { var e = []; function t(n, i) { return e.push(n + " ") > r.cacheLength && delete t[e.shift()], t[n + " "] = i } return t } function se(e) { return e[b] = !0, e } function ue(e) { var t = d.createElement("fieldset"); try { return !!e(t) } catch (e) { return !1 } finally { t.parentNode && t.parentNode.removeChild(t), t = null } } function le(e, t) { var n = e.split("|"), i = n.length; while (i--) r.attrHandle[n[i]] = t } function ce(e, t) { var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex; if (r) return r; if (n) while (n = n.nextSibling) if (n === t) return -1; return e ? 1 : -1 } function fe(e) { return function (t) { return "input" === t.nodeName.toLowerCase() && t.type === e } } function pe(e) { return function (t) { var n = t.nodeName.toLowerCase(); return ("input" === n || "button" === n) && t.type === e } } function de(e) { return function (t) { return "form" in t ? t.parentNode && !1 === t.disabled ? "label" in t ? "label" in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && ie(t) === e : t.disabled === e : "label" in t && t.disabled === e } } function he(e) { return se(function (t) { return t = +t, se(function (n, r) { var i, o = e([], n.length, t), a = o.length; while (a--) n[i = o[a]] && (n[i] = !(r[i] = n[i])) }) }) } function ge(e) { return e && "undefined" != typeof e.getElementsByTagName && e } n = oe.support = {}, o = oe.isXML = function (e) { var t = e && (e.ownerDocument || e).documentElement; return !!t && "HTML" !== t.nodeName }, p = oe.setDocument = function (e) { var t, i, a = e ? e.ownerDocument || e : w; return a !== d && 9 === a.nodeType && a.documentElement ? (d = a, h = d.documentElement, g = !o(d), w !== d && (i = d.defaultView) && i.top !== i && (i.addEventListener ? i.addEventListener("unload", re, !1) : i.attachEvent && i.attachEvent("onunload", re)), n.attributes = ue(function (e) { return e.className = "i", !e.getAttribute("className") }), n.getElementsByTagName = ue(function (e) { return e.appendChild(d.createComment("")), !e.getElementsByTagName("*").length }), n.getElementsByClassName = Q.test(d.getElementsByClassName), n.getById = ue(function (e) { return h.appendChild(e).id = b, !d.getElementsByName || !d.getElementsByName(b).length }), n.getById ? (r.filter.ID = function (e) { var t = e.replace(Z, ee); return function (e) { return e.getAttribute("id") === t } }, r.find.ID = function (e, t) { if ("undefined" != typeof t.getElementById && g) { var n = t.getElementById(e); return n ? [n] : [] } }) : (r.filter.ID = function (e) { var t = e.replace(Z, ee); return function (e) { var n = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id"); return n && n.value === t } }, r.find.ID = function (e, t) { if ("undefined" != typeof t.getElementById && g) { var n, r, i, o = t.getElementById(e); if (o) { if ((n = o.getAttributeNode("id")) && n.value === e) return [o]; i = t.getElementsByName(e), r = 0; while (o = i[r++]) if ((n = o.getAttributeNode("id")) && n.value === e) return [o] } return [] } }), r.find.TAG = n.getElementsByTagName ? function (e, t) { return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : n.qsa ? t.querySelectorAll(e) : void 0 } : function (e, t) { var n, r = [], i = 0, o = t.getElementsByTagName(e); if ("*" === e) { while (n = o[i++]) 1 === n.nodeType && r.push(n); return r } return o }, r.find.CLASS = n.getElementsByClassName && function (e, t) { if ("undefined" != typeof t.getElementsByClassName && g) return t.getElementsByClassName(e) }, v = [], y = [], (n.qsa = Q.test(d.querySelectorAll)) && (ue(function (e) { h.appendChild(e).innerHTML = "<a id='" + b + "'></a><select id='" + b + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && y.push("[*^$]=" + M + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || y.push("\\[" + M + "*(?:value|" + P + ")"), e.querySelectorAll("[id~=" + b + "-]").length || y.push("~="), e.querySelectorAll(":checked").length || y.push(":checked"), e.querySelectorAll("a#" + b + "+*").length || y.push(".#.+[+~]") }), ue(function (e) { e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>"; var t = d.createElement("input"); t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && y.push("name" + M + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && y.push(":enabled", ":disabled"), h.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && y.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), y.push(",.*:") })), (n.matchesSelector = Q.test(m = h.matches || h.webkitMatchesSelector || h.mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector)) && ue(function (e) { n.disconnectedMatch = m.call(e, "*"), m.call(e, "[s!='']:x"), v.push("!=", W) }), y = y.length && new RegExp(y.join("|")), v = v.length && new RegExp(v.join("|")), t = Q.test(h.compareDocumentPosition), x = t || Q.test(h.contains) ? function (e, t) { var n = 9 === e.nodeType ? e.documentElement : e, r = t && t.parentNode; return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))) } : function (e, t) { if (t) while (t = t.parentNode) if (t === e) return !0; return !1 }, D = t ? function (e, t) { if (e === t) return f = !0, 0; var r = !e.compareDocumentPosition - !t.compareDocumentPosition; return r || (1 & (r = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !n.sortDetached && t.compareDocumentPosition(e) === r ? e === d || e.ownerDocument === w && x(w, e) ? -1 : t === d || t.ownerDocument === w && x(w, t) ? 1 : c ? O(c, e) - O(c, t) : 0 : 4 & r ? -1 : 1) } : function (e, t) { if (e === t) return f = !0, 0; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; if (!i || !o) return e === d ? -1 : t === d ? 1 : i ? -1 : o ? 1 : c ? O(c, e) - O(c, t) : 0; if (i === o) return ce(e, t); n = e; while (n = n.parentNode) a.unshift(n); n = t; while (n = n.parentNode) s.unshift(n); while (a[r] === s[r]) r++; return r ? ce(a[r], s[r]) : a[r] === w ? -1 : s[r] === w ? 1 : 0 }, d) : d }, oe.matches = function (e, t) { return oe(e, null, null, t) }, oe.matchesSelector = function (e, t) { if ((e.ownerDocument || e) !== d && p(e), t = t.replace(z, "='$1']"), n.matchesSelector && g && !S[t + " "] && (!v || !v.test(t)) && (!y || !y.test(t))) try { var r = m.call(e, t); if (r || n.disconnectedMatch || e.document && 11 !== e.document.nodeType) return r } catch (e) { } return oe(t, d, null, [e]).length > 0 }, oe.contains = function (e, t) { return (e.ownerDocument || e) !== d && p(e), x(e, t) }, oe.attr = function (e, t) { (e.ownerDocument || e) !== d && p(e); var i = r.attrHandle[t.toLowerCase()], o = i && N.call(r.attrHandle, t.toLowerCase()) ? i(e, t, !g) : void 0; return void 0 !== o ? o : n.attributes || !g ? e.getAttribute(t) : (o = e.getAttributeNode(t)) && o.specified ? o.value : null }, oe.escape = function (e) { return (e + "").replace(te, ne) }, oe.error = function (e) { throw new Error("Syntax error, unrecognized expression: " + e) }, oe.uniqueSort = function (e) { var t, r = [], i = 0, o = 0; if (f = !n.detectDuplicates, c = !n.sortStable && e.slice(0), e.sort(D), f) { while (t = e[o++]) t === e[o] && (i = r.push(o)); while (i--) e.splice(r[i], 1) } return c = null, e }, i = oe.getText = function (e) { var t, n = "", r = 0, o = e.nodeType; if (o) { if (1 === o || 9 === o || 11 === o) { if ("string" == typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling)n += i(e) } else if (3 === o || 4 === o) return e.nodeValue } else while (t = e[r++]) n += i(t); return n }, (r = oe.selectors = { cacheLength: 50, createPseudo: se, match: V, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function (e) { return e[1] = e[1].replace(Z, ee), e[3] = (e[3] || e[4] || e[5] || "").replace(Z, ee), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4) }, CHILD: function (e) { return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || oe.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && oe.error(e[0]), e }, PSEUDO: function (e) { var t, n = !e[6] && e[2]; return V.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && X.test(n) && (t = a(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3)) } }, filter: { TAG: function (e) { var t = e.replace(Z, ee).toLowerCase(); return "*" === e ? function () { return !0 } : function (e) { return e.nodeName && e.nodeName.toLowerCase() === t } }, CLASS: function (e) { var t = E[e + " "]; return t || (t = new RegExp("(^|" + M + ")" + e + "(" + M + "|$)")) && E(e, function (e) { return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "") }) }, ATTR: function (e, t, n) { return function (r) { var i = oe.attr(r, e); return null == i ? "!=" === t : !t || (i += "", "=" === t ? i === n : "!=" === t ? i !== n : "^=" === t ? n && 0 === i.indexOf(n) : "*=" === t ? n && i.indexOf(n) > -1 : "$=" === t ? n && i.slice(-n.length) === n : "~=" === t ? (" " + i.replace($, " ") + " ").indexOf(n) > -1 : "|=" === t && (i === n || i.slice(0, n.length + 1) === n + "-")) } }, CHILD: function (e, t, n, r, i) { var o = "nth" !== e.slice(0, 3), a = "last" !== e.slice(-4), s = "of-type" === t; return 1 === r && 0 === i ? function (e) { return !!e.parentNode } : function (t, n, u) { var l, c, f, p, d, h, g = o !== a ? "nextSibling" : "previousSibling", y = t.parentNode, v = s && t.nodeName.toLowerCase(), m = !u && !s, x = !1; if (y) { if (o) { while (g) { p = t; while (p = p[g]) if (s ? p.nodeName.toLowerCase() === v : 1 === p.nodeType) return !1; h = g = "only" === e && !h && "nextSibling" } return !0 } if (h = [a ? y.firstChild : y.lastChild], a && m) { x = (d = (l = (c = (f = (p = y)[b] || (p[b] = {}))[p.uniqueID] || (f[p.uniqueID] = {}))[e] || [])[0] === T && l[1]) && l[2], p = d && y.childNodes[d]; while (p = ++d && p && p[g] || (x = d = 0) || h.pop()) if (1 === p.nodeType && ++x && p === t) { c[e] = [T, d, x]; break } } else if (m && (x = d = (l = (c = (f = (p = t)[b] || (p[b] = {}))[p.uniqueID] || (f[p.uniqueID] = {}))[e] || [])[0] === T && l[1]), !1 === x) while (p = ++d && p && p[g] || (x = d = 0) || h.pop()) if ((s ? p.nodeName.toLowerCase() === v : 1 === p.nodeType) && ++x && (m && ((c = (f = p[b] || (p[b] = {}))[p.uniqueID] || (f[p.uniqueID] = {}))[e] = [T, x]), p === t)) break; return (x -= i) === r || x % r == 0 && x / r >= 0 } } }, PSEUDO: function (e, t) { var n, i = r.pseudos[e] || r.setFilters[e.toLowerCase()] || oe.error("unsupported pseudo: " + e); return i[b] ? i(t) : i.length > 1 ? (n = [e, e, "", t], r.setFilters.hasOwnProperty(e.toLowerCase()) ? se(function (e, n) { var r, o = i(e, t), a = o.length; while (a--) e[r = O(e, o[a])] = !(n[r] = o[a]) }) : function (e) { return i(e, 0, n) }) : i } }, pseudos: { not: se(function (e) { var t = [], n = [], r = s(e.replace(B, "$1")); return r[b] ? se(function (e, t, n, i) { var o, a = r(e, null, i, []), s = e.length; while (s--) (o = a[s]) && (e[s] = !(t[s] = o)) }) : function (e, i, o) { return t[0] = e, r(t, null, o, n), t[0] = null, !n.pop() } }), has: se(function (e) { return function (t) { return oe(e, t).length > 0 } }), contains: se(function (e) { return e = e.replace(Z, ee), function (t) { return (t.textContent || t.innerText || i(t)).indexOf(e) > -1 } }), lang: se(function (e) { return U.test(e || "") || oe.error("unsupported lang: " + e), e = e.replace(Z, ee).toLowerCase(), function (t) { var n; do { if (n = g ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return (n = n.toLowerCase()) === e || 0 === n.indexOf(e + "-") } while ((t = t.parentNode) && 1 === t.nodeType); return !1 } }), target: function (t) { var n = e.location && e.location.hash; return n && n.slice(1) === t.id }, root: function (e) { return e === h }, focus: function (e) { return e === d.activeElement && (!d.hasFocus || d.hasFocus()) && !!(e.type || e.href || ~e.tabIndex) }, enabled: de(!1), disabled: de(!0), checked: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && !!e.checked || "option" === t && !!e.selected }, selected: function (e) { return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected }, empty: function (e) { for (e = e.firstChild; e; e = e.nextSibling)if (e.nodeType < 6) return !1; return !0 }, parent: function (e) { return !r.pseudos.empty(e) }, header: function (e) { return Y.test(e.nodeName) }, input: function (e) { return G.test(e.nodeName) }, button: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && "button" === e.type || "button" === t }, text: function (e) { var t; return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase()) }, first: he(function () { return [0] }), last: he(function (e, t) { return [t - 1] }), eq: he(function (e, t, n) { return [n < 0 ? n + t : n] }), even: he(function (e, t) { for (var n = 0; n < t; n += 2)e.push(n); return e }), odd: he(function (e, t) { for (var n = 1; n < t; n += 2)e.push(n); return e }), lt: he(function (e, t, n) { for (var r = n < 0 ? n + t : n; --r >= 0;)e.push(r); return e }), gt: he(function (e, t, n) { for (var r = n < 0 ? n + t : n; ++r < t;)e.push(r); return e }) } }).pseudos.nth = r.pseudos.eq; for (t in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) r.pseudos[t] = fe(t); for (t in { submit: !0, reset: !0 }) r.pseudos[t] = pe(t); function ye() { } ye.prototype = r.filters = r.pseudos, r.setFilters = new ye, a = oe.tokenize = function (e, t) { var n, i, o, a, s, u, l, c = k[e + " "]; if (c) return t ? 0 : c.slice(0); s = e, u = [], l = r.preFilter; while (s) { n && !(i = F.exec(s)) || (i && (s = s.slice(i[0].length) || s), u.push(o = [])), n = !1, (i = _.exec(s)) && (n = i.shift(), o.push({ value: n, type: i[0].replace(B, " ") }), s = s.slice(n.length)); for (a in r.filter) !(i = V[a].exec(s)) || l[a] && !(i = l[a](i)) || (n = i.shift(), o.push({ value: n, type: a, matches: i }), s = s.slice(n.length)); if (!n) break } return t ? s.length : s ? oe.error(e) : k(e, u).slice(0) }; function ve(e) { for (var t = 0, n = e.length, r = ""; t < n; t++)r += e[t].value; return r } function me(e, t, n) { var r = t.dir, i = t.next, o = i || r, a = n && "parentNode" === o, s = C++; return t.first ? function (t, n, i) { while (t = t[r]) if (1 === t.nodeType || a) return e(t, n, i); return !1 } : function (t, n, u) { var l, c, f, p = [T, s]; if (u) { while (t = t[r]) if ((1 === t.nodeType || a) && e(t, n, u)) return !0 } else while (t = t[r]) if (1 === t.nodeType || a) if (f = t[b] || (t[b] = {}), c = f[t.uniqueID] || (f[t.uniqueID] = {}), i && i === t.nodeName.toLowerCase()) t = t[r] || t; else { if ((l = c[o]) && l[0] === T && l[1] === s) return p[2] = l[2]; if (c[o] = p, p[2] = e(t, n, u)) return !0 } return !1 } } function xe(e) { return e.length > 1 ? function (t, n, r) { var i = e.length; while (i--) if (!e[i](t, n, r)) return !1; return !0 } : e[0] } function be(e, t, n) { for (var r = 0, i = t.length; r < i; r++)oe(e, t[r], n); return n } function we(e, t, n, r, i) { for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s))); return a } function Te(e, t, n, r, i, o) { return r && !r[b] && (r = Te(r)), i && !i[b] && (i = Te(i, o)), se(function (o, a, s, u) { var l, c, f, p = [], d = [], h = a.length, g = o || be(t || "*", s.nodeType ? [s] : s, []), y = !e || !o && t ? g : we(g, p, e, s, u), v = n ? i || (o ? e : h || r) ? [] : a : y; if (n && n(y, v, s, u), r) { l = we(v, d), r(l, [], s, u), c = l.length; while (c--) (f = l[c]) && (v[d[c]] = !(y[d[c]] = f)) } if (o) { if (i || e) { if (i) { l = [], c = v.length; while (c--) (f = v[c]) && l.push(y[c] = f); i(null, v = [], l, u) } c = v.length; while (c--) (f = v[c]) && (l = i ? O(o, f) : p[c]) > -1 && (o[l] = !(a[l] = f)) } } else v = we(v === a ? v.splice(h, v.length) : v), i ? i(null, a, v, u) : L.apply(a, v) }) } function Ce(e) { for (var t, n, i, o = e.length, a = r.relative[e[0].type], s = a || r.relative[" "], u = a ? 1 : 0, c = me(function (e) { return e === t }, s, !0), f = me(function (e) { return O(t, e) > -1 }, s, !0), p = [function (e, n, r) { var i = !a && (r || n !== l) || ((t = n).nodeType ? c(e, n, r) : f(e, n, r)); return t = null, i }]; u < o; u++)if (n = r.relative[e[u].type]) p = [me(xe(p), n)]; else { if ((n = r.filter[e[u].type].apply(null, e[u].matches))[b]) { for (i = ++u; i < o; i++)if (r.relative[e[i].type]) break; return Te(u > 1 && xe(p), u > 1 && ve(e.slice(0, u - 1).concat({ value: " " === e[u - 2].type ? "*" : "" })).replace(B, "$1"), n, u < i && Ce(e.slice(u, i)), i < o && Ce(e = e.slice(i)), i < o && ve(e)) } p.push(n) } return xe(p) } function Ee(e, t) { var n = t.length > 0, i = e.length > 0, o = function (o, a, s, u, c) { var f, h, y, v = 0, m = "0", x = o && [], b = [], w = l, C = o || i && r.find.TAG("*", c), E = T += null == w ? 1 : Math.random() || .1, k = C.length; for (c && (l = a === d || a || c); m !== k && null != (f = C[m]); m++) { if (i && f) { h = 0, a || f.ownerDocument === d || (p(f), s = !g); while (y = e[h++]) if (y(f, a || d, s)) { u.push(f); break } c && (T = E) } n && ((f = !y && f) && v--, o && x.push(f)) } if (v += m, n && m !== v) { h = 0; while (y = t[h++]) y(x, b, a, s); if (o) { if (v > 0) while (m--) x[m] || b[m] || (b[m] = j.call(u)); b = we(b) } L.apply(u, b), c && !o && b.length > 0 && v + t.length > 1 && oe.uniqueSort(u) } return c && (T = E, l = w), x }; return n ? se(o) : o } return s = oe.compile = function (e, t) { var n, r = [], i = [], o = S[e + " "]; if (!o) { t || (t = a(e)), n = t.length; while (n--) (o = Ce(t[n]))[b] ? r.push(o) : i.push(o); (o = S(e, Ee(i, r))).selector = e } return o }, u = oe.select = function (e, t, n, i) { var o, u, l, c, f, p = "function" == typeof e && e, d = !i && a(e = p.selector || e); if (n = n || [], 1 === d.length) { if ((u = d[0] = d[0].slice(0)).length > 2 && "ID" === (l = u[0]).type && 9 === t.nodeType && g && r.relative[u[1].type]) { if (!(t = (r.find.ID(l.matches[0].replace(Z, ee), t) || [])[0])) return n; p && (t = t.parentNode), e = e.slice(u.shift().value.length) } o = V.needsContext.test(e) ? 0 : u.length; while (o--) { if (l = u[o], r.relative[c = l.type]) break; if ((f = r.find[c]) && (i = f(l.matches[0].replace(Z, ee), K.test(u[0].type) && ge(t.parentNode) || t))) { if (u.splice(o, 1), !(e = i.length && ve(u))) return L.apply(n, i), n; break } } } return (p || s(e, d))(i, t, !g, n, !t || K.test(e) && ge(t.parentNode) || t), n }, n.sortStable = b.split("").sort(D).join("") === b, n.detectDuplicates = !!f, p(), n.sortDetached = ue(function (e) { return 1 & e.compareDocumentPosition(d.createElement("fieldset")) }), ue(function (e) { return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href") }) || le("type|href|height|width", function (e, t, n) { if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2) }), n.attributes && ue(function (e) { return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value") }) || le("value", function (e, t, n) { if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue }), ue(function (e) { return null == e.getAttribute("disabled") }) || le(P, function (e, t, n) { var r; if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null }), oe }(e); w.find = E, w.expr = E.selectors, w.expr[":"] = w.expr.pseudos, w.uniqueSort = w.unique = E.uniqueSort, w.text = E.getText, w.isXMLDoc = E.isXML, w.contains = E.contains, w.escapeSelector = E.escape; var k = function (e, t, n) { var r = [], i = void 0 !== n; while ((e = e[t]) && 9 !== e.nodeType) if (1 === e.nodeType) { if (i && w(e).is(n)) break; r.push(e) } return r }, S = function (e, t) { for (var n = []; e; e = e.nextSibling)1 === e.nodeType && e !== t && n.push(e); return n }, D = w.expr.match.needsContext; function N(e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase() } var A = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; function j(e, t, n) { return g(t) ? w.grep(e, function (e, r) { return !!t.call(e, r, e) !== n }) : t.nodeType ? w.grep(e, function (e) { return e === t !== n }) : "string" != typeof t ? w.grep(e, function (e) { return u.call(t, e) > -1 !== n }) : w.filter(t, e, n) } w.filter = function (e, t, n) { var r = t[0]; return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? w.find.matchesSelector(r, e) ? [r] : [] : w.find.matches(e, w.grep(t, function (e) { return 1 === e.nodeType })) }, w.fn.extend({ find: function (e) { var t, n, r = this.length, i = this; if ("string" != typeof e) return this.pushStack(w(e).filter(function () { for (t = 0; t < r; t++)if (w.contains(i[t], this)) return !0 })); for (n = this.pushStack([]), t = 0; t < r; t++)w.find(e, i[t], n); return r > 1 ? w.uniqueSort(n) : n }, filter: function (e) { return this.pushStack(j(this, e || [], !1)) }, not: function (e) { return this.pushStack(j(this, e || [], !0)) }, is: function (e) { return !!j(this, "string" == typeof e && D.test(e) ? w(e) : e || [], !1).length } }); var q, L = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/; (w.fn.init = function (e, t, n) { var i, o; if (!e) return this; if (n = n || q, "string" == typeof e) { if (!(i = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : L.exec(e)) || !i[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e); if (i[1]) { if (t = t instanceof w ? t[0] : t, w.merge(this, w.parseHTML(i[1], t && t.nodeType ? t.ownerDocument || t : r, !0)), A.test(i[1]) && w.isPlainObject(t)) for (i in t) g(this[i]) ? this[i](t[i]) : this.attr(i, t[i]); return this } return (o = r.getElementById(i[2])) && (this[0] = o, this.length = 1), this } return e.nodeType ? (this[0] = e, this.length = 1, this) : g(e) ? void 0 !== n.ready ? n.ready(e) : e(w) : w.makeArray(e, this) }).prototype = w.fn, q = w(r); var H = /^(?:parents|prev(?:Until|All))/, O = { children: !0, contents: !0, next: !0, prev: !0 }; w.fn.extend({ has: function (e) { var t = w(e, this), n = t.length; return this.filter(function () { for (var e = 0; e < n; e++)if (w.contains(this, t[e])) return !0 }) }, closest: function (e, t) { var n, r = 0, i = this.length, o = [], a = "string" != typeof e && w(e); if (!D.test(e)) for (; r < i; r++)for (n = this[r]; n && n !== t; n = n.parentNode)if (n.nodeType < 11 && (a ? a.index(n) > -1 : 1 === n.nodeType && w.find.matchesSelector(n, e))) { o.push(n); break } return this.pushStack(o.length > 1 ? w.uniqueSort(o) : o) }, index: function (e) { return e ? "string" == typeof e ? u.call(w(e), this[0]) : u.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 }, add: function (e, t) { return this.pushStack(w.uniqueSort(w.merge(this.get(), w(e, t)))) }, addBack: function (e) { return this.add(null == e ? this.prevObject : this.prevObject.filter(e)) } }); function P(e, t) { while ((e = e[t]) && 1 !== e.nodeType); return e } w.each({ parent: function (e) { var t = e.parentNode; return t && 11 !== t.nodeType ? t : null }, parents: function (e) { return k(e, "parentNode") }, parentsUntil: function (e, t, n) { return k(e, "parentNode", n) }, next: function (e) { return P(e, "nextSibling") }, prev: function (e) { return P(e, "previousSibling") }, nextAll: function (e) { return k(e, "nextSibling") }, prevAll: function (e) { return k(e, "previousSibling") }, nextUntil: function (e, t, n) { return k(e, "nextSibling", n) }, prevUntil: function (e, t, n) { return k(e, "previousSibling", n) }, siblings: function (e) { return S((e.parentNode || {}).firstChild, e) }, children: function (e) { return S(e.firstChild) }, contents: function (e) { return N(e, "iframe") ? e.contentDocument : (N(e, "template") && (e = e.content || e), w.merge([], e.childNodes)) } }, function (e, t) { w.fn[e] = function (n, r) { var i = w.map(this, t, n); return "Until" !== e.slice(-5) && (r = n), r && "string" == typeof r && (i = w.filter(r, i)), this.length > 1 && (O[e] || w.uniqueSort(i), H.test(e) && i.reverse()), this.pushStack(i) } }); var M = /[^\x20\t\r\n\f]+/g; function R(e) { var t = {}; return w.each(e.match(M) || [], function (e, n) { t[n] = !0 }), t } w.Callbacks = function (e) { e = "string" == typeof e ? R(e) : w.extend({}, e); var t, n, r, i, o = [], a = [], s = -1, u = function () { for (i = i || e.once, r = t = !0; a.length; s = -1) { n = a.shift(); while (++s < o.length) !1 === o[s].apply(n[0], n[1]) && e.stopOnFalse && (s = o.length, n = !1) } e.memory || (n = !1), t = !1, i && (o = n ? [] : "") }, l = { add: function () { return o && (n && !t && (s = o.length - 1, a.push(n)), function t(n) { w.each(n, function (n, r) { g(r) ? e.unique && l.has(r) || o.push(r) : r && r.length && "string" !== x(r) && t(r) }) }(arguments), n && !t && u()), this }, remove: function () { return w.each(arguments, function (e, t) { var n; while ((n = w.inArray(t, o, n)) > -1) o.splice(n, 1), n <= s && s-- }), this }, has: function (e) { return e ? w.inArray(e, o) > -1 : o.length > 0 }, empty: function () { return o && (o = []), this }, disable: function () { return i = a = [], o = n = "", this }, disabled: function () { return !o }, lock: function () { return i = a = [], n || t || (o = n = ""), this }, locked: function () { return !!i }, fireWith: function (e, n) { return i || (n = [e, (n = n || []).slice ? n.slice() : n], a.push(n), t || u()), this }, fire: function () { return l.fireWith(this, arguments), this }, fired: function () { return !!r } }; return l }; function I(e) { return e } function W(e) { throw e } function $(e, t, n, r) { var i; try { e && g(i = e.promise) ? i.call(e).done(t).fail(n) : e && g(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r)) } catch (e) { n.apply(void 0, [e]) } } w.extend({ Deferred: function (t) { var n = [["notify", "progress", w.Callbacks("memory"), w.Callbacks("memory"), 2], ["resolve", "done", w.Callbacks("once memory"), w.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", w.Callbacks("once memory"), w.Callbacks("once memory"), 1, "rejected"]], r = "pending", i = { state: function () { return r }, always: function () { return o.done(arguments).fail(arguments), this }, "catch": function (e) { return i.then(null, e) }, pipe: function () { var e = arguments; return w.Deferred(function (t) { w.each(n, function (n, r) { var i = g(e[r[4]]) && e[r[4]]; o[r[1]](function () { var e = i && i.apply(this, arguments); e && g(e.promise) ? e.promise().progress(t.notify).done(t.resolve).fail(t.reject) : t[r[0] + "With"](this, i ? [e] : arguments) }) }), e = null }).promise() }, then: function (t, r, i) { var o = 0; function a(t, n, r, i) { return function () { var s = this, u = arguments, l = function () { var e, l; if (!(t < o)) { if ((e = r.apply(s, u)) === n.promise()) throw new TypeError("Thenable self-resolution"); l = e && ("object" == typeof e || "function" == typeof e) && e.then, g(l) ? i ? l.call(e, a(o, n, I, i), a(o, n, W, i)) : (o++, l.call(e, a(o, n, I, i), a(o, n, W, i), a(o, n, I, n.notifyWith))) : (r !== I && (s = void 0, u = [e]), (i || n.resolveWith)(s, u)) } }, c = i ? l : function () { try { l() } catch (e) { w.Deferred.exceptionHook && w.Deferred.exceptionHook(e, c.stackTrace), t + 1 >= o && (r !== W && (s = void 0, u = [e]), n.rejectWith(s, u)) } }; t ? c() : (w.Deferred.getStackHook && (c.stackTrace = w.Deferred.getStackHook()), e.setTimeout(c)) } } return w.Deferred(function (e) { n[0][3].add(a(0, e, g(i) ? i : I, e.notifyWith)), n[1][3].add(a(0, e, g(t) ? t : I)), n[2][3].add(a(0, e, g(r) ? r : W)) }).promise() }, promise: function (e) { return null != e ? w.extend(e, i) : i } }, o = {}; return w.each(n, function (e, t) { var a = t[2], s = t[5]; i[t[1]] = a.add, s && a.add(function () { r = s }, n[3 - e][2].disable, n[3 - e][3].disable, n[0][2].lock, n[0][3].lock), a.add(t[3].fire), o[t[0]] = function () { return o[t[0] + "With"](this === o ? void 0 : this, arguments), this }, o[t[0] + "With"] = a.fireWith }), i.promise(o), t && t.call(o, o), o }, when: function (e) { var t = arguments.length, n = t, r = Array(n), i = o.call(arguments), a = w.Deferred(), s = function (e) { return function (n) { r[e] = this, i[e] = arguments.length > 1 ? o.call(arguments) : n, --t || a.resolveWith(r, i) } }; if (t <= 1 && ($(e, a.done(s(n)).resolve, a.reject, !t), "pending" === a.state() || g(i[n] && i[n].then))) return a.then(); while (n--) $(i[n], s(n), a.reject); return a.promise() } }); var B = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/; w.Deferred.exceptionHook = function (t, n) { e.console && e.console.warn && t && B.test(t.name) && e.console.warn("jQuery.Deferred exception: " + t.message, t.stack, n) }, w.readyException = function (t) { e.setTimeout(function () { throw t }) }; var F = w.Deferred(); w.fn.ready = function (e) { return F.then(e)["catch"](function (e) { w.readyException(e) }), this }, w.extend({ isReady: !1, readyWait: 1, ready: function (e) { (!0 === e ? --w.readyWait : w.isReady) || (w.isReady = !0, !0 !== e && --w.readyWait > 0 || F.resolveWith(r, [w])) } }), w.ready.then = F.then; function _() { r.removeEventListener("DOMContentLoaded", _), e.removeEventListener("load", _), w.ready() } "complete" === r.readyState || "loading" !== r.readyState && !r.documentElement.doScroll ? e.setTimeout(w.ready) : (r.addEventListener("DOMContentLoaded", _), e.addEventListener("load", _)); var z = function (e, t, n, r, i, o, a) { var s = 0, u = e.length, l = null == n; if ("object" === x(n)) { i = !0; for (s in n) z(e, t, s, n[s], !0, o, a) } else if (void 0 !== r && (i = !0, g(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function (e, t, n) { return l.call(w(e), n) })), t)) for (; s < u; s++)t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n))); return i ? e : l ? t.call(e) : u ? t(e[0], n) : o }, X = /^-ms-/, U = /-([a-z])/g; function V(e, t) { return t.toUpperCase() } function G(e) { return e.replace(X, "ms-").replace(U, V) } var Y = function (e) { return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType }; function Q() { this.expando = w.expando + Q.uid++ } Q.uid = 1, Q.prototype = { cache: function (e) { var t = e[this.expando]; return t || (t = {}, Y(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, { value: t, configurable: !0 }))), t }, set: function (e, t, n) { var r, i = this.cache(e); if ("string" == typeof t) i[G(t)] = n; else for (r in t) i[G(r)] = t[r]; return i }, get: function (e, t) { return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][G(t)] }, access: function (e, t, n) { return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t) }, remove: function (e, t) { var n, r = e[this.expando]; if (void 0 !== r) { if (void 0 !== t) { n = (t = Array.isArray(t) ? t.map(G) : (t = G(t)) in r ? [t] : t.match(M) || []).length; while (n--) delete r[t[n]] } (void 0 === t || w.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]) } }, hasData: function (e) { var t = e[this.expando]; return void 0 !== t && !w.isEmptyObject(t) } }; var J = new Q, K = new Q, Z = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, ee = /[A-Z]/g; function te(e) { return "true" === e || "false" !== e && ("null" === e ? null : e === +e + "" ? +e : Z.test(e) ? JSON.parse(e) : e) } function ne(e, t, n) { var r; if (void 0 === n && 1 === e.nodeType) if (r = "data-" + t.replace(ee, "-$&").toLowerCase(), "string" == typeof (n = e.getAttribute(r))) { try { n = te(n) } catch (e) { } K.set(e, t, n) } else n = void 0; return n } w.extend({ hasData: function (e) { return K.hasData(e) || J.hasData(e) }, data: function (e, t, n) { return K.access(e, t, n) }, removeData: function (e, t) { K.remove(e, t) }, _data: function (e, t, n) { return J.access(e, t, n) }, _removeData: function (e, t) { J.remove(e, t) } }), w.fn.extend({ data: function (e, t) { var n, r, i, o = this[0], a = o && o.attributes; if (void 0 === e) { if (this.length && (i = K.get(o), 1 === o.nodeType && !J.get(o, "hasDataAttrs"))) { n = a.length; while (n--) a[n] && 0 === (r = a[n].name).indexOf("data-") && (r = G(r.slice(5)), ne(o, r, i[r])); J.set(o, "hasDataAttrs", !0) } return i } return "object" == typeof e ? this.each(function () { K.set(this, e) }) : z(this, function (t) { var n; if (o && void 0 === t) { if (void 0 !== (n = K.get(o, e))) return n; if (void 0 !== (n = ne(o, e))) return n } else this.each(function () { K.set(this, e, t) }) }, null, t, arguments.length > 1, null, !0) }, removeData: function (e) { return this.each(function () { K.remove(this, e) }) } }), w.extend({ queue: function (e, t, n) { var r; if (e) return t = (t || "fx") + "queue", r = J.get(e, t), n && (!r || Array.isArray(n) ? r = J.access(e, t, w.makeArray(n)) : r.push(n)), r || [] }, dequeue: function (e, t) { t = t || "fx"; var n = w.queue(e, t), r = n.length, i = n.shift(), o = w._queueHooks(e, t), a = function () { w.dequeue(e, t) }; "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, a, o)), !r && o && o.empty.fire() }, _queueHooks: function (e, t) { var n = t + "queueHooks"; return J.get(e, n) || J.access(e, n, { empty: w.Callbacks("once memory").add(function () { J.remove(e, [t + "queue", n]) }) }) } }), w.fn.extend({ queue: function (e, t) { var n = 2; return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? w.queue(this[0], e) : void 0 === t ? this : this.each(function () { var n = w.queue(this, e, t); w._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && w.dequeue(this, e) }) }, dequeue: function (e) { return this.each(function () { w.dequeue(this, e) }) }, clearQueue: function (e) { return this.queue(e || "fx", []) }, promise: function (e, t) { var n, r = 1, i = w.Deferred(), o = this, a = this.length, s = function () { --r || i.resolveWith(o, [o]) }; "string" != typeof e && (t = e, e = void 0), e = e || "fx"; while (a--) (n = J.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s)); return s(), i.promise(t) } }); var re = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, ie = new RegExp("^(?:([+-])=|)(" + re + ")([a-z%]*)$", "i"), oe = ["Top", "Right", "Bottom", "Left"], ae = function (e, t) { return "none" === (e = t || e).style.display || "" === e.style.display && w.contains(e.ownerDocument, e) && "none" === w.css(e, "display") }, se = function (e, t, n, r) { var i, o, a = {}; for (o in t) a[o] = e.style[o], e.style[o] = t[o]; i = n.apply(e, r || []); for (o in t) e.style[o] = a[o]; return i }; function ue(e, t, n, r) { var i, o, a = 20, s = r ? function () { return r.cur() } : function () { return w.css(e, t, "") }, u = s(), l = n && n[3] || (w.cssNumber[t] ? "" : "px"), c = (w.cssNumber[t] || "px" !== l && +u) && ie.exec(w.css(e, t)); if (c && c[3] !== l) { u /= 2, l = l || c[3], c = +u || 1; while (a--) w.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o; c *= 2, w.style(e, t, c + l), n = n || [] } return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i } var le = {}; function ce(e) { var t, n = e.ownerDocument, r = e.nodeName, i = le[r]; return i || (t = n.body.appendChild(n.createElement(r)), i = w.css(t, "display"), t.parentNode.removeChild(t), "none" === i && (i = "block"), le[r] = i, i) } function fe(e, t) { for (var n, r, i = [], o = 0, a = e.length; o < a; o++)(r = e[o]).style && (n = r.style.display, t ? ("none" === n && (i[o] = J.get(r, "display") || null, i[o] || (r.style.display = "")), "" === r.style.display && ae(r) && (i[o] = ce(r))) : "none" !== n && (i[o] = "none", J.set(r, "display", n))); for (o = 0; o < a; o++)null != i[o] && (e[o].style.display = i[o]); return e } w.fn.extend({ show: function () { return fe(this, !0) }, hide: function () { return fe(this) }, toggle: function (e) { return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () { ae(this) ? w(this).show() : w(this).hide() }) } }); var pe = /^(?:checkbox|radio)$/i, de = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i, he = /^$|^module$|\/(?:java|ecma)script/i, ge = { option: [1, "<select multiple='multiple'>", "</select>"], thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] }; ge.optgroup = ge.option, ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td; function ye(e, t) { var n; return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && N(e, t) ? w.merge([e], n) : n } function ve(e, t) { for (var n = 0, r = e.length; n < r; n++)J.set(e[n], "globalEval", !t || J.get(t[n], "globalEval")) } var me = /<|&#?\w+;/; function xe(e, t, n, r, i) { for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++)if ((o = e[d]) || 0 === o) if ("object" === x(o)) w.merge(p, o.nodeType ? [o] : o); else if (me.test(o)) { a = a || f.appendChild(t.createElement("div")), s = (de.exec(o) || ["", ""])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + w.htmlPrefilter(o) + u[2], c = u[0]; while (c--) a = a.lastChild; w.merge(p, a.childNodes), (a = f.firstChild).textContent = "" } else p.push(t.createTextNode(o)); f.textContent = "", d = 0; while (o = p[d++]) if (r && w.inArray(o, r) > -1) i && i.push(o); else if (l = w.contains(o.ownerDocument, o), a = ye(f.appendChild(o), "script"), l && ve(a), n) { c = 0; while (o = a[c++]) he.test(o.type || "") && n.push(o) } return f } !function () { var e = r.createDocumentFragment().appendChild(r.createElement("div")), t = r.createElement("input"); t.setAttribute("type", "radio"), t.setAttribute("checked", "checked"), t.setAttribute("name", "t"), e.appendChild(t), h.checkClone = e.cloneNode(!0).cloneNode(!0).lastChild.checked, e.innerHTML = "<textarea>x</textarea>", h.noCloneChecked = !!e.cloneNode(!0).lastChild.defaultValue }(); var be = r.documentElement, we = /^key/, Te = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, Ce = /^([^.]*)(?:\.(.+)|)/; function Ee() { return !0 } function ke() { return !1 } function Se() { try { return r.activeElement } catch (e) { } } function De(e, t, n, r, i, o) { var a, s; if ("object" == typeof t) { "string" != typeof n && (r = r || n, n = void 0); for (s in t) De(e, s, n, r, t[s], o); return e } if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = ke; else if (!i) return e; return 1 === o && (a = i, (i = function (e) { return w().off(e), a.apply(this, arguments) }).guid = a.guid || (a.guid = w.guid++)), e.each(function () { w.event.add(this, t, i, r, n) }) } w.event = { global: {}, add: function (e, t, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, y = J.get(e); if (y) { n.handler && (n = (o = n).handler, i = o.selector), i && w.find.matchesSelector(be, i), n.guid || (n.guid = w.guid++), (u = y.events) || (u = y.events = {}), (a = y.handle) || (a = y.handle = function (t) { return "undefined" != typeof w && w.event.triggered !== t.type ? w.event.dispatch.apply(e, arguments) : void 0 }), l = (t = (t || "").match(M) || [""]).length; while (l--) d = g = (s = Ce.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), d && (f = w.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = w.event.special[d] || {}, c = w.extend({ type: d, origType: g, data: r, handler: n, guid: n.guid, selector: i, needsContext: i && w.expr.match.needsContext.test(i), namespace: h.join(".") }, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(e, r, h, a) || e.addEventListener && e.addEventListener(d, a)), f.add && (f.add.call(e, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), w.event.global[d] = !0) } }, remove: function (e, t, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, y = J.hasData(e) && J.get(e); if (y && (u = y.events)) { l = (t = (t || "").match(M) || [""]).length; while (l--) if (s = Ce.exec(t[l]) || [], d = g = s[1], h = (s[2] || "").split(".").sort(), d) { f = w.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = p.length; while (o--) c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c)); a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, y.handle) || w.removeEvent(e, d, y.handle), delete u[d]) } else for (d in u) w.event.remove(e, d + t[l], n, r, !0); w.isEmptyObject(u) && J.remove(e, "handle events") } }, dispatch: function (e) { var t = w.event.fix(e), n, r, i, o, a, s, u = new Array(arguments.length), l = (J.get(this, "events") || {})[t.type] || [], c = w.event.special[t.type] || {}; for (u[0] = t, n = 1; n < arguments.length; n++)u[n] = arguments[n]; if (t.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, t)) { s = w.event.handlers.call(this, t, l), n = 0; while ((o = s[n++]) && !t.isPropagationStopped()) { t.currentTarget = o.elem, r = 0; while ((a = o.handlers[r++]) && !t.isImmediatePropagationStopped()) t.rnamespace && !t.rnamespace.test(a.namespace) || (t.handleObj = a, t.data = a.data, void 0 !== (i = ((w.event.special[a.origType] || {}).handle || a.handler).apply(o.elem, u)) && !1 === (t.result = i) && (t.preventDefault(), t.stopPropagation())) } return c.postDispatch && c.postDispatch.call(this, t), t.result } }, handlers: function (e, t) { var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType && !("click" === e.type && e.button >= 1)) for (; l !== this; l = l.parentNode || this)if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) { for (o = [], a = {}, n = 0; n < u; n++)void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? w(i, this).index(l) > -1 : w.find(i, this, null, [l]).length), a[i] && o.push(r); o.length && s.push({ elem: l, handlers: o }) } return l = this, u < t.length && s.push({ elem: l, handlers: t.slice(u) }), s }, addProp: function (e, t) { Object.defineProperty(w.Event.prototype, e, { enumerable: !0, configurable: !0, get: g(t) ? function () { if (this.originalEvent) return t(this.originalEvent) } : function () { if (this.originalEvent) return this.originalEvent[e] }, set: function (t) { Object.defineProperty(this, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) } }) }, fix: function (e) { return e[w.expando] ? e : new w.Event(e) }, special: { load: { noBubble: !0 }, focus: { trigger: function () { if (this !== Se() && this.focus) return this.focus(), !1 }, delegateType: "focusin" }, blur: { trigger: function () { if (this === Se() && this.blur) return this.blur(), !1 }, delegateType: "focusout" }, click: { trigger: function () { if ("checkbox" === this.type && this.click && N(this, "input")) return this.click(), !1 }, _default: function (e) { return N(e.target, "a") } }, beforeunload: { postDispatch: function (e) { void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result) } } } }, w.removeEvent = function (e, t, n) { e.removeEventListener && e.removeEventListener(t, n) }, w.Event = function (e, t) { if (!(this instanceof w.Event)) return new w.Event(e, t); e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? Ee : ke, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && w.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[w.expando] = !0 }, w.Event.prototype = { constructor: w.Event, isDefaultPrevented: ke, isPropagationStopped: ke, isImmediatePropagationStopped: ke, isSimulated: !1, preventDefault: function () { var e = this.originalEvent; this.isDefaultPrevented = Ee, e && !this.isSimulated && e.preventDefault() }, stopPropagation: function () { var e = this.originalEvent; this.isPropagationStopped = Ee, e && !this.isSimulated && e.stopPropagation() }, stopImmediatePropagation: function () { var e = this.originalEvent; this.isImmediatePropagationStopped = Ee, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation() } }, w.each({ altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, "char": !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which: function (e) { var t = e.button; return null == e.which && we.test(e.type) ? null != e.charCode ? e.charCode : e.keyCode : !e.which && void 0 !== t && Te.test(e.type) ? 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0 : e.which } }, w.event.addProp), w.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function (e, t) { w.event.special[e] = { delegateType: t, bindType: t, handle: function (e) { var n, r = this, i = e.relatedTarget, o = e.handleObj; return i && (i === r || w.contains(r, i)) || (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n } } }), w.fn.extend({ on: function (e, t, n, r) { return De(this, e, t, n, r) }, one: function (e, t, n, r) { return De(this, e, t, n, r, 1) }, off: function (e, t, n) { var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, w(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this; if ("object" == typeof e) { for (i in e) this.off(i, t, e[i]); return this } return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = ke), this.each(function () { w.event.remove(this, e, n, t) }) } }); var Ne = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, Ae = /<script|<style|<link/i, je = /checked\s*(?:[^=]|=\s*.checked.)/i, qe = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; function Le(e, t) { return N(e, "table") && N(11 !== t.nodeType ? t : t.firstChild, "tr") ? w(e).children("tbody")[0] || e : e } function He(e) { return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e } function Oe(e) { return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e } function Pe(e, t) { var n, r, i, o, a, s, u, l; if (1 === t.nodeType) { if (J.hasData(e) && (o = J.access(e), a = J.set(t, o), l = o.events)) { delete a.handle, a.events = {}; for (i in l) for (n = 0, r = l[i].length; n < r; n++)w.event.add(t, i, l[i][n]) } K.hasData(e) && (s = K.access(e), u = w.extend({}, s), K.set(t, u)) } } function Me(e, t) { var n = t.nodeName.toLowerCase(); "input" === n && pe.test(e.type) ? t.checked = e.checked : "input" !== n && "textarea" !== n || (t.defaultValue = e.defaultValue) } function Re(e, t, n, r) { t = a.apply([], t); var i, o, s, u, l, c, f = 0, p = e.length, d = p - 1, y = t[0], v = g(y); if (v || p > 1 && "string" == typeof y && !h.checkClone && je.test(y)) return e.each(function (i) { var o = e.eq(i); v && (t[0] = y.call(this, i, o.html())), Re(o, t, n, r) }); if (p && (i = xe(t, e[0].ownerDocument, !1, e, r), o = i.firstChild, 1 === i.childNodes.length && (i = o), o || r)) { for (u = (s = w.map(ye(i, "script"), He)).length; f < p; f++)l = i, f !== d && (l = w.clone(l, !0, !0), u && w.merge(s, ye(l, "script"))), n.call(e[f], l, f); if (u) for (c = s[s.length - 1].ownerDocument, w.map(s, Oe), f = 0; f < u; f++)l = s[f], he.test(l.type || "") && !J.access(l, "globalEval") && w.contains(c, l) && (l.src && "module" !== (l.type || "").toLowerCase() ? w._evalUrl && w._evalUrl(l.src) : m(l.textContent.replace(qe, ""), c, l)) } return e } function Ie(e, t, n) { for (var r, i = t ? w.filter(t, e) : e, o = 0; null != (r = i[o]); o++)n || 1 !== r.nodeType || w.cleanData(ye(r)), r.parentNode && (n && w.contains(r.ownerDocument, r) && ve(ye(r, "script")), r.parentNode.removeChild(r)); return e } w.extend({ htmlPrefilter: function (e) { return e.replace(Ne, "<$1></$2>") }, clone: function (e, t, n) { var r, i, o, a, s = e.cloneNode(!0), u = w.contains(e.ownerDocument, e); if (!(h.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || w.isXMLDoc(e))) for (a = ye(s), r = 0, i = (o = ye(e)).length; r < i; r++)Me(o[r], a[r]); if (t) if (n) for (o = o || ye(e), a = a || ye(s), r = 0, i = o.length; r < i; r++)Pe(o[r], a[r]); else Pe(e, s); return (a = ye(s, "script")).length > 0 && ve(a, !u && ye(e, "script")), s }, cleanData: function (e) { for (var t, n, r, i = w.event.special, o = 0; void 0 !== (n = e[o]); o++)if (Y(n)) { if (t = n[J.expando]) { if (t.events) for (r in t.events) i[r] ? w.event.remove(n, r) : w.removeEvent(n, r, t.handle); n[J.expando] = void 0 } n[K.expando] && (n[K.expando] = void 0) } } }), w.fn.extend({ detach: function (e) { return Ie(this, e, !0) }, remove: function (e) { return Ie(this, e) }, text: function (e) { return z(this, function (e) { return void 0 === e ? w.text(this) : this.empty().each(function () { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e) }) }, null, e, arguments.length) }, append: function () { return Re(this, arguments, function (e) { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Le(this, e).appendChild(e) }) }, prepend: function () { return Re(this, arguments, function (e) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var t = Le(this, e); t.insertBefore(e, t.firstChild) } }) }, before: function () { return Re(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this) }) }, after: function () { return Re(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this.nextSibling) }) }, empty: function () { for (var e, t = 0; null != (e = this[t]); t++)1 === e.nodeType && (w.cleanData(ye(e, !1)), e.textContent = ""); return this }, clone: function (e, t) { return e = null != e && e, t = null == t ? e : t, this.map(function () { return w.clone(this, e, t) }) }, html: function (e) { return z(this, function (e) { var t = this[0] || {}, n = 0, r = this.length; if (void 0 === e && 1 === t.nodeType) return t.innerHTML; if ("string" == typeof e && !Ae.test(e) && !ge[(de.exec(e) || ["", ""])[1].toLowerCase()]) { e = w.htmlPrefilter(e); try { for (; n < r; n++)1 === (t = this[n] || {}).nodeType && (w.cleanData(ye(t, !1)), t.innerHTML = e); t = 0 } catch (e) { } } t && this.empty().append(e) }, null, e, arguments.length) }, replaceWith: function () { var e = []; return Re(this, arguments, function (t) { var n = this.parentNode; w.inArray(this, e) < 0 && (w.cleanData(ye(this)), n && n.replaceChild(t, this)) }, e) } }), w.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function (e, t) { w.fn[e] = function (e) { for (var n, r = [], i = w(e), o = i.length - 1, a = 0; a <= o; a++)n = a === o ? this : this.clone(!0), w(i[a])[t](n), s.apply(r, n.get()); return this.pushStack(r) } }); var We = new RegExp("^(" + re + ")(?!px)[a-z%]+$", "i"), $e = function (t) { var n = t.ownerDocument.defaultView; return n && n.opener || (n = e), n.getComputedStyle(t) }, Be = new RegExp(oe.join("|"), "i"); !function () { function t() { if (c) { l.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", c.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", be.appendChild(l).appendChild(c); var t = e.getComputedStyle(c); i = "1%" !== t.top, u = 12 === n(t.marginLeft), c.style.right = "60%", s = 36 === n(t.right), o = 36 === n(t.width), c.style.position = "absolute", a = 36 === c.offsetWidth || "absolute", be.removeChild(l), c = null } } function n(e) { return Math.round(parseFloat(e)) } var i, o, a, s, u, l = r.createElement("div"), c = r.createElement("div"); c.style && (c.style.backgroundClip = "content-box", c.cloneNode(!0).style.backgroundClip = "", h.clearCloneStyle = "content-box" === c.style.backgroundClip, w.extend(h, { boxSizingReliable: function () { return t(), o }, pixelBoxStyles: function () { return t(), s }, pixelPosition: function () { return t(), i }, reliableMarginLeft: function () { return t(), u }, scrollboxSize: function () { return t(), a } })) }(); function Fe(e, t, n) { var r, i, o, a, s = e.style; return (n = n || $e(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || w.contains(e.ownerDocument, e) || (a = w.style(e, t)), !h.pixelBoxStyles() && We.test(a) && Be.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a } function _e(e, t) { return { get: function () { if (!e()) return (this.get = t).apply(this, arguments); delete this.get } } } var ze = /^(none|table(?!-c[ea]).+)/, Xe = /^--/, Ue = { position: "absolute", visibility: "hidden", display: "block" }, Ve = { letterSpacing: "0", fontWeight: "400" }, Ge = ["Webkit", "Moz", "ms"], Ye = r.createElement("div").style; function Qe(e) { if (e in Ye) return e; var t = e[0].toUpperCase() + e.slice(1), n = Ge.length; while (n--) if ((e = Ge[n] + t) in Ye) return e } function Je(e) { var t = w.cssProps[e]; return t || (t = w.cssProps[e] = Qe(e) || e), t } function Ke(e, t, n) { var r = ie.exec(t); return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t } function Ze(e, t, n, r, i, o) { var a = "width" === t ? 1 : 0, s = 0, u = 0; if (n === (r ? "border" : "content")) return 0; for (; a < 4; a += 2)"margin" === n && (u += w.css(e, n + oe[a], !0, i)), r ? ("content" === n && (u -= w.css(e, "padding" + oe[a], !0, i)), "margin" !== n && (u -= w.css(e, "border" + oe[a] + "Width", !0, i))) : (u += w.css(e, "padding" + oe[a], !0, i), "padding" !== n ? u += w.css(e, "border" + oe[a] + "Width", !0, i) : s += w.css(e, "border" + oe[a] + "Width", !0, i)); return !r && o >= 0 && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5))), u } function et(e, t, n) { var r = $e(e), i = Fe(e, t, r), o = "border-box" === w.css(e, "boxSizing", !1, r), a = o; if (We.test(i)) { if (!n) return i; i = "auto" } return a = a && (h.boxSizingReliable() || i === e.style[t]), ("auto" === i || !parseFloat(i) && "inline" === w.css(e, "display", !1, r)) && (i = e["offset" + t[0].toUpperCase() + t.slice(1)], a = !0), (i = parseFloat(i) || 0) + Ze(e, t, n || (o ? "border" : "content"), a, r, i) + "px" } w.extend({ cssHooks: { opacity: { get: function (e, t) { if (t) { var n = Fe(e, "opacity"); return "" === n ? "1" : n } } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: {}, style: function (e, t, n, r) { if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) { var i, o, a, s = G(t), u = Xe.test(t), l = e.style; if (u || (t = Je(s)), a = w.cssHooks[t] || w.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t]; "string" == (o = typeof n) && (i = ie.exec(n)) && i[1] && (n = ue(e, t, i), o = "number"), null != n && n === n && ("number" === o && (n += i && i[3] || (w.cssNumber[s] ? "" : "px")), h.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n)) } }, css: function (e, t, n, r) { var i, o, a, s = G(t); return Xe.test(t) || (t = Je(s)), (a = w.cssHooks[t] || w.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = Fe(e, t, r)), "normal" === i && t in Ve && (i = Ve[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i } }), w.each(["height", "width"], function (e, t) { w.cssHooks[t] = { get: function (e, n, r) { if (n) return !ze.test(w.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? et(e, t, r) : se(e, Ue, function () { return et(e, t, r) }) }, set: function (e, n, r) { var i, o = $e(e), a = "border-box" === w.css(e, "boxSizing", !1, o), s = r && Ze(e, t, r, a, o); return a && h.scrollboxSize() === o.position && (s -= Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - parseFloat(o[t]) - Ze(e, t, "border", !1, o) - .5)), s && (i = ie.exec(n)) && "px" !== (i[3] || "px") && (e.style[t] = n, n = w.css(e, t)), Ke(e, n, s) } } }), w.cssHooks.marginLeft = _e(h.reliableMarginLeft, function (e, t) { if (t) return (parseFloat(Fe(e, "marginLeft")) || e.getBoundingClientRect().left - se(e, { marginLeft: 0 }, function () { return e.getBoundingClientRect().left })) + "px" }), w.each({ margin: "", padding: "", border: "Width" }, function (e, t) { w.cssHooks[e + t] = { expand: function (n) { for (var r = 0, i = {}, o = "string" == typeof n ? n.split(" ") : [n]; r < 4; r++)i[e + oe[r] + t] = o[r] || o[r - 2] || o[0]; return i } }, "margin" !== e && (w.cssHooks[e + t].set = Ke) }), w.fn.extend({ css: function (e, t) { return z(this, function (e, t, n) { var r, i, o = {}, a = 0; if (Array.isArray(t)) { for (r = $e(e), i = t.length; a < i; a++)o[t[a]] = w.css(e, t[a], !1, r); return o } return void 0 !== n ? w.style(e, t, n) : w.css(e, t) }, e, t, arguments.length > 1) } }); function tt(e, t, n, r, i) { return new tt.prototype.init(e, t, n, r, i) } w.Tween = tt, tt.prototype = { constructor: tt, init: function (e, t, n, r, i, o) { this.elem = e, this.prop = n, this.easing = i || w.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (w.cssNumber[n] ? "" : "px") }, cur: function () { var e = tt.propHooks[this.prop]; return e && e.get ? e.get(this) : tt.propHooks._default.get(this) }, run: function (e) { var t, n = tt.propHooks[this.prop]; return this.options.duration ? this.pos = t = w.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : tt.propHooks._default.set(this), this } }, tt.prototype.init.prototype = tt.prototype, tt.propHooks = { _default: { get: function (e) { var t; return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = w.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0 }, set: function (e) { w.fx.step[e.prop] ? w.fx.step[e.prop](e) : 1 !== e.elem.nodeType || null == e.elem.style[w.cssProps[e.prop]] && !w.cssHooks[e.prop] ? e.elem[e.prop] = e.now : w.style(e.elem, e.prop, e.now + e.unit) } } }, tt.propHooks.scrollTop = tt.propHooks.scrollLeft = { set: function (e) { e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now) } }, w.easing = { linear: function (e) { return e }, swing: function (e) { return .5 - Math.cos(e * Math.PI) / 2 }, _default: "swing" }, w.fx = tt.prototype.init, w.fx.step = {}; var nt, rt, it = /^(?:toggle|show|hide)$/, ot = /queueHooks$/; function at() { rt && (!1 === r.hidden && e.requestAnimationFrame ? e.requestAnimationFrame(at) : e.setTimeout(at, w.fx.interval), w.fx.tick()) } function st() { return e.setTimeout(function () { nt = void 0 }), nt = Date.now() } function ut(e, t) { var n, r = 0, i = { height: e }; for (t = t ? 1 : 0; r < 4; r += 2 - t)i["margin" + (n = oe[r])] = i["padding" + n] = e; return t && (i.opacity = i.width = e), i } function lt(e, t, n) { for (var r, i = (pt.tweeners[t] || []).concat(pt.tweeners["*"]), o = 0, a = i.length; o < a; o++)if (r = i[o].call(n, t, e)) return r } function ct(e, t, n) { var r, i, o, a, s, u, l, c, f = "width" in t || "height" in t, p = this, d = {}, h = e.style, g = e.nodeType && ae(e), y = J.get(e, "fxshow"); n.queue || (null == (a = w._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () { a.unqueued || s() }), a.unqueued++, p.always(function () { p.always(function () { a.unqueued--, w.queue(e, "fx").length || a.empty.fire() }) })); for (r in t) if (i = t[r], it.test(i)) { if (delete t[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) { if ("show" !== i || !y || void 0 === y[r]) continue; g = !0 } d[r] = y && y[r] || w.style(e, r) } if ((u = !w.isEmptyObject(t)) || !w.isEmptyObject(d)) { f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = y && y.display) && (l = J.get(e, "display")), "none" === (c = w.css(e, "display")) && (l ? c = l : (fe([e], !0), l = e.style.display || l, c = w.css(e, "display"), fe([e]))), ("inline" === c || "inline-block" === c && null != l) && "none" === w.css(e, "float") && (u || (p.done(function () { h.display = l }), null == l && (c = h.display, l = "none" === c ? "" : c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always(function () { h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2] })), u = !1; for (r in d) u || (y ? "hidden" in y && (g = y.hidden) : y = J.access(e, "fxshow", { display: l }), o && (y.hidden = !g), g && fe([e], !0), p.done(function () { g || fe([e]), J.remove(e, "fxshow"); for (r in d) w.style(e, r, d[r]) })), u = lt(g ? y[r] : 0, r, p), r in y || (y[r] = u.start, g && (u.end = u.start, u.start = 0)) } } function ft(e, t) { var n, r, i, o, a; for (n in e) if (r = G(n), i = t[r], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = w.cssHooks[r]) && "expand" in a) { o = a.expand(o), delete e[r]; for (n in o) n in e || (e[n] = o[n], t[n] = i) } else t[r] = i } function pt(e, t, n) { var r, i, o = 0, a = pt.prefilters.length, s = w.Deferred().always(function () { delete u.elem }), u = function () { if (i) return !1; for (var t = nt || st(), n = Math.max(0, l.startTime + l.duration - t), r = 1 - (n / l.duration || 0), o = 0, a = l.tweens.length; o < a; o++)l.tweens[o].run(r); return s.notifyWith(e, [l, r, n]), r < 1 && a ? n : (a || s.notifyWith(e, [l, 1, 0]), s.resolveWith(e, [l]), !1) }, l = s.promise({ elem: e, props: w.extend({}, t), opts: w.extend(!0, { specialEasing: {}, easing: w.easing._default }, n), originalProperties: t, originalOptions: n, startTime: nt || st(), duration: n.duration, tweens: [], createTween: function (t, n) { var r = w.Tween(e, l.opts, t, n, l.opts.specialEasing[t] || l.opts.easing); return l.tweens.push(r), r }, stop: function (t) { var n = 0, r = t ? l.tweens.length : 0; if (i) return this; for (i = !0; n < r; n++)l.tweens[n].run(1); return t ? (s.notifyWith(e, [l, 1, 0]), s.resolveWith(e, [l, t])) : s.rejectWith(e, [l, t]), this } }), c = l.props; for (ft(c, l.opts.specialEasing); o < a; o++)if (r = pt.prefilters[o].call(l, e, c, l.opts)) return g(r.stop) && (w._queueHooks(l.elem, l.opts.queue).stop = r.stop.bind(r)), r; return w.map(c, lt, l), g(l.opts.start) && l.opts.start.call(e, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), w.fx.timer(w.extend(u, { elem: e, anim: l, queue: l.opts.queue })), l } w.Animation = w.extend(pt, { tweeners: { "*": [function (e, t) { var n = this.createTween(e, t); return ue(n.elem, e, ie.exec(t), n), n }] }, tweener: function (e, t) { g(e) ? (t = e, e = ["*"]) : e = e.match(M); for (var n, r = 0, i = e.length; r < i; r++)n = e[r], pt.tweeners[n] = pt.tweeners[n] || [], pt.tweeners[n].unshift(t) }, prefilters: [ct], prefilter: function (e, t) { t ? pt.prefilters.unshift(e) : pt.prefilters.push(e) } }), w.speed = function (e, t, n) { var r = e && "object" == typeof e ? w.extend({}, e) : { complete: n || !n && t || g(e) && e, duration: e, easing: n && t || t && !g(t) && t }; return w.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in w.fx.speeds ? r.duration = w.fx.speeds[r.duration] : r.duration = w.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function () { g(r.old) && r.old.call(this), r.queue && w.dequeue(this, r.queue) }, r }, w.fn.extend({ fadeTo: function (e, t, n, r) { return this.filter(ae).css("opacity", 0).show().end().animate({ opacity: t }, e, n, r) }, animate: function (e, t, n, r) { var i = w.isEmptyObject(e), o = w.speed(t, n, r), a = function () { var t = pt(this, w.extend({}, e), o); (i || J.get(this, "finish")) && t.stop(!0) }; return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a) }, stop: function (e, t, n) { var r = function (e) { var t = e.stop; delete e.stop, t(n) }; return "string" != typeof e && (n = t, t = e, e = void 0), t && !1 !== e && this.queue(e || "fx", []), this.each(function () { var t = !0, i = null != e && e + "queueHooks", o = w.timers, a = J.get(this); if (i) a[i] && a[i].stop && r(a[i]); else for (i in a) a[i] && a[i].stop && ot.test(i) && r(a[i]); for (i = o.length; i--;)o[i].elem !== this || null != e && o[i].queue !== e || (o[i].anim.stop(n), t = !1, o.splice(i, 1)); !t && n || w.dequeue(this, e) }) }, finish: function (e) { return !1 !== e && (e = e || "fx"), this.each(function () { var t, n = J.get(this), r = n[e + "queue"], i = n[e + "queueHooks"], o = w.timers, a = r ? r.length : 0; for (n.finish = !0, w.queue(this, e, []), i && i.stop && i.stop.call(this, !0), t = o.length; t--;)o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1)); for (t = 0; t < a; t++)r[t] && r[t].finish && r[t].finish.call(this); delete n.finish }) } }), w.each(["toggle", "show", "hide"], function (e, t) { var n = w.fn[t]; w.fn[t] = function (e, r, i) { return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(ut(t, !0), e, r, i) } }), w.each({ slideDown: ut("show"), slideUp: ut("hide"), slideToggle: ut("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function (e, t) { w.fn[e] = function (e, n, r) { return this.animate(t, e, n, r) } }), w.timers = [], w.fx.tick = function () { var e, t = 0, n = w.timers; for (nt = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1); n.length || w.fx.stop(), nt = void 0 }, w.fx.timer = function (e) { w.timers.push(e), w.fx.start() }, w.fx.interval = 13, w.fx.start = function () { rt || (rt = !0, at()) }, w.fx.stop = function () { rt = null }, w.fx.speeds = { slow: 600, fast: 200, _default: 400 }, w.fn.delay = function (t, n) { return t = w.fx ? w.fx.speeds[t] || t : t, n = n || "fx", this.queue(n, function (n, r) { var i = e.setTimeout(n, t); r.stop = function () { e.clearTimeout(i) } }) }, function () { var e = r.createElement("input"), t = r.createElement("select").appendChild(r.createElement("option")); e.type = "checkbox", h.checkOn = "" !== e.value, h.optSelected = t.selected, (e = r.createElement("input")).value = "t", e.type = "radio", h.radioValue = "t" === e.value }(); var dt, ht = w.expr.attrHandle; w.fn.extend({ attr: function (e, t) { return z(this, w.attr, e, t, arguments.length > 1) }, removeAttr: function (e) { return this.each(function () { w.removeAttr(this, e) }) } }), w.extend({ attr: function (e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? w.prop(e, t, n) : (1 === o && w.isXMLDoc(e) || (i = w.attrHooks[t.toLowerCase()] || (w.expr.match.bool.test(t) ? dt : void 0)), void 0 !== n ? null === n ? void w.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = w.find.attr(e, t)) ? void 0 : r) }, attrHooks: { type: { set: function (e, t) { if (!h.radioValue && "radio" === t && N(e, "input")) { var n = e.value; return e.setAttribute("type", t), n && (e.value = n), t } } } }, removeAttr: function (e, t) { var n, r = 0, i = t && t.match(M); if (i && 1 === e.nodeType) while (n = i[r++]) e.removeAttribute(n) } }), dt = { set: function (e, t, n) { return !1 === t ? w.removeAttr(e, n) : e.setAttribute(n, n), n } }, w.each(w.expr.match.bool.source.match(/\w+/g), function (e, t) { var n = ht[t] || w.find.attr; ht[t] = function (e, t, r) { var i, o, a = t.toLowerCase(); return r || (o = ht[a], ht[a] = i, i = null != n(e, t, r) ? a : null, ht[a] = o), i } }); var gt = /^(?:input|select|textarea|button)$/i, yt = /^(?:a|area)$/i; w.fn.extend({ prop: function (e, t) { return z(this, w.prop, e, t, arguments.length > 1) }, removeProp: function (e) { return this.each(function () { delete this[w.propFix[e] || e] }) } }), w.extend({ prop: function (e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return 1 === o && w.isXMLDoc(e) || (t = w.propFix[t] || t, i = w.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t] }, propHooks: { tabIndex: { get: function (e) { var t = w.find.attr(e, "tabindex"); return t ? parseInt(t, 10) : gt.test(e.nodeName) || yt.test(e.nodeName) && e.href ? 0 : -1 } } }, propFix: { "for": "htmlFor", "class": "className" } }), h.optSelected || (w.propHooks.selected = { get: function (e) { var t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null }, set: function (e) { var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex) } }), w.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () { w.propFix[this.toLowerCase()] = this }); function vt(e) { return (e.match(M) || []).join(" ") } function mt(e) { return e.getAttribute && e.getAttribute("class") || "" } function xt(e) { return Array.isArray(e) ? e : "string" == typeof e ? e.match(M) || [] : [] } w.fn.extend({ addClass: function (e) { var t, n, r, i, o, a, s, u = 0; if (g(e)) return this.each(function (t) { w(this).addClass(e.call(this, t, mt(this))) }); if ((t = xt(e)).length) while (n = this[u++]) if (i = mt(n), r = 1 === n.nodeType && " " + vt(i) + " ") { a = 0; while (o = t[a++]) r.indexOf(" " + o + " ") < 0 && (r += o + " "); i !== (s = vt(r)) && n.setAttribute("class", s) } return this }, removeClass: function (e) { var t, n, r, i, o, a, s, u = 0; if (g(e)) return this.each(function (t) { w(this).removeClass(e.call(this, t, mt(this))) }); if (!arguments.length) return this.attr("class", ""); if ((t = xt(e)).length) while (n = this[u++]) if (i = mt(n), r = 1 === n.nodeType && " " + vt(i) + " ") { a = 0; while (o = t[a++]) while (r.indexOf(" " + o + " ") > -1) r = r.replace(" " + o + " ", " "); i !== (s = vt(r)) && n.setAttribute("class", s) } return this }, toggleClass: function (e, t) { var n = typeof e, r = "string" === n || Array.isArray(e); return "boolean" == typeof t && r ? t ? this.addClass(e) : this.removeClass(e) : g(e) ? this.each(function (n) { w(this).toggleClass(e.call(this, n, mt(this), t), t) }) : this.each(function () { var t, i, o, a; if (r) { i = 0, o = w(this), a = xt(e); while (t = a[i++]) o.hasClass(t) ? o.removeClass(t) : o.addClass(t) } else void 0 !== e && "boolean" !== n || ((t = mt(this)) && J.set(this, "__className__", t), this.setAttribute && this.setAttribute("class", t || !1 === e ? "" : J.get(this, "__className__") || "")) }) }, hasClass: function (e) { var t, n, r = 0; t = " " + e + " "; while (n = this[r++]) if (1 === n.nodeType && (" " + vt(mt(n)) + " ").indexOf(t) > -1) return !0; return !1 } }); var bt = /\r/g; w.fn.extend({ val: function (e) { var t, n, r, i = this[0]; { if (arguments.length) return r = g(e), this.each(function (n) { var i; 1 === this.nodeType && (null == (i = r ? e.call(this, n, w(this).val()) : e) ? i = "" : "number" == typeof i ? i += "" : Array.isArray(i) && (i = w.map(i, function (e) { return null == e ? "" : e + "" })), (t = w.valHooks[this.type] || w.valHooks[this.nodeName.toLowerCase()]) && "set" in t && void 0 !== t.set(this, i, "value") || (this.value = i)) }); if (i) return (t = w.valHooks[i.type] || w.valHooks[i.nodeName.toLowerCase()]) && "get" in t && void 0 !== (n = t.get(i, "value")) ? n : "string" == typeof (n = i.value) ? n.replace(bt, "") : null == n ? "" : n } } }), w.extend({ valHooks: { option: { get: function (e) { var t = w.find.attr(e, "value"); return null != t ? t : vt(w.text(e)) } }, select: { get: function (e) { var t, n, r, i = e.options, o = e.selectedIndex, a = "select-one" === e.type, s = a ? null : [], u = a ? o + 1 : i.length; for (r = o < 0 ? u : a ? o : 0; r < u; r++)if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !N(n.parentNode, "optgroup"))) { if (t = w(n).val(), a) return t; s.push(t) } return s }, set: function (e, t) { var n, r, i = e.options, o = w.makeArray(t), a = i.length; while (a--) ((r = i[a]).selected = w.inArray(w.valHooks.option.get(r), o) > -1) && (n = !0); return n || (e.selectedIndex = -1), o } } } }), w.each(["radio", "checkbox"], function () { w.valHooks[this] = { set: function (e, t) { if (Array.isArray(t)) return e.checked = w.inArray(w(e).val(), t) > -1 } }, h.checkOn || (w.valHooks[this].get = function (e) { return null === e.getAttribute("value") ? "on" : e.value }) }), h.focusin = "onfocusin" in e; var wt = /^(?:focusinfocus|focusoutblur)$/, Tt = function (e) { e.stopPropagation() }; w.extend(w.event, { trigger: function (t, n, i, o) { var a, s, u, l, c, p, d, h, v = [i || r], m = f.call(t, "type") ? t.type : t, x = f.call(t, "namespace") ? t.namespace.split(".") : []; if (s = h = u = i = i || r, 3 !== i.nodeType && 8 !== i.nodeType && !wt.test(m + w.event.triggered) && (m.indexOf(".") > -1 && (m = (x = m.split(".")).shift(), x.sort()), c = m.indexOf(":") < 0 && "on" + m, t = t[w.expando] ? t : new w.Event(m, "object" == typeof t && t), t.isTrigger = o ? 2 : 3, t.namespace = x.join("."), t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + x.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = i), n = null == n ? [t] : w.makeArray(n, [t]), d = w.event.special[m] || {}, o || !d.trigger || !1 !== d.trigger.apply(i, n))) { if (!o && !d.noBubble && !y(i)) { for (l = d.delegateType || m, wt.test(l + m) || (s = s.parentNode); s; s = s.parentNode)v.push(s), u = s; u === (i.ownerDocument || r) && v.push(u.defaultView || u.parentWindow || e) } a = 0; while ((s = v[a++]) && !t.isPropagationStopped()) h = s, t.type = a > 1 ? l : d.bindType || m, (p = (J.get(s, "events") || {})[t.type] && J.get(s, "handle")) && p.apply(s, n), (p = c && s[c]) && p.apply && Y(s) && (t.result = p.apply(s, n), !1 === t.result && t.preventDefault()); return t.type = m, o || t.isDefaultPrevented() || d._default && !1 !== d._default.apply(v.pop(), n) || !Y(i) || c && g(i[m]) && !y(i) && ((u = i[c]) && (i[c] = null), w.event.triggered = m, t.isPropagationStopped() && h.addEventListener(m, Tt), i[m](), t.isPropagationStopped() && h.removeEventListener(m, Tt), w.event.triggered = void 0, u && (i[c] = u)), t.result } }, simulate: function (e, t, n) { var r = w.extend(new w.Event, n, { type: e, isSimulated: !0 }); w.event.trigger(r, null, t) } }), w.fn.extend({ trigger: function (e, t) { return this.each(function () { w.event.trigger(e, t, this) }) }, triggerHandler: function (e, t) { var n = this[0]; if (n) return w.event.trigger(e, t, n, !0) } }), h.focusin || w.each({ focus: "focusin", blur: "focusout" }, function (e, t) { var n = function (e) { w.event.simulate(t, e.target, w.event.fix(e)) }; w.event.special[t] = { setup: function () { var r = this.ownerDocument || this, i = J.access(r, t); i || r.addEventListener(e, n, !0), J.access(r, t, (i || 0) + 1) }, teardown: function () { var r = this.ownerDocument || this, i = J.access(r, t) - 1; i ? J.access(r, t, i) : (r.removeEventListener(e, n, !0), J.remove(r, t)) } } }); var Ct = e.location, Et = Date.now(), kt = /\?/; w.parseXML = function (t) { var n; if (!t || "string" != typeof t) return null; try { n = (new e.DOMParser).parseFromString(t, "text/xml") } catch (e) { n = void 0 } return n && !n.getElementsByTagName("parsererror").length || w.error("Invalid XML: " + t), n }; var St = /\[\]$/, Dt = /\r?\n/g, Nt = /^(?:submit|button|image|reset|file)$/i, At = /^(?:input|select|textarea|keygen)/i; function jt(e, t, n, r) { var i; if (Array.isArray(t)) w.each(t, function (t, i) { n || St.test(e) ? r(e, i) : jt(e + "[" + ("object" == typeof i && null != i ? t : "") + "]", i, n, r) }); else if (n || "object" !== x(t)) r(e, t); else for (i in t) jt(e + "[" + i + "]", t[i], n, r) } w.param = function (e, t) { var n, r = [], i = function (e, t) { var n = g(t) ? t() : t; r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n) }; if (Array.isArray(e) || e.jquery && !w.isPlainObject(e)) w.each(e, function () { i(this.name, this.value) }); else for (n in e) jt(n, e[n], t, i); return r.join("&") }, w.fn.extend({ serialize: function () { return w.param(this.serializeArray()) }, serializeArray: function () { return this.map(function () { var e = w.prop(this, "elements"); return e ? w.makeArray(e) : this }).filter(function () { var e = this.type; return this.name && !w(this).is(":disabled") && At.test(this.nodeName) && !Nt.test(e) && (this.checked || !pe.test(e)) }).map(function (e, t) { var n = w(this).val(); return null == n ? null : Array.isArray(n) ? w.map(n, function (e) { return { name: t.name, value: e.replace(Dt, "\r\n") } }) : { name: t.name, value: n.replace(Dt, "\r\n") } }).get() } }); var qt = /%20/g, Lt = /#.*$/, Ht = /([?&])_=[^&]*/, Ot = /^(.*?):[ \t]*([^\r\n]*)$/gm, Pt = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Mt = /^(?:GET|HEAD)$/, Rt = /^\/\//, It = {}, Wt = {}, $t = "*/".concat("*"), Bt = r.createElement("a"); Bt.href = Ct.href; function Ft(e) { return function (t, n) { "string" != typeof t && (n = t, t = "*"); var r, i = 0, o = t.toLowerCase().match(M) || []; if (g(n)) while (r = o[i++]) "+" === r[0] ? (r = r.slice(1) || "*", (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n) } } function _t(e, t, n, r) { var i = {}, o = e === Wt; function a(s) { var u; return i[s] = !0, w.each(e[s] || [], function (e, s) { var l = s(t, n, r); return "string" != typeof l || o || i[l] ? o ? !(u = l) : void 0 : (t.dataTypes.unshift(l), a(l), !1) }), u } return a(t.dataTypes[0]) || !i["*"] && a("*") } function zt(e, t) { var n, r, i = w.ajaxSettings.flatOptions || {}; for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]); return r && w.extend(!0, e, r), e } function Xt(e, t, n) { var r, i, o, a, s = e.contents, u = e.dataTypes; while ("*" === u[0]) u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type")); if (r) for (i in s) if (s[i] && s[i].test(r)) { u.unshift(i); break } if (u[0] in n) o = u[0]; else { for (i in n) { if (!u[0] || e.converters[i + " " + u[0]]) { o = i; break } a || (a = i) } o = o || a } if (o) return o !== u[0] && u.unshift(o), n[o] } function Ut(e, t, n, r) { var i, o, a, s, u, l = {}, c = e.dataTypes.slice(); if (c[1]) for (a in e.converters) l[a.toLowerCase()] = e.converters[a]; o = c.shift(); while (o) if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift()) if ("*" === o) o = u; else if ("*" !== u && u !== o) { if (!(a = l[u + " " + o] || l["* " + o])) for (i in l) if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) { !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1])); break } if (!0 !== a) if (a && e["throws"]) t = a(t); else try { t = a(t) } catch (e) { return { state: "parsererror", error: a ? e : "No conversion from " + u + " to " + o } } } return { state: "success", data: t } } w.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: Ct.href, type: "GET", isLocal: Pt.test(Ct.protocol), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": $t, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": JSON.parse, "text xml": w.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (e, t) { return t ? zt(zt(e, w.ajaxSettings), t) : zt(w.ajaxSettings, e) }, ajaxPrefilter: Ft(It), ajaxTransport: Ft(Wt), ajax: function (t, n) { "object" == typeof t && (n = t, t = void 0), n = n || {}; var i, o, a, s, u, l, c, f, p, d, h = w.ajaxSetup({}, n), g = h.context || h, y = h.context && (g.nodeType || g.jquery) ? w(g) : w.event, v = w.Deferred(), m = w.Callbacks("once memory"), x = h.statusCode || {}, b = {}, T = {}, C = "canceled", E = { readyState: 0, getResponseHeader: function (e) { var t; if (c) { if (!s) { s = {}; while (t = Ot.exec(a)) s[t[1].toLowerCase()] = t[2] } t = s[e.toLowerCase()] } return null == t ? null : t }, getAllResponseHeaders: function () { return c ? a : null }, setRequestHeader: function (e, t) { return null == c && (e = T[e.toLowerCase()] = T[e.toLowerCase()] || e, b[e] = t), this }, overrideMimeType: function (e) { return null == c && (h.mimeType = e), this }, statusCode: function (e) { var t; if (e) if (c) E.always(e[E.status]); else for (t in e) x[t] = [x[t], e[t]]; return this }, abort: function (e) { var t = e || C; return i && i.abort(t), k(0, t), this } }; if (v.promise(E), h.url = ((t || h.url || Ct.href) + "").replace(Rt, Ct.protocol + "//"), h.type = n.method || n.type || h.method || h.type, h.dataTypes = (h.dataType || "*").toLowerCase().match(M) || [""], null == h.crossDomain) { l = r.createElement("a"); try { l.href = h.url, l.href = l.href, h.crossDomain = Bt.protocol + "//" + Bt.host != l.protocol + "//" + l.host } catch (e) { h.crossDomain = !0 } } if (h.data && h.processData && "string" != typeof h.data && (h.data = w.param(h.data, h.traditional)), _t(It, h, n, E), c) return E; (f = w.event && h.global) && 0 == w.active++ && w.event.trigger("ajaxStart"), h.type = h.type.toUpperCase(), h.hasContent = !Mt.test(h.type), o = h.url.replace(Lt, ""), h.hasContent ? h.data && h.processData && 0 === (h.contentType || "").indexOf("application/x-www-form-urlencoded") && (h.data = h.data.replace(qt, "+")) : (d = h.url.slice(o.length), h.data && (h.processData || "string" == typeof h.data) && (o += (kt.test(o) ? "&" : "?") + h.data, delete h.data), !1 === h.cache && (o = o.replace(Ht, "$1"), d = (kt.test(o) ? "&" : "?") + "_=" + Et++ + d), h.url = o + d), h.ifModified && (w.lastModified[o] && E.setRequestHeader("If-Modified-Since", w.lastModified[o]), w.etag[o] && E.setRequestHeader("If-None-Match", w.etag[o])), (h.data && h.hasContent && !1 !== h.contentType || n.contentType) && E.setRequestHeader("Content-Type", h.contentType), E.setRequestHeader("Accept", h.dataTypes[0] && h.accepts[h.dataTypes[0]] ? h.accepts[h.dataTypes[0]] + ("*" !== h.dataTypes[0] ? ", " + $t + "; q=0.01" : "") : h.accepts["*"]); for (p in h.headers) E.setRequestHeader(p, h.headers[p]); if (h.beforeSend && (!1 === h.beforeSend.call(g, E, h) || c)) return E.abort(); if (C = "abort", m.add(h.complete), E.done(h.success), E.fail(h.error), i = _t(Wt, h, n, E)) { if (E.readyState = 1, f && y.trigger("ajaxSend", [E, h]), c) return E; h.async && h.timeout > 0 && (u = e.setTimeout(function () { E.abort("timeout") }, h.timeout)); try { c = !1, i.send(b, k) } catch (e) { if (c) throw e; k(-1, e) } } else k(-1, "No Transport"); function k(t, n, r, s) { var l, p, d, b, T, C = n; c || (c = !0, u && e.clearTimeout(u), i = void 0, a = s || "", E.readyState = t > 0 ? 4 : 0, l = t >= 200 && t < 300 || 304 === t, r && (b = Xt(h, E, r)), b = Ut(h, b, E, l), l ? (h.ifModified && ((T = E.getResponseHeader("Last-Modified")) && (w.lastModified[o] = T), (T = E.getResponseHeader("etag")) && (w.etag[o] = T)), 204 === t || "HEAD" === h.type ? C = "nocontent" : 304 === t ? C = "notmodified" : (C = b.state, p = b.data, l = !(d = b.error))) : (d = C, !t && C || (C = "error", t < 0 && (t = 0))), E.status = t, E.statusText = (n || C) + "", l ? v.resolveWith(g, [p, C, E]) : v.rejectWith(g, [E, C, d]), E.statusCode(x), x = void 0, f && y.trigger(l ? "ajaxSuccess" : "ajaxError", [E, h, l ? p : d]), m.fireWith(g, [E, C]), f && (y.trigger("ajaxComplete", [E, h]), --w.active || w.event.trigger("ajaxStop"))) } return E }, getJSON: function (e, t, n) { return w.get(e, t, n, "json") }, getScript: function (e, t) { return w.get(e, void 0, t, "script") } }), w.each(["get", "post"], function (e, t) { w[t] = function (e, n, r, i) { return g(n) && (i = i || r, r = n, n = void 0), w.ajax(w.extend({ url: e, type: t, dataType: i, data: n, success: r }, w.isPlainObject(e) && e)) } }), w._evalUrl = function (e) { return w.ajax({ url: e, type: "GET", dataType: "script", cache: !0, async: !1, global: !1, "throws": !0 }) }, w.fn.extend({ wrapAll: function (e) { var t; return this[0] && (g(e) && (e = e.call(this[0])), t = w(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () { var e = this; while (e.firstElementChild) e = e.firstElementChild; return e }).append(this)), this }, wrapInner: function (e) { return g(e) ? this.each(function (t) { w(this).wrapInner(e.call(this, t)) }) : this.each(function () { var t = w(this), n = t.contents(); n.length ? n.wrapAll(e) : t.append(e) }) }, wrap: function (e) { var t = g(e); return this.each(function (n) { w(this).wrapAll(t ? e.call(this, n) : e) }) }, unwrap: function (e) { return this.parent(e).not("body").each(function () { w(this).replaceWith(this.childNodes) }), this } }), w.expr.pseudos.hidden = function (e) { return !w.expr.pseudos.visible(e) }, w.expr.pseudos.visible = function (e) { return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length) }, w.ajaxSettings.xhr = function () { try { return new e.XMLHttpRequest } catch (e) { } }; var Vt = { 0: 200, 1223: 204 }, Gt = w.ajaxSettings.xhr(); h.cors = !!Gt && "withCredentials" in Gt, h.ajax = Gt = !!Gt, w.ajaxTransport(function (t) { var n, r; if (h.cors || Gt && !t.crossDomain) return { send: function (i, o) { var a, s = t.xhr(); if (s.open(t.type, t.url, t.async, t.username, t.password), t.xhrFields) for (a in t.xhrFields) s[a] = t.xhrFields[a]; t.mimeType && s.overrideMimeType && s.overrideMimeType(t.mimeType), t.crossDomain || i["X-Requested-With"] || (i["X-Requested-With"] = "XMLHttpRequest"); for (a in i) s.setRequestHeader(a, i[a]); n = function (e) { return function () { n && (n = r = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, "abort" === e ? s.abort() : "error" === e ? "number" != typeof s.status ? o(0, "error") : o(s.status, s.statusText) : o(Vt[s.status] || s.status, s.statusText, "text" !== (s.responseType || "text") || "string" != typeof s.responseText ? { binary: s.response } : { text: s.responseText }, s.getAllResponseHeaders())) } }, s.onload = n(), r = s.onerror = s.ontimeout = n("error"), void 0 !== s.onabort ? s.onabort = r : s.onreadystatechange = function () { 4 === s.readyState && e.setTimeout(function () { n && r() }) }, n = n("abort"); try { s.send(t.hasContent && t.data || null) } catch (e) { if (n) throw e } }, abort: function () { n && n() } } }), w.ajaxPrefilter(function (e) { e.crossDomain && (e.contents.script = !1) }), w.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function (e) { return w.globalEval(e), e } } }), w.ajaxPrefilter("script", function (e) { void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET") }), w.ajaxTransport("script", function (e) { if (e.crossDomain) { var t, n; return { send: function (i, o) { t = w("<script>").prop({ charset: e.scriptCharset, src: e.url }).on("load error", n = function (e) { t.remove(), n = null, e && o("error" === e.type ? 404 : 200, e.type) }), r.head.appendChild(t[0]) }, abort: function () { n && n() } } } }); var Yt = [], Qt = /(=)\?(?=&|$)|\?\?/; w.ajaxSetup({ jsonp: "callback", jsonpCallback: function () { var e = Yt.pop() || w.expando + "_" + Et++; return this[e] = !0, e } }), w.ajaxPrefilter("json jsonp", function (t, n, r) { var i, o, a, s = !1 !== t.jsonp && (Qt.test(t.url) ? "url" : "string" == typeof t.data && 0 === (t.contentType || "").indexOf("application/x-www-form-urlencoded") && Qt.test(t.data) && "data"); if (s || "jsonp" === t.dataTypes[0]) return i = t.jsonpCallback = g(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, s ? t[s] = t[s].replace(Qt, "$1" + i) : !1 !== t.jsonp && (t.url += (kt.test(t.url) ? "&" : "?") + t.jsonp + "=" + i), t.converters["script json"] = function () { return a || w.error(i + " was not called"), a[0] }, t.dataTypes[0] = "json", o = e[i], e[i] = function () { a = arguments }, r.always(function () { void 0 === o ? w(e).removeProp(i) : e[i] = o, t[i] && (t.jsonpCallback = n.jsonpCallback, Yt.push(i)), a && g(o) && o(a[0]), a = o = void 0 }), "script" }), h.createHTMLDocument = function () { var e = r.implementation.createHTMLDocument("").body; return e.innerHTML = "<form></form><form></form>", 2 === e.childNodes.length }(), w.parseHTML = function (e, t, n) { if ("string" != typeof e) return []; "boolean" == typeof t && (n = t, t = !1); var i, o, a; return t || (h.createHTMLDocument ? ((i = (t = r.implementation.createHTMLDocument("")).createElement("base")).href = r.location.href, t.head.appendChild(i)) : t = r), o = A.exec(e), a = !n && [], o ? [t.createElement(o[1])] : (o = xe([e], t, a), a && a.length && w(a).remove(), w.merge([], o.childNodes)) }, w.fn.load = function (e, t, n) { var r, i, o, a = this, s = e.indexOf(" "); return s > -1 && (r = vt(e.slice(s)), e = e.slice(0, s)), g(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), a.length > 0 && w.ajax({ url: e, type: i || "GET", dataType: "html", data: t }).done(function (e) { o = arguments, a.html(r ? w("<div>").append(w.parseHTML(e)).find(r) : e) }).always(n && function (e, t) { a.each(function () { n.apply(this, o || [e.responseText, t, e]) }) }), this }, w.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) { w.fn[t] = function (e) { return this.on(t, e) } }), w.expr.pseudos.animated = function (e) { return w.grep(w.timers, function (t) { return e === t.elem }).length }, w.offset = { setOffset: function (e, t, n) { var r, i, o, a, s, u, l, c = w.css(e, "position"), f = w(e), p = {}; "static" === c && (e.style.position = "relative"), s = f.offset(), o = w.css(e, "top"), u = w.css(e, "left"), (l = ("absolute" === c || "fixed" === c) && (o + u).indexOf("auto") > -1) ? (a = (r = f.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), g(t) && (t = t.call(e, n, w.extend({}, s))), null != t.top && (p.top = t.top - s.top + a), null != t.left && (p.left = t.left - s.left + i), "using" in t ? t.using.call(e, p) : f.css(p) } }, w.fn.extend({ offset: function (e) { if (arguments.length) return void 0 === e ? this : this.each(function (t) { w.offset.setOffset(this, e, t) }); var t, n, r = this[0]; if (r) return r.getClientRects().length ? (t = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, { top: t.top + n.pageYOffset, left: t.left + n.pageXOffset }) : { top: 0, left: 0 } }, position: function () { if (this[0]) { var e, t, n, r = this[0], i = { top: 0, left: 0 }; if ("fixed" === w.css(r, "position")) t = r.getBoundingClientRect(); else { t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement; while (e && (e === n.body || e === n.documentElement) && "static" === w.css(e, "position")) e = e.parentNode; e && e !== r && 1 === e.nodeType && ((i = w(e).offset()).top += w.css(e, "borderTopWidth", !0), i.left += w.css(e, "borderLeftWidth", !0)) } return { top: t.top - i.top - w.css(r, "marginTop", !0), left: t.left - i.left - w.css(r, "marginLeft", !0) } } }, offsetParent: function () { return this.map(function () { var e = this.offsetParent; while (e && "static" === w.css(e, "position")) e = e.offsetParent; return e || be }) } }), w.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (e, t) { var n = "pageYOffset" === t; w.fn[e] = function (r) { return z(this, function (e, r, i) { var o; if (y(e) ? o = e : 9 === e.nodeType && (o = e.defaultView), void 0 === i) return o ? o[t] : e[r]; o ? o.scrollTo(n ? o.pageXOffset : i, n ? i : o.pageYOffset) : e[r] = i }, e, r, arguments.length) } }), w.each(["top", "left"], function (e, t) { w.cssHooks[t] = _e(h.pixelPosition, function (e, n) { if (n) return n = Fe(e, t), We.test(n) ? w(e).position()[t] + "px" : n }) }), w.each({ Height: "height", Width: "width" }, function (e, t) { w.each({ padding: "inner" + e, content: t, "": "outer" + e }, function (n, r) { w.fn[r] = function (i, o) { var a = arguments.length && (n || "boolean" != typeof i), s = n || (!0 === i || !0 === o ? "margin" : "border"); return z(this, function (t, n, i) { var o; return y(t) ? 0 === r.indexOf("outer") ? t["inner" + e] : t.document.documentElement["client" + e] : 9 === t.nodeType ? (o = t.documentElement, Math.max(t.body["scroll" + e], o["scroll" + e], t.body["offset" + e], o["offset" + e], o["client" + e])) : void 0 === i ? w.css(t, n, s) : w.style(t, n, i, s) }, t, a ? i : void 0, a) } }) }), w.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (e, t) { w.fn[t] = function (e, n) { return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t) } }), w.fn.extend({ hover: function (e, t) { return this.mouseenter(e).mouseleave(t || e) } }), w.fn.extend({ bind: function (e, t, n) { return this.on(e, null, t, n) }, unbind: function (e, t) { return this.off(e, null, t) }, delegate: function (e, t, n, r) { return this.on(t, e, n, r) }, undelegate: function (e, t, n) { return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n) } }), w.proxy = function (e, t) { var n, r, i; if ("string" == typeof t && (n = e[t], t = e, e = n), g(e)) return r = o.call(arguments, 2), i = function () { return e.apply(t || this, r.concat(o.call(arguments))) }, i.guid = e.guid = e.guid || w.guid++, i }, w.holdReady = function (e) { e ? w.readyWait++ : w.ready(!0) }, w.isArray = Array.isArray, w.parseJSON = JSON.parse, w.nodeName = N, w.isFunction = g, w.isWindow = y, w.camelCase = G, w.type = x, w.now = Date.now, w.isNumeric = function (e) { var t = w.type(e); return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e)) }, "function" == typeof define && define.amd && define("jquery", [], function () { return w }); var Jt = e.jQuery, Kt = e.$; return w.noConflict = function (t) { return e.$ === w && (e.$ = Kt), t && e.jQuery === w && (e.jQuery = Jt), w }, t || (e.jQuery = e.$ = w), w });




/**
 * Swiper 7.4.1
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2021 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: December 24, 2021
 */

!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).Swiper = t() }(this, (function () { "use strict"; function e(e) { return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object } function t(s = {}, a = {}) { Object.keys(a).forEach((i => { void 0 === s[i] ? s[i] = a[i] : e(a[i]) && e(s[i]) && Object.keys(a[i]).length > 0 && t(s[i], a[i]) })) } const s = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector: () => null, querySelectorAll: () => [], getElementById: () => null, createEvent: () => ({ initEvent() { } }), createElement: () => ({ children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName: () => [] }), createElementNS: () => ({}), importNode: () => null, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function a() { const e = "undefined" != typeof document ? document : {}; return t(e, s), e } const i = { document: s, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle: () => ({ getPropertyValue: () => "" }), Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia: () => ({}), requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0), cancelAnimationFrame(e) { "undefined" != typeof setTimeout && clearTimeout(e) } }; function r() { const e = "undefined" != typeof window ? window : {}; return t(e, i), e } class n extends Array { constructor(e) { super(...e || []), function (e) { const t = e.__proto__; Object.defineProperty(e, "__proto__", { get: () => t, set(e) { t.__proto__ = e } }) }(this) } } function l(e = []) { const t = []; return e.forEach((e => { Array.isArray(e) ? t.push(...l(e)) : t.push(e) })), t } function o(e, t) { return Array.prototype.filter.call(e, t) } function d(e, t) { const s = r(), i = a(); let l = []; if (!t && e instanceof n) return e; if (!e) return new n(l); if ("string" == typeof e) { const s = e.trim(); if (s.indexOf("<") >= 0 && s.indexOf(">") >= 0) { let e = "div"; 0 === s.indexOf("<li") && (e = "ul"), 0 === s.indexOf("<tr") && (e = "tbody"), 0 !== s.indexOf("<td") && 0 !== s.indexOf("<th") || (e = "tr"), 0 === s.indexOf("<tbody") && (e = "table"), 0 === s.indexOf("<option") && (e = "select"); const t = i.createElement(e); t.innerHTML = s; for (let e = 0; e < t.childNodes.length; e += 1)l.push(t.childNodes[e]) } else l = function (e, t) { if ("string" != typeof e) return [e]; const s = [], a = t.querySelectorAll(e); for (let e = 0; e < a.length; e += 1)s.push(a[e]); return s }(e.trim(), t || i) } else if (e.nodeType || e === s || e === i) l.push(e); else if (Array.isArray(e)) { if (e instanceof n) return e; l = e } return new n(function (e) { const t = []; for (let s = 0; s < e.length; s += 1)-1 === t.indexOf(e[s]) && t.push(e[s]); return t }(l)) } d.fn = n.prototype; const p = { addClass: function (...e) { const t = l(e.map((e => e.split(" ")))); return this.forEach((e => { e.classList.add(...t) })), this }, removeClass: function (...e) { const t = l(e.map((e => e.split(" ")))); return this.forEach((e => { e.classList.remove(...t) })), this }, hasClass: function (...e) { const t = l(e.map((e => e.split(" ")))); return o(this, (e => t.filter((t => e.classList.contains(t))).length > 0)).length > 0 }, toggleClass: function (...e) { const t = l(e.map((e => e.split(" ")))); this.forEach((e => { t.forEach((t => { e.classList.toggle(t) })) })) }, attr: function (e, t) { if (1 === arguments.length && "string" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0; for (let s = 0; s < this.length; s += 1)if (2 === arguments.length) this[s].setAttribute(e, t); else for (const t in e) this[s][t] = e[t], this[s].setAttribute(t, e[t]); return this }, removeAttr: function (e) { for (let t = 0; t < this.length; t += 1)this[t].removeAttribute(e); return this }, transform: function (e) { for (let t = 0; t < this.length; t += 1)this[t].style.transform = e; return this }, transition: function (e) { for (let t = 0; t < this.length; t += 1)this[t].style.transitionDuration = "string" != typeof e ? `${e}ms` : e; return this }, on: function (...e) { let [t, s, a, i] = e; function r(e) { const t = e.target; if (!t) return; const i = e.target.dom7EventData || []; if (i.indexOf(e) < 0 && i.unshift(e), d(t).is(s)) a.apply(t, i); else { const e = d(t).parents(); for (let t = 0; t < e.length; t += 1)d(e[t]).is(s) && a.apply(e[t], i) } } function n(e) { const t = e && e.target && e.target.dom7EventData || []; t.indexOf(e) < 0 && t.unshift(e), a.apply(this, t) } "function" == typeof e[1] && ([t, a, i] = e, s = void 0), i || (i = !1); const l = t.split(" "); let o; for (let e = 0; e < this.length; e += 1) { const t = this[e]; if (s) for (o = 0; o < l.length; o += 1) { const e = l[o]; t.dom7LiveListeners || (t.dom7LiveListeners = {}), t.dom7LiveListeners[e] || (t.dom7LiveListeners[e] = []), t.dom7LiveListeners[e].push({ listener: a, proxyListener: r }), t.addEventListener(e, r, i) } else for (o = 0; o < l.length; o += 1) { const e = l[o]; t.dom7Listeners || (t.dom7Listeners = {}), t.dom7Listeners[e] || (t.dom7Listeners[e] = []), t.dom7Listeners[e].push({ listener: a, proxyListener: n }), t.addEventListener(e, n, i) } } return this }, off: function (...e) { let [t, s, a, i] = e; "function" == typeof e[1] && ([t, a, i] = e, s = void 0), i || (i = !1); const r = t.split(" "); for (let e = 0; e < r.length; e += 1) { const t = r[e]; for (let e = 0; e < this.length; e += 1) { const r = this[e]; let n; if (!s && r.dom7Listeners ? n = r.dom7Listeners[t] : s && r.dom7LiveListeners && (n = r.dom7LiveListeners[t]), n && n.length) for (let e = n.length - 1; e >= 0; e -= 1) { const s = n[e]; a && s.listener === a || a && s.listener && s.listener.dom7proxy && s.listener.dom7proxy === a ? (r.removeEventListener(t, s.proxyListener, i), n.splice(e, 1)) : a || (r.removeEventListener(t, s.proxyListener, i), n.splice(e, 1)) } } } return this }, trigger: function (...e) { const t = r(), s = e[0].split(" "), a = e[1]; for (let i = 0; i < s.length; i += 1) { const r = s[i]; for (let s = 0; s < this.length; s += 1) { const i = this[s]; if (t.CustomEvent) { const s = new t.CustomEvent(r, { detail: a, bubbles: !0, cancelable: !0 }); i.dom7EventData = e.filter(((e, t) => t > 0)), i.dispatchEvent(s), i.dom7EventData = [], delete i.dom7EventData } } } return this }, transitionEnd: function (e) { const t = this; return e && t.on("transitionend", (function s(a) { a.target === this && (e.call(this, a), t.off("transitionend", s)) })), this }, outerWidth: function (e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left")) } return this[0].offsetWidth } return null }, outerHeight: function (e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom")) } return this[0].offsetHeight } return null }, styles: function () { const e = r(); return this[0] ? e.getComputedStyle(this[0], null) : {} }, offset: function () { if (this.length > 0) { const e = r(), t = a(), s = this[0], i = s.getBoundingClientRect(), n = t.body, l = s.clientTop || n.clientTop || 0, o = s.clientLeft || n.clientLeft || 0, d = s === e ? e.scrollY : s.scrollTop, p = s === e ? e.scrollX : s.scrollLeft; return { top: i.top + d - l, left: i.left + p - o } } return null }, css: function (e, t) { const s = r(); let a; if (1 === arguments.length) { if ("string" != typeof e) { for (a = 0; a < this.length; a += 1)for (const t in e) this[a].style[t] = e[t]; return this } if (this[0]) return s.getComputedStyle(this[0], null).getPropertyValue(e) } if (2 === arguments.length && "string" == typeof e) { for (a = 0; a < this.length; a += 1)this[a].style[e] = t; return this } return this }, each: function (e) { return e ? (this.forEach(((t, s) => { e.apply(t, [t, s]) })), this) : this }, html: function (e) { if (void 0 === e) return this[0] ? this[0].innerHTML : null; for (let t = 0; t < this.length; t += 1)this[t].innerHTML = e; return this }, text: function (e) { if (void 0 === e) return this[0] ? this[0].textContent.trim() : null; for (let t = 0; t < this.length; t += 1)this[t].textContent = e; return this }, is: function (e) { const t = r(), s = a(), i = this[0]; let l, o; if (!i || void 0 === e) return !1; if ("string" == typeof e) { if (i.matches) return i.matches(e); if (i.webkitMatchesSelector) return i.webkitMatchesSelector(e); if (i.msMatchesSelector) return i.msMatchesSelector(e); for (l = d(e), o = 0; o < l.length; o += 1)if (l[o] === i) return !0; return !1 } if (e === s) return i === s; if (e === t) return i === t; if (e.nodeType || e instanceof n) { for (l = e.nodeType ? [e] : e, o = 0; o < l.length; o += 1)if (l[o] === i) return !0; return !1 } return !1 }, index: function () { let e, t = this[0]; if (t) { for (e = 0; null !== (t = t.previousSibling);)1 === t.nodeType && (e += 1); return e } }, eq: function (e) { if (void 0 === e) return this; const t = this.length; if (e > t - 1) return d([]); if (e < 0) { const s = t + e; return d(s < 0 ? [] : [this[s]]) } return d([this[e]]) }, append: function (...e) { let t; const s = a(); for (let a = 0; a < e.length; a += 1) { t = e[a]; for (let e = 0; e < this.length; e += 1)if ("string" == typeof t) { const a = s.createElement("div"); for (a.innerHTML = t; a.firstChild;)this[e].appendChild(a.firstChild) } else if (t instanceof n) for (let s = 0; s < t.length; s += 1)this[e].appendChild(t[s]); else this[e].appendChild(t) } return this }, prepend: function (e) { const t = a(); let s, i; for (s = 0; s < this.length; s += 1)if ("string" == typeof e) { const a = t.createElement("div"); for (a.innerHTML = e, i = a.childNodes.length - 1; i >= 0; i -= 1)this[s].insertBefore(a.childNodes[i], this[s].childNodes[0]) } else if (e instanceof n) for (i = 0; i < e.length; i += 1)this[s].insertBefore(e[i], this[s].childNodes[0]); else this[s].insertBefore(e, this[s].childNodes[0]); return this }, next: function (e) { return this.length > 0 ? e ? this[0].nextElementSibling && d(this[0].nextElementSibling).is(e) ? d([this[0].nextElementSibling]) : d([]) : this[0].nextElementSibling ? d([this[0].nextElementSibling]) : d([]) : d([]) }, nextAll: function (e) { const t = []; let s = this[0]; if (!s) return d([]); for (; s.nextElementSibling;) { const a = s.nextElementSibling; e ? d(a).is(e) && t.push(a) : t.push(a), s = a } return d(t) }, prev: function (e) { if (this.length > 0) { const t = this[0]; return e ? t.previousElementSibling && d(t.previousElementSibling).is(e) ? d([t.previousElementSibling]) : d([]) : t.previousElementSibling ? d([t.previousElementSibling]) : d([]) } return d([]) }, prevAll: function (e) { const t = []; let s = this[0]; if (!s) return d([]); for (; s.previousElementSibling;) { const a = s.previousElementSibling; e ? d(a).is(e) && t.push(a) : t.push(a), s = a } return d(t) }, parent: function (e) { const t = []; for (let s = 0; s < this.length; s += 1)null !== this[s].parentNode && (e ? d(this[s].parentNode).is(e) && t.push(this[s].parentNode) : t.push(this[s].parentNode)); return d(t) }, parents: function (e) { const t = []; for (let s = 0; s < this.length; s += 1) { let a = this[s].parentNode; for (; a;)e ? d(a).is(e) && t.push(a) : t.push(a), a = a.parentNode } return d(t) }, closest: function (e) { let t = this; return void 0 === e ? d([]) : (t.is(e) || (t = t.parents(e).eq(0)), t) }, find: function (e) { const t = []; for (let s = 0; s < this.length; s += 1) { const a = this[s].querySelectorAll(e); for (let e = 0; e < a.length; e += 1)t.push(a[e]) } return d(t) }, children: function (e) { const t = []; for (let s = 0; s < this.length; s += 1) { const a = this[s].children; for (let s = 0; s < a.length; s += 1)e && !d(a[s]).is(e) || t.push(a[s]) } return d(t) }, filter: function (e) { return d(o(this, e)) }, remove: function () { for (let e = 0; e < this.length; e += 1)this[e].parentNode && this[e].parentNode.removeChild(this[e]); return this } }; function c(e, t = 0) { return setTimeout(e, t) } function u() { return Date.now() } function h(e, t = "x") { const s = r(); let a, i, n; const l = function (e) { const t = r(); let s; return t.getComputedStyle && (s = t.getComputedStyle(e, null)), !s && e.currentStyle && (s = e.currentStyle), s || (s = e.style), s }(e); return s.WebKitCSSMatrix ? (i = l.transform || l.webkitTransform, i.split(",").length > 6 && (i = i.split(", ").map((e => e.replace(",", "."))).join(", ")), n = new s.WebKitCSSMatrix("none" === i ? "" : i)) : (n = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), a = n.toString().split(",")), "x" === t && (i = s.WebKitCSSMatrix ? n.m41 : 16 === a.length ? parseFloat(a[12]) : parseFloat(a[4])), "y" === t && (i = s.WebKitCSSMatrix ? n.m42 : 16 === a.length ? parseFloat(a[13]) : parseFloat(a[5])), i || 0 } function m(e) { return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1) } function f(...e) { const t = Object(e[0]), s = ["__proto__", "constructor", "prototype"]; for (let i = 1; i < e.length; i += 1) { const r = e[i]; if (null != r && (a = r, !("undefined" != typeof window && void 0 !== window.HTMLElement ? a instanceof HTMLElement : a && (1 === a.nodeType || 11 === a.nodeType)))) { const e = Object.keys(Object(r)).filter((e => s.indexOf(e) < 0)); for (let s = 0, a = e.length; s < a; s += 1) { const a = e[s], i = Object.getOwnPropertyDescriptor(r, a); void 0 !== i && i.enumerable && (m(t[a]) && m(r[a]) ? r[a].__swiper__ ? t[a] = r[a] : f(t[a], r[a]) : !m(t[a]) && m(r[a]) ? (t[a] = {}, r[a].__swiper__ ? t[a] = r[a] : f(t[a], r[a])) : t[a] = r[a]) } } } var a; return t } function g(e, t, s) { e.style.setProperty(t, s) } function v({ swiper: e, targetPosition: t, side: s }) { const a = r(), i = -e.translate; let n, l = null; const o = e.params.speed; e.wrapperEl.style.scrollSnapType = "none", a.cancelAnimationFrame(e.cssModeFrameID); const d = t > i ? "next" : "prev", p = (e, t) => "next" === d && e >= t || "prev" === d && e <= t, c = () => { n = (new Date).getTime(), null === l && (l = n); const r = Math.max(Math.min((n - l) / o, 1), 0), d = .5 - Math.cos(r * Math.PI) / 2; let u = i + d * (t - i); if (p(u, t) && (u = t), e.wrapperEl.scrollTo({ [s]: u }), p(u, t)) return e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout((() => { e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({ [s]: u }) })), void a.cancelAnimationFrame(e.cssModeFrameID); e.cssModeFrameID = a.requestAnimationFrame(c) }; c() } let w, b, x; function y() { return w || (w = function () { const e = r(), t = a(); return { smoothScroll: t.documentElement && "scrollBehavior" in t.documentElement.style, touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch), passiveListener: function () { let t = !1; try { const s = Object.defineProperty({}, "passive", { get() { t = !0 } }); e.addEventListener("testPassiveListener", null, s) } catch (e) { } return t }(), gestures: "ongesturestart" in e } }()), w } function E(e = {}) { return b || (b = function ({ userAgent: e } = {}) { const t = y(), s = r(), a = s.navigator.platform, i = e || s.navigator.userAgent, n = { ios: !1, android: !1 }, l = s.screen.width, o = s.screen.height, d = i.match(/(Android);?[\s\/]+([\d.]+)?/); let p = i.match(/(iPad).*OS\s([\d_]+)/); const c = i.match(/(iPod)(.*OS\s([\d_]+))?/), u = !p && i.match(/(iPhone\sOS|iOS)\s([\d_]+)/), h = "Win32" === a; let m = "MacIntel" === a; return !p && m && t.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${l}x${o}`) >= 0 && (p = i.match(/(Version)\/([\d.]+)/), p || (p = [0, 1, "13_0_0"]), m = !1), d && !h && (n.os = "android", n.android = !0), (p || u || c) && (n.os = "ios", n.ios = !0), n }(e)), b } function T() { return x || (x = function () { const e = r(); return { isSafari: function () { const t = e.navigator.userAgent.toLowerCase(); return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0 }(), isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent) } }()), x } Object.keys(p).forEach((e => { Object.defineProperty(d.fn, e, { value: p[e], writable: !0 }) })); var C = { on(e, t, s) { const a = this; if ("function" != typeof t) return a; const i = s ? "unshift" : "push"; return e.split(" ").forEach((e => { a.eventsListeners[e] || (a.eventsListeners[e] = []), a.eventsListeners[e][i](t) })), a }, once(e, t, s) { const a = this; if ("function" != typeof t) return a; function i(...s) { a.off(e, i), i.__emitterProxy && delete i.__emitterProxy, t.apply(a, s) } return i.__emitterProxy = t, a.on(e, i, s) }, onAny(e, t) { const s = this; if ("function" != typeof e) return s; const a = t ? "unshift" : "push"; return s.eventsAnyListeners.indexOf(e) < 0 && s.eventsAnyListeners[a](e), s }, offAny(e) { const t = this; if (!t.eventsAnyListeners) return t; const s = t.eventsAnyListeners.indexOf(e); return s >= 0 && t.eventsAnyListeners.splice(s, 1), t }, off(e, t) { const s = this; return s.eventsListeners ? (e.split(" ").forEach((e => { void 0 === t ? s.eventsListeners[e] = [] : s.eventsListeners[e] && s.eventsListeners[e].forEach(((a, i) => { (a === t || a.__emitterProxy && a.__emitterProxy === t) && s.eventsListeners[e].splice(i, 1) })) })), s) : s }, emit(...e) { const t = this; if (!t.eventsListeners) return t; let s, a, i; "string" == typeof e[0] || Array.isArray(e[0]) ? (s = e[0], a = e.slice(1, e.length), i = t) : (s = e[0].events, a = e[0].data, i = e[0].context || t), a.unshift(i); return (Array.isArray(s) ? s : s.split(" ")).forEach((e => { t.eventsAnyListeners && t.eventsAnyListeners.length && t.eventsAnyListeners.forEach((t => { t.apply(i, [e, ...a]) })), t.eventsListeners && t.eventsListeners[e] && t.eventsListeners[e].forEach((e => { e.apply(i, a) })) })), t } }; function $({ swiper: e, runCallbacks: t, direction: s, step: a }) { const { activeIndex: i, previousIndex: r } = e; let n = s; if (n || (n = i > r ? "next" : i < r ? "prev" : "reset"), e.emit(`transition${a}`), t && i !== r) { if ("reset" === n) return void e.emit(`slideResetTransition${a}`); e.emit(`slideChangeTransition${a}`), "next" === n ? e.emit(`slideNextTransition${a}`) : e.emit(`slidePrevTransition${a}`) } } function S(e) { const t = this, s = a(), i = r(), n = t.touchEventsData, { params: l, touches: o, enabled: p } = t; if (!p) return; if (t.animating && l.preventInteractionOnTransition) return; !t.animating && l.cssMode && l.loop && t.loopFix(); let c = e; c.originalEvent && (c = c.originalEvent); let h = d(c.target); if ("wrapper" === l.touchEventsTarget && !h.closest(t.wrapperEl).length) return; if (n.isTouchEvent = "touchstart" === c.type, !n.isTouchEvent && "which" in c && 3 === c.which) return; if (!n.isTouchEvent && "button" in c && c.button > 0) return; if (n.isTouched && n.isMoved) return; !!l.noSwipingClass && "" !== l.noSwipingClass && c.target && c.target.shadowRoot && e.path && e.path[0] && (h = d(e.path[0])); const m = l.noSwipingSelector ? l.noSwipingSelector : `.${l.noSwipingClass}`, f = !(!c.target || !c.target.shadowRoot); if (l.noSwiping && (f ? function (e, t = this) { return function t(s) { return s && s !== a() && s !== r() ? (s.assignedSlot && (s = s.assignedSlot), s.closest(e) || t(s.getRootNode().host)) : null }(t) }(m, c.target) : h.closest(m)[0])) return void (t.allowClick = !0); if (l.swipeHandler && !h.closest(l.swipeHandler)[0]) return; o.currentX = "touchstart" === c.type ? c.targetTouches[0].pageX : c.pageX, o.currentY = "touchstart" === c.type ? c.targetTouches[0].pageY : c.pageY; const g = o.currentX, v = o.currentY, w = l.edgeSwipeDetection || l.iOSEdgeSwipeDetection, b = l.edgeSwipeThreshold || l.iOSEdgeSwipeThreshold; if (w && (g <= b || g >= i.innerWidth - b)) { if ("prevent" !== w) return; e.preventDefault() } if (Object.assign(n, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), o.startX = g, o.startY = v, n.touchStartTime = u(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, l.threshold > 0 && (n.allowThresholdMove = !1), "touchstart" !== c.type) { let e = !0; h.is(n.focusableElements) && (e = !1), s.activeElement && d(s.activeElement).is(n.focusableElements) && s.activeElement !== h[0] && s.activeElement.blur(); const a = e && t.allowTouchMove && l.touchStartPreventDefault; !l.touchStartForcePreventDefault && !a || h[0].isContentEditable || c.preventDefault() } t.emit("touchStart", c) } function M(e) { const t = a(), s = this, i = s.touchEventsData, { params: r, touches: n, rtlTranslate: l, enabled: o } = s; if (!o) return; let p = e; if (p.originalEvent && (p = p.originalEvent), !i.isTouched) return void (i.startMoving && i.isScrolling && s.emit("touchMoveOpposite", p)); if (i.isTouchEvent && "touchmove" !== p.type) return; const c = "touchmove" === p.type && p.targetTouches && (p.targetTouches[0] || p.changedTouches[0]), h = "touchmove" === p.type ? c.pageX : p.pageX, m = "touchmove" === p.type ? c.pageY : p.pageY; if (p.preventedByNestedSwiper) return n.startX = h, void (n.startY = m); if (!s.allowTouchMove) return s.allowClick = !1, void (i.isTouched && (Object.assign(n, { startX: h, startY: m, currentX: h, currentY: m }), i.touchStartTime = u())); if (i.isTouchEvent && r.touchReleaseOnEdges && !r.loop) if (s.isVertical()) { if (m < n.startY && s.translate <= s.maxTranslate() || m > n.startY && s.translate >= s.minTranslate()) return i.isTouched = !1, void (i.isMoved = !1) } else if (h < n.startX && s.translate <= s.maxTranslate() || h > n.startX && s.translate >= s.minTranslate()) return; if (i.isTouchEvent && t.activeElement && p.target === t.activeElement && d(p.target).is(i.focusableElements)) return i.isMoved = !0, void (s.allowClick = !1); if (i.allowTouchCallbacks && s.emit("touchMove", p), p.targetTouches && p.targetTouches.length > 1) return; n.currentX = h, n.currentY = m; const f = n.currentX - n.startX, g = n.currentY - n.startY; if (s.params.threshold && Math.sqrt(f ** 2 + g ** 2) < s.params.threshold) return; if (void 0 === i.isScrolling) { let e; s.isHorizontal() && n.currentY === n.startY || s.isVertical() && n.currentX === n.startX ? i.isScrolling = !1 : f * f + g * g >= 25 && (e = 180 * Math.atan2(Math.abs(g), Math.abs(f)) / Math.PI, i.isScrolling = s.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle) } if (i.isScrolling && s.emit("touchMoveOpposite", p), void 0 === i.startMoving && (n.currentX === n.startX && n.currentY === n.startY || (i.startMoving = !0)), i.isScrolling) return void (i.isTouched = !1); if (!i.startMoving) return; s.allowClick = !1, !r.cssMode && p.cancelable && p.preventDefault(), r.touchMoveStopPropagation && !r.nested && p.stopPropagation(), i.isMoved || (r.loop && !r.cssMode && s.loopFix(), i.startTranslate = s.getTranslate(), s.setTransition(0), s.animating && s.$wrapperEl.trigger("webkitTransitionEnd transitionend"), i.allowMomentumBounce = !1, !r.grabCursor || !0 !== s.allowSlideNext && !0 !== s.allowSlidePrev || s.setGrabCursor(!0), s.emit("sliderFirstMove", p)), s.emit("sliderMove", p), i.isMoved = !0; let v = s.isHorizontal() ? f : g; n.diff = v, v *= r.touchRatio, l && (v = -v), s.swipeDirection = v > 0 ? "prev" : "next", i.currentTranslate = v + i.startTranslate; let w = !0, b = r.resistanceRatio; if (r.touchReleaseOnEdges && (b = 0), v > 0 && i.currentTranslate > s.minTranslate() ? (w = !1, r.resistance && (i.currentTranslate = s.minTranslate() - 1 + (-s.minTranslate() + i.startTranslate + v) ** b)) : v < 0 && i.currentTranslate < s.maxTranslate() && (w = !1, r.resistance && (i.currentTranslate = s.maxTranslate() + 1 - (s.maxTranslate() - i.startTranslate - v) ** b)), w && (p.preventedByNestedSwiper = !0), !s.allowSlideNext && "next" === s.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !s.allowSlidePrev && "prev" === s.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), s.allowSlidePrev || s.allowSlideNext || (i.currentTranslate = i.startTranslate), r.threshold > 0) { if (!(Math.abs(v) > r.threshold || i.allowThresholdMove)) return void (i.currentTranslate = i.startTranslate); if (!i.allowThresholdMove) return i.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, i.currentTranslate = i.startTranslate, void (n.diff = s.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY) } r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && s.freeMode || r.watchSlidesProgress) && (s.updateActiveIndex(), s.updateSlidesClasses()), s.params.freeMode && r.freeMode.enabled && s.freeMode && s.freeMode.onTouchMove(), s.updateProgress(i.currentTranslate), s.setTranslate(i.currentTranslate)) } function P(e) { const t = this, s = t.touchEventsData, { params: a, touches: i, rtlTranslate: r, slidesGrid: n, enabled: l } = t; if (!l) return; let o = e; if (o.originalEvent && (o = o.originalEvent), s.allowTouchCallbacks && t.emit("touchEnd", o), s.allowTouchCallbacks = !1, !s.isTouched) return s.isMoved && a.grabCursor && t.setGrabCursor(!1), s.isMoved = !1, void (s.startMoving = !1); a.grabCursor && s.isMoved && s.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); const d = u(), p = d - s.touchStartTime; if (t.allowClick) { const e = o.path || o.composedPath && o.composedPath(); t.updateClickedSlide(e && e[0] || o.target), t.emit("tap click", o), p < 300 && d - s.lastClickTime < 300 && t.emit("doubleTap doubleClick", o) } if (s.lastClickTime = u(), c((() => { t.destroyed || (t.allowClick = !0) })), !s.isTouched || !s.isMoved || !t.swipeDirection || 0 === i.diff || s.currentTranslate === s.startTranslate) return s.isTouched = !1, s.isMoved = !1, void (s.startMoving = !1); let h; if (s.isTouched = !1, s.isMoved = !1, s.startMoving = !1, h = a.followFinger ? r ? t.translate : -t.translate : -s.currentTranslate, a.cssMode) return; if (t.params.freeMode && a.freeMode.enabled) return void t.freeMode.onTouchEnd({ currentPos: h }); let m = 0, f = t.slidesSizesGrid[0]; for (let e = 0; e < n.length; e += e < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) { const t = e < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup; void 0 !== n[e + t] ? h >= n[e] && h < n[e + t] && (m = e, f = n[e + t] - n[e]) : h >= n[e] && (m = e, f = n[n.length - 1] - n[n.length - 2]) } const g = (h - n[m]) / f, v = m < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup; if (p > a.longSwipesMs) { if (!a.longSwipes) return void t.slideTo(t.activeIndex); "next" === t.swipeDirection && (g >= a.longSwipesRatio ? t.slideTo(m + v) : t.slideTo(m)), "prev" === t.swipeDirection && (g > 1 - a.longSwipesRatio ? t.slideTo(m + v) : t.slideTo(m)) } else { if (!a.shortSwipes) return void t.slideTo(t.activeIndex); t.navigation && (o.target === t.navigation.nextEl || o.target === t.navigation.prevEl) ? o.target === t.navigation.nextEl ? t.slideTo(m + v) : t.slideTo(m) : ("next" === t.swipeDirection && t.slideTo(m + v), "prev" === t.swipeDirection && t.slideTo(m)) } } function k() { const e = this, { params: t, el: s } = e; if (s && 0 === s.offsetWidth) return; t.breakpoints && e.setBreakpoint(); const { allowSlideNext: a, allowSlidePrev: i, snapGrid: r } = e; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), ("auto" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = i, e.allowSlideNext = a, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow() } function z(e) { const t = this; t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))) } function O() { const e = this, { wrapperEl: t, rtlTranslate: s, enabled: a } = e; if (!a) return; let i; e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, -0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const r = e.maxTranslate() - e.minTranslate(); i = 0 === r ? 0 : (e.translate - e.minTranslate()) / r, i !== e.progress && e.updateProgress(s ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1) } let I = !1; function L() { } const A = (e, t) => { const s = a(), { params: i, touchEvents: r, el: n, wrapperEl: l, device: o, support: d } = e, p = !!i.nested, c = "on" === t ? "addEventListener" : "removeEventListener", u = t; if (d.touch) { const t = !("touchstart" !== r.start || !d.passiveListener || !i.passiveListeners) && { passive: !0, capture: !1 }; n[c](r.start, e.onTouchStart, t), n[c](r.move, e.onTouchMove, d.passiveListener ? { passive: !1, capture: p } : p), n[c](r.end, e.onTouchEnd, t), r.cancel && n[c](r.cancel, e.onTouchEnd, t) } else n[c](r.start, e.onTouchStart, !1), s[c](r.move, e.onTouchMove, p), s[c](r.end, e.onTouchEnd, !1); (i.preventClicks || i.preventClicksPropagation) && n[c]("click", e.onClick, !0), i.cssMode && l[c]("scroll", e.onScroll), i.updateOnWindowResize ? e[u](o.ios || o.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", k, !0) : e[u]("observerUpdate", k, !0) }; const D = (e, t) => e.grid && t.grid && t.grid.rows > 1; var G = { init: !0, direction: "horizontal", touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 0, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, loopFillGroupWithBlank: !1, loopPreventsSlide: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-invisible-blank", slideActiveClass: "swiper-slide-active", slideDuplicateActiveClass: "swiper-slide-duplicate-active", slideVisibleClass: "swiper-slide-visible", slideDuplicateClass: "swiper-slide-duplicate", slideNextClass: "swiper-slide-next", slideDuplicateNextClass: "swiper-slide-duplicate-next", slidePrevClass: "swiper-slide-prev", slideDuplicatePrevClass: "swiper-slide-duplicate-prev", wrapperClass: "swiper-wrapper", runCallbacksOnInit: !0, _emitClasses: !1 }; function N(e, t) { return function (s = {}) { const a = Object.keys(s)[0], i = s[a]; "object" == typeof i && null !== i ? (["navigation", "pagination", "scrollbar"].indexOf(a) >= 0 && !0 === e[a] && (e[a] = { auto: !0 }), a in e && "enabled" in i ? (!0 === e[a] && (e[a] = { enabled: !0 }), "object" != typeof e[a] || "enabled" in e[a] || (e[a].enabled = !0), e[a] || (e[a] = { enabled: !1 }), f(t, s)) : f(t, s)) : f(t, s) } } const B = { eventsEmitter: C, update: { updateSize: function () { const e = this; let t, s; const a = e.$el; t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : a[0].clientWidth, s = void 0 !== e.params.height && null !== e.params.height ? e.params.height : a[0].clientHeight, 0 === t && e.isHorizontal() || 0 === s && e.isVertical() || (t = t - parseInt(a.css("padding-left") || 0, 10) - parseInt(a.css("padding-right") || 0, 10), s = s - parseInt(a.css("padding-top") || 0, 10) - parseInt(a.css("padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(s) && (s = 0), Object.assign(e, { width: t, height: s, size: e.isHorizontal() ? t : s })) }, updateSlides: function () { const e = this; function t(t) { return e.isHorizontal() ? t : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[t] } function s(e, s) { return parseFloat(e.getPropertyValue(t(s)) || 0) } const a = e.params, { $wrapperEl: i, size: r, rtlTranslate: n, wrongRTL: l } = e, o = e.virtual && a.virtual.enabled, d = o ? e.virtual.slides.length : e.slides.length, p = i.children(`.${e.params.slideClass}`), c = o ? e.virtual.slides.length : p.length; let u = []; const h = [], m = []; let f = a.slidesOffsetBefore; "function" == typeof f && (f = a.slidesOffsetBefore.call(e)); let v = a.slidesOffsetAfter; "function" == typeof v && (v = a.slidesOffsetAfter.call(e)); const w = e.snapGrid.length, b = e.slidesGrid.length; let x = a.spaceBetween, y = -f, E = 0, T = 0; if (void 0 === r) return; "string" == typeof x && x.indexOf("%") >= 0 && (x = parseFloat(x.replace("%", "")) / 100 * r), e.virtualSize = -x, n ? p.css({ marginLeft: "", marginBottom: "", marginTop: "" }) : p.css({ marginRight: "", marginBottom: "", marginTop: "" }), a.centeredSlides && a.cssMode && (g(e.wrapperEl, "--swiper-centered-offset-before", ""), g(e.wrapperEl, "--swiper-centered-offset-after", "")); const C = a.grid && a.grid.rows > 1 && e.grid; let $; C && e.grid.initSlides(c); const S = "auto" === a.slidesPerView && a.breakpoints && Object.keys(a.breakpoints).filter((e => void 0 !== a.breakpoints[e].slidesPerView)).length > 0; for (let i = 0; i < c; i += 1) { $ = 0; const n = p.eq(i); if (C && e.grid.updateSlide(i, n, c, t), "none" !== n.css("display")) { if ("auto" === a.slidesPerView) { S && (p[i].style[t("width")] = ""); const r = getComputedStyle(n[0]), l = n[0].style.transform, o = n[0].style.webkitTransform; if (l && (n[0].style.transform = "none"), o && (n[0].style.webkitTransform = "none"), a.roundLengths) $ = e.isHorizontal() ? n.outerWidth(!0) : n.outerHeight(!0); else { const e = s(r, "width"), t = s(r, "padding-left"), a = s(r, "padding-right"), i = s(r, "margin-left"), l = s(r, "margin-right"), o = r.getPropertyValue("box-sizing"); if (o && "border-box" === o) $ = e + i + l; else { const { clientWidth: s, offsetWidth: r } = n[0]; $ = e + t + a + i + l + (r - s) } } l && (n[0].style.transform = l), o && (n[0].style.webkitTransform = o), a.roundLengths && ($ = Math.floor($)) } else $ = (r - (a.slidesPerView - 1) * x) / a.slidesPerView, a.roundLengths && ($ = Math.floor($)), p[i] && (p[i].style[t("width")] = `${$}px`); p[i] && (p[i].swiperSlideSize = $), m.push($), a.centeredSlides ? (y = y + $ / 2 + E / 2 + x, 0 === E && 0 !== i && (y = y - r / 2 - x), 0 === i && (y = y - r / 2 - x), Math.abs(y) < .001 && (y = 0), a.roundLengths && (y = Math.floor(y)), T % a.slidesPerGroup == 0 && u.push(y), h.push(y)) : (a.roundLengths && (y = Math.floor(y)), (T - Math.min(e.params.slidesPerGroupSkip, T)) % e.params.slidesPerGroup == 0 && u.push(y), h.push(y), y = y + $ + x), e.virtualSize += $ + x, E = $, T += 1 } } if (e.virtualSize = Math.max(e.virtualSize, r) + v, n && l && ("slide" === a.effect || "coverflow" === a.effect) && i.css({ width: `${e.virtualSize + a.spaceBetween}px` }), a.setWrapperSize && i.css({ [t("width")]: `${e.virtualSize + a.spaceBetween}px` }), C && e.grid.updateWrapperSize($, u, t), !a.centeredSlides) { const t = []; for (let s = 0; s < u.length; s += 1) { let i = u[s]; a.roundLengths && (i = Math.floor(i)), u[s] <= e.virtualSize - r && t.push(i) } u = t, Math.floor(e.virtualSize - r) - Math.floor(u[u.length - 1]) > 1 && u.push(e.virtualSize - r) } if (0 === u.length && (u = [0]), 0 !== a.spaceBetween) { const s = e.isHorizontal() && n ? "marginLeft" : t("marginRight"); p.filter(((e, t) => !a.cssMode || t !== p.length - 1)).css({ [s]: `${x}px` }) } if (a.centeredSlides && a.centeredSlidesBounds) { let e = 0; m.forEach((t => { e += t + (a.spaceBetween ? a.spaceBetween : 0) })), e -= a.spaceBetween; const t = e - r; u = u.map((e => e < 0 ? -f : e > t ? t + v : e)) } if (a.centerInsufficientSlides) { let e = 0; if (m.forEach((t => { e += t + (a.spaceBetween ? a.spaceBetween : 0) })), e -= a.spaceBetween, e < r) { const t = (r - e) / 2; u.forEach(((e, s) => { u[s] = e - t })), h.forEach(((e, s) => { h[s] = e + t })) } } if (Object.assign(e, { slides: p, snapGrid: u, slidesGrid: h, slidesSizesGrid: m }), a.centeredSlides && a.cssMode && !a.centeredSlidesBounds) { g(e.wrapperEl, "--swiper-centered-offset-before", -u[0] + "px"), g(e.wrapperEl, "--swiper-centered-offset-after", e.size / 2 - m[m.length - 1] / 2 + "px"); const t = -e.snapGrid[0], s = -e.slidesGrid[0]; e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + s)) } c !== d && e.emit("slidesLengthChange"), u.length !== w && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), h.length !== b && e.emit("slidesGridLengthChange"), a.watchSlidesProgress && e.updateSlidesOffset() }, updateAutoHeight: function (e) { const t = this, s = [], a = t.virtual && t.params.virtual.enabled; let i, r = 0; "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed); const n = e => a ? t.slides.filter((t => parseInt(t.getAttribute("data-swiper-slide-index"), 10) === e))[0] : t.slides.eq(e)[0]; if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1) if (t.params.centeredSlides) t.visibleSlides.each((e => { s.push(e) })); else for (i = 0; i < Math.ceil(t.params.slidesPerView); i += 1) { const e = t.activeIndex + i; if (e > t.slides.length && !a) break; s.push(n(e)) } else s.push(n(t.activeIndex)); for (i = 0; i < s.length; i += 1)if (void 0 !== s[i]) { const e = s[i].offsetHeight; r = e > r ? e : r } (r || 0 === r) && t.$wrapperEl.css("height", `${r}px`) }, updateSlidesOffset: function () { const e = this, t = e.slides; for (let s = 0; s < t.length; s += 1)t[s].swiperSlideOffset = e.isHorizontal() ? t[s].offsetLeft : t[s].offsetTop }, updateSlidesProgress: function (e = this && this.translate || 0) { const t = this, s = t.params, { slides: a, rtlTranslate: i, snapGrid: r } = t; if (0 === a.length) return; void 0 === a[0].swiperSlideOffset && t.updateSlidesOffset(); let n = -e; i && (n = e), a.removeClass(s.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = []; for (let e = 0; e < a.length; e += 1) { const l = a[e]; let o = l.swiperSlideOffset; s.cssMode && s.centeredSlides && (o -= a[0].swiperSlideOffset); const d = (n + (s.centeredSlides ? t.minTranslate() : 0) - o) / (l.swiperSlideSize + s.spaceBetween), p = (n - r[0] + (s.centeredSlides ? t.minTranslate() : 0) - o) / (l.swiperSlideSize + s.spaceBetween), c = -(n - o), u = c + t.slidesSizesGrid[e]; (c >= 0 && c < t.size - 1 || u > 1 && u <= t.size || c <= 0 && u >= t.size) && (t.visibleSlides.push(l), t.visibleSlidesIndexes.push(e), a.eq(e).addClass(s.slideVisibleClass)), l.progress = i ? -d : d, l.originalProgress = i ? -p : p } t.visibleSlides = d(t.visibleSlides) }, updateProgress: function (e) { const t = this; if (void 0 === e) { const s = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * s || 0 } const s = t.params, a = t.maxTranslate() - t.minTranslate(); let { progress: i, isBeginning: r, isEnd: n } = t; const l = r, o = n; 0 === a ? (i = 0, r = !0, n = !0) : (i = (e - t.minTranslate()) / a, r = i <= 0, n = i >= 1), Object.assign(t, { progress: i, isBeginning: r, isEnd: n }), (s.watchSlidesProgress || s.centeredSlides && s.autoHeight) && t.updateSlidesProgress(e), r && !l && t.emit("reachBeginning toEdge"), n && !o && t.emit("reachEnd toEdge"), (l && !r || o && !n) && t.emit("fromEdge"), t.emit("progress", i) }, updateSlidesClasses: function () { const e = this, { slides: t, params: s, $wrapperEl: a, activeIndex: i, realIndex: r } = e, n = e.virtual && s.virtual.enabled; let l; t.removeClass(`${s.slideActiveClass} ${s.slideNextClass} ${s.slidePrevClass} ${s.slideDuplicateActiveClass} ${s.slideDuplicateNextClass} ${s.slideDuplicatePrevClass}`), l = n ? e.$wrapperEl.find(`.${s.slideClass}[data-swiper-slide-index="${i}"]`) : t.eq(i), l.addClass(s.slideActiveClass), s.loop && (l.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${r}"]`).addClass(s.slideDuplicateActiveClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${r}"]`).addClass(s.slideDuplicateActiveClass)); let o = l.nextAll(`.${s.slideClass}`).eq(0).addClass(s.slideNextClass); s.loop && 0 === o.length && (o = t.eq(0), o.addClass(s.slideNextClass)); let d = l.prevAll(`.${s.slideClass}`).eq(0).addClass(s.slidePrevClass); s.loop && 0 === d.length && (d = t.eq(-1), d.addClass(s.slidePrevClass)), s.loop && (o.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicateNextClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicateNextClass), d.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicatePrevClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicatePrevClass)), e.emitSlidesClasses() }, updateActiveIndex: function (e) { const t = this, s = t.rtlTranslate ? t.translate : -t.translate, { slidesGrid: a, snapGrid: i, params: r, activeIndex: n, realIndex: l, snapIndex: o } = t; let d, p = e; if (void 0 === p) { for (let e = 0; e < a.length; e += 1)void 0 !== a[e + 1] ? s >= a[e] && s < a[e + 1] - (a[e + 1] - a[e]) / 2 ? p = e : s >= a[e] && s < a[e + 1] && (p = e + 1) : s >= a[e] && (p = e); r.normalizeSlideIndex && (p < 0 || void 0 === p) && (p = 0) } if (i.indexOf(s) >= 0) d = i.indexOf(s); else { const e = Math.min(r.slidesPerGroupSkip, p); d = e + Math.floor((p - e) / r.slidesPerGroup) } if (d >= i.length && (d = i.length - 1), p === n) return void (d !== o && (t.snapIndex = d, t.emit("snapIndexChange"))); const c = parseInt(t.slides.eq(p).attr("data-swiper-slide-index") || p, 10); Object.assign(t, { snapIndex: d, realIndex: c, previousIndex: n, activeIndex: p }), t.emit("activeIndexChange"), t.emit("snapIndexChange"), l !== c && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange") }, updateClickedSlide: function (e) { const t = this, s = t.params, a = d(e).closest(`.${s.slideClass}`)[0]; let i, r = !1; if (a) for (let e = 0; e < t.slides.length; e += 1)if (t.slides[e] === a) { r = !0, i = e; break } if (!a || !r) return t.clickedSlide = void 0, void (t.clickedIndex = void 0); t.clickedSlide = a, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(d(a).attr("data-swiper-slide-index"), 10) : t.clickedIndex = i, s.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide() } }, translate: { getTranslate: function (e = (this.isHorizontal() ? "x" : "y")) { const { params: t, rtlTranslate: s, translate: a, $wrapperEl: i } = this; if (t.virtualTranslate) return s ? -a : a; if (t.cssMode) return a; let r = h(i[0], e); return s && (r = -r), r || 0 }, setTranslate: function (e, t) { const s = this, { rtlTranslate: a, params: i, $wrapperEl: r, wrapperEl: n, progress: l } = s; let o, d = 0, p = 0; s.isHorizontal() ? d = a ? -e : e : p = e, i.roundLengths && (d = Math.floor(d), p = Math.floor(p)), i.cssMode ? n[s.isHorizontal() ? "scrollLeft" : "scrollTop"] = s.isHorizontal() ? -d : -p : i.virtualTranslate || r.transform(`translate3d(${d}px, ${p}px, 0px)`), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? d : p; const c = s.maxTranslate() - s.minTranslate(); o = 0 === c ? 0 : (e - s.minTranslate()) / c, o !== l && s.updateProgress(e), s.emit("setTranslate", s.translate, t) }, minTranslate: function () { return -this.snapGrid[0] }, maxTranslate: function () { return -this.snapGrid[this.snapGrid.length - 1] }, translateTo: function (e = 0, t = this.params.speed, s = !0, a = !0, i) { const r = this, { params: n, wrapperEl: l } = r; if (r.animating && n.preventInteractionOnTransition) return !1; const o = r.minTranslate(), d = r.maxTranslate(); let p; if (p = a && e > o ? o : a && e < d ? d : e, r.updateProgress(p), n.cssMode) { const e = r.isHorizontal(); if (0 === t) l[e ? "scrollLeft" : "scrollTop"] = -p; else { if (!r.support.smoothScroll) return v({ swiper: r, targetPosition: -p, side: e ? "left" : "top" }), !0; l.scrollTo({ [e ? "left" : "top"]: -p, behavior: "smooth" }) } return !0 } return 0 === t ? (r.setTransition(0), r.setTranslate(p), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionEnd"))) : (r.setTransition(t), r.setTranslate(p), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, s && r.emit("transitionEnd")) }), r.$wrapperEl[0].addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd))), !0 } }, transition: { setTransition: function (e, t) { const s = this; s.params.cssMode || s.$wrapperEl.transition(e), s.emit("setTransition", e, t) }, transitionStart: function (e = !0, t) { const s = this, { params: a } = s; a.cssMode || (a.autoHeight && s.updateAutoHeight(), $({ swiper: s, runCallbacks: e, direction: t, step: "Start" })) }, transitionEnd: function (e = !0, t) { const s = this, { params: a } = s; s.animating = !1, a.cssMode || (s.setTransition(0), $({ swiper: s, runCallbacks: e, direction: t, step: "End" })) } }, slide: { slideTo: function (e = 0, t = this.params.speed, s = !0, a, i) { if ("number" != typeof e && "string" != typeof e) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`); if ("string" == typeof e) { const t = parseInt(e, 10); if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`); e = t } const r = this; let n = e; n < 0 && (n = 0); const { params: l, snapGrid: o, slidesGrid: d, previousIndex: p, activeIndex: c, rtlTranslate: u, wrapperEl: h, enabled: m } = r; if (r.animating && l.preventInteractionOnTransition || !m && !a && !i) return !1; const f = Math.min(r.params.slidesPerGroupSkip, n); let g = f + Math.floor((n - f) / r.params.slidesPerGroup); g >= o.length && (g = o.length - 1), (c || l.initialSlide || 0) === (p || 0) && s && r.emit("beforeSlideChangeStart"); const w = -o[g]; if (r.updateProgress(w), l.normalizeSlideIndex) for (let e = 0; e < d.length; e += 1) { const t = -Math.floor(100 * w), s = Math.floor(100 * d[e]), a = Math.floor(100 * d[e + 1]); void 0 !== d[e + 1] ? t >= s && t < a - (a - s) / 2 ? n = e : t >= s && t < a && (n = e + 1) : t >= s && (n = e) } if (r.initialized && n !== c) { if (!r.allowSlideNext && w < r.translate && w < r.minTranslate()) return !1; if (!r.allowSlidePrev && w > r.translate && w > r.maxTranslate() && (c || 0) !== n) return !1 } let b; if (b = n > c ? "next" : n < c ? "prev" : "reset", u && -w === r.translate || !u && w === r.translate) return r.updateActiveIndex(n), l.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== l.effect && r.setTranslate(w), "reset" !== b && (r.transitionStart(s, b), r.transitionEnd(s, b)), !1; if (l.cssMode) { const e = r.isHorizontal(), s = u ? w : -w; if (0 === t) { const t = r.virtual && r.params.virtual.enabled; t && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), h[e ? "scrollLeft" : "scrollTop"] = s, t && requestAnimationFrame((() => { r.wrapperEl.style.scrollSnapType = "", r._swiperImmediateVirtual = !1 })) } else { if (!r.support.smoothScroll) return v({ swiper: r, targetPosition: s, side: e ? "left" : "top" }), !0; h.scrollTo({ [e ? "left" : "top"]: s, behavior: "smooth" }) } return !0 } return r.setTransition(t), r.setTranslate(w), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, a), r.transitionStart(s, b), 0 === t ? r.transitionEnd(s, b) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(s, b)) }), r.$wrapperEl[0].addEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd)), !0 }, slideToLoop: function (e = 0, t = this.params.speed, s = !0, a) { const i = this; let r = e; return i.params.loop && (r += i.loopedSlides), i.slideTo(r, t, s, a) }, slideNext: function (e = this.params.speed, t = !0, s) { const a = this, { animating: i, enabled: r, params: n } = a; if (!r) return a; let l = n.slidesPerGroup; "auto" === n.slidesPerView && 1 === n.slidesPerGroup && n.slidesPerGroupAuto && (l = Math.max(a.slidesPerViewDynamic("current", !0), 1)); const o = a.activeIndex < n.slidesPerGroupSkip ? 1 : l; if (n.loop) { if (i && n.loopPreventsSlide) return !1; a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft } return n.rewind && a.isEnd ? a.slideTo(0, e, t, s) : a.slideTo(a.activeIndex + o, e, t, s) }, slidePrev: function (e = this.params.speed, t = !0, s) { const a = this, { params: i, animating: r, snapGrid: n, slidesGrid: l, rtlTranslate: o, enabled: d } = a; if (!d) return a; if (i.loop) { if (r && i.loopPreventsSlide) return !1; a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft } function p(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } const c = p(o ? a.translate : -a.translate), u = n.map((e => p(e))); let h = n[u.indexOf(c) - 1]; if (void 0 === h && i.cssMode) { let e; n.forEach(((t, s) => { c >= t && (e = s) })), void 0 !== e && (h = n[e > 0 ? e - 1 : e]) } let m = 0; return void 0 !== h && (m = l.indexOf(h), m < 0 && (m = a.activeIndex - 1), "auto" === i.slidesPerView && 1 === i.slidesPerGroup && i.slidesPerGroupAuto && (m = m - a.slidesPerViewDynamic("previous", !0) + 1, m = Math.max(m, 0))), i.rewind && a.isBeginning ? a.slideTo(a.slides.length - 1, e, t, s) : a.slideTo(m, e, t, s) }, slideReset: function (e = this.params.speed, t = !0, s) { return this.slideTo(this.activeIndex, e, t, s) }, slideToClosest: function (e = this.params.speed, t = !0, s, a = .5) { const i = this; let r = i.activeIndex; const n = Math.min(i.params.slidesPerGroupSkip, r), l = n + Math.floor((r - n) / i.params.slidesPerGroup), o = i.rtlTranslate ? i.translate : -i.translate; if (o >= i.snapGrid[l]) { const e = i.snapGrid[l]; o - e > (i.snapGrid[l + 1] - e) * a && (r += i.params.slidesPerGroup) } else { const e = i.snapGrid[l - 1]; o - e <= (i.snapGrid[l] - e) * a && (r -= i.params.slidesPerGroup) } return r = Math.max(r, 0), r = Math.min(r, i.slidesGrid.length - 1), i.slideTo(r, e, t, s) }, slideToClickedSlide: function () { const e = this, { params: t, $wrapperEl: s } = e, a = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView; let i, r = e.clickedIndex; if (t.loop) { if (e.animating) return; i = parseInt(d(e.clickedSlide).attr("data-swiper-slide-index"), 10), t.centeredSlides ? r < e.loopedSlides - a / 2 || r > e.slides.length - e.loopedSlides + a / 2 ? (e.loopFix(), r = s.children(`.${t.slideClass}[data-swiper-slide-index="${i}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), c((() => { e.slideTo(r) }))) : e.slideTo(r) : r > e.slides.length - a ? (e.loopFix(), r = s.children(`.${t.slideClass}[data-swiper-slide-index="${i}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), c((() => { e.slideTo(r) }))) : e.slideTo(r) } else e.slideTo(r) } }, loop: { loopCreate: function () { const e = this, t = a(), { params: s, $wrapperEl: i } = e, r = i.children().length > 0 ? d(i.children()[0].parentNode) : i; r.children(`.${s.slideClass}.${s.slideDuplicateClass}`).remove(); let n = r.children(`.${s.slideClass}`); if (s.loopFillGroupWithBlank) { const e = s.slidesPerGroup - n.length % s.slidesPerGroup; if (e !== s.slidesPerGroup) { for (let a = 0; a < e; a += 1) { const e = d(t.createElement("div")).addClass(`${s.slideClass} ${s.slideBlankClass}`); r.append(e) } n = r.children(`.${s.slideClass}`) } } "auto" !== s.slidesPerView || s.loopedSlides || (s.loopedSlides = n.length), e.loopedSlides = Math.ceil(parseFloat(s.loopedSlides || s.slidesPerView, 10)), e.loopedSlides += s.loopAdditionalSlides, e.loopedSlides > n.length && (e.loopedSlides = n.length); const l = [], o = []; n.each(((t, s) => { const a = d(t); s < e.loopedSlides && o.push(t), s < n.length && s >= n.length - e.loopedSlides && l.push(t), a.attr("data-swiper-slide-index", s) })); for (let e = 0; e < o.length; e += 1)r.append(d(o[e].cloneNode(!0)).addClass(s.slideDuplicateClass)); for (let e = l.length - 1; e >= 0; e -= 1)r.prepend(d(l[e].cloneNode(!0)).addClass(s.slideDuplicateClass)) }, loopFix: function () { const e = this; e.emit("beforeLoopFix"); const { activeIndex: t, slides: s, loopedSlides: a, allowSlidePrev: i, allowSlideNext: r, snapGrid: n, rtlTranslate: l } = e; let o; e.allowSlidePrev = !0, e.allowSlideNext = !0; const d = -n[t] - e.getTranslate(); if (t < a) { o = s.length - 3 * a + t, o += a; e.slideTo(o, 0, !1, !0) && 0 !== d && e.setTranslate((l ? -e.translate : e.translate) - d) } else if (t >= s.length - a) { o = -s.length + t + a, o += a; e.slideTo(o, 0, !1, !0) && 0 !== d && e.setTranslate((l ? -e.translate : e.translate) - d) } e.allowSlidePrev = i, e.allowSlideNext = r, e.emit("loopFix") }, loopDestroy: function () { const { $wrapperEl: e, params: t, slides: s } = this; e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), s.removeAttr("data-swiper-slide-index") } }, grabCursor: { setGrabCursor: function (e) { const t = this; if (t.support.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return; const s = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl; s.style.cursor = "move", s.style.cursor = e ? "-webkit-grabbing" : "-webkit-grab", s.style.cursor = e ? "-moz-grabbin" : "-moz-grab", s.style.cursor = e ? "grabbing" : "grab" }, unsetGrabCursor: function () { const e = this; e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "") } }, events: { attachEvents: function () { const e = this, t = a(), { params: s, support: i } = e; e.onTouchStart = S.bind(e), e.onTouchMove = M.bind(e), e.onTouchEnd = P.bind(e), s.cssMode && (e.onScroll = O.bind(e)), e.onClick = z.bind(e), i.touch && !I && (t.addEventListener("touchstart", L), I = !0), A(e, "on") }, detachEvents: function () { A(this, "off") } }, breakpoints: { setBreakpoint: function () { const e = this, { activeIndex: t, initialized: s, loopedSlides: a = 0, params: i, $el: r } = e, n = i.breakpoints; if (!n || n && 0 === Object.keys(n).length) return; const l = e.getBreakpoint(n, e.params.breakpointsBase, e.el); if (!l || e.currentBreakpoint === l) return; const o = (l in n ? n[l] : void 0) || e.originalParams, d = D(e, i), p = D(e, o), c = i.enabled; d && !p ? (r.removeClass(`${i.containerModifierClass}grid ${i.containerModifierClass}grid-column`), e.emitContainerClasses()) : !d && p && (r.addClass(`${i.containerModifierClass}grid`), (o.grid.fill && "column" === o.grid.fill || !o.grid.fill && "column" === i.grid.fill) && r.addClass(`${i.containerModifierClass}grid-column`), e.emitContainerClasses()); const u = o.direction && o.direction !== i.direction, h = i.loop && (o.slidesPerView !== i.slidesPerView || u); u && s && e.changeDirection(), f(e.params, o); const m = e.params.enabled; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), c && !m ? e.disable() : !c && m && e.enable(), e.currentBreakpoint = l, e.emit("_beforeBreakpoint", o), h && s && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - a + e.loopedSlides, 0, !1)), e.emit("breakpoint", o) }, getBreakpoint: function (e, t = "window", s) { if (!e || "container" === t && !s) return; let a = !1; const i = r(), n = "window" === t ? i.innerHeight : s.clientHeight, l = Object.keys(e).map((e => { if ("string" == typeof e && 0 === e.indexOf("@")) { const t = parseFloat(e.substr(1)); return { value: n * t, point: e } } return { value: e, point: e } })); l.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10))); for (let e = 0; e < l.length; e += 1) { const { point: r, value: n } = l[e]; "window" === t ? i.matchMedia(`(min-width: ${n}px)`).matches && (a = r) : n <= s.clientWidth && (a = r) } return a || "max" } }, checkOverflow: { checkOverflow: function () { const e = this, { isLocked: t, params: s } = e, { slidesOffsetBefore: a } = s; if (a) { const t = e.slides.length - 1, s = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * a; e.isLocked = e.size > s } else e.isLocked = 1 === e.snapGrid.length; !0 === s.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === s.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock") } }, classes: { addClasses: function () { const e = this, { classNames: t, params: s, rtl: a, $el: i, device: r, support: n } = e, l = function (e, t) { const s = []; return e.forEach((e => { "object" == typeof e ? Object.keys(e).forEach((a => { e[a] && s.push(t + a) })) : "string" == typeof e && s.push(t + e) })), s }(["initialized", s.direction, { "pointer-events": !n.touch }, { "free-mode": e.params.freeMode && s.freeMode.enabled }, { autoheight: s.autoHeight }, { rtl: a }, { grid: s.grid && s.grid.rows > 1 }, { "grid-column": s.grid && s.grid.rows > 1 && "column" === s.grid.fill }, { android: r.android }, { ios: r.ios }, { "css-mode": s.cssMode }, { centered: s.cssMode && s.centeredSlides }], s.containerModifierClass); t.push(...l), i.addClass([...t].join(" ")), e.emitContainerClasses() }, removeClasses: function () { const { $el: e, classNames: t } = this; e.removeClass(t.join(" ")), this.emitContainerClasses() } }, images: { loadImage: function (e, t, s, a, i, n) { const l = r(); let o; function p() { n && n() } d(e).parent("picture")[0] || e.complete && i ? p() : t ? (o = new l.Image, o.onload = p, o.onerror = p, a && (o.sizes = a), s && (o.srcset = s), t && (o.src = t)) : p() }, preloadImages: function () { const e = this; function t() { null != e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady"))) } e.imagesToLoad = e.$el.find("img"); for (let s = 0; s < e.imagesToLoad.length; s += 1) { const a = e.imagesToLoad[s]; e.loadImage(a, a.currentSrc || a.getAttribute("src"), a.srcset || a.getAttribute("srcset"), a.sizes || a.getAttribute("sizes"), !0, t) } } } }, X = {}; class H { constructor(...e) { let t, s; if (1 === e.length && e[0].constructor && "Object" === Object.prototype.toString.call(e[0]).slice(8, -1) ? s = e[0] : [t, s] = e, s || (s = {}), s = f({}, s), t && !s.el && (s.el = t), s.el && d(s.el).length > 1) { const e = []; return d(s.el).each((t => { const a = f({}, s, { el: t }); e.push(new H(a)) })), e } const a = this; a.__swiper__ = !0, a.support = y(), a.device = E({ userAgent: s.userAgent }), a.browser = T(), a.eventsListeners = {}, a.eventsAnyListeners = [], a.modules = [...a.__modules__], s.modules && Array.isArray(s.modules) && a.modules.push(...s.modules); const i = {}; a.modules.forEach((e => { e({ swiper: a, extendParams: N(s, i), on: a.on.bind(a), once: a.once.bind(a), off: a.off.bind(a), emit: a.emit.bind(a) }) })); const r = f({}, G, i); return a.params = f({}, r, X, s), a.originalParams = f({}, a.params), a.passedParams = f({}, s), a.params && a.params.on && Object.keys(a.params.on).forEach((e => { a.on(e, a.params.on[e]) })), a.params && a.params.onAny && a.onAny(a.params.onAny), a.$ = d, Object.assign(a, { enabled: a.params.enabled, el: t, classNames: [], slides: d(), slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal: () => "horizontal" === a.params.direction, isVertical: () => "vertical" === a.params.direction, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, allowSlideNext: a.params.allowSlideNext, allowSlidePrev: a.params.allowSlidePrev, touchEvents: function () { const e = ["touchstart", "touchmove", "touchend", "touchcancel"], t = ["pointerdown", "pointermove", "pointerup"]; return a.touchEventsTouch = { start: e[0], move: e[1], end: e[2], cancel: e[3] }, a.touchEventsDesktop = { start: t[0], move: t[1], end: t[2] }, a.support.touch || !a.params.simulateTouch ? a.touchEventsTouch : a.touchEventsDesktop }(), touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: a.params.focusableElements, lastClickTime: u(), clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, isTouchEvent: void 0, startMoving: void 0 }, allowClick: !0, allowTouchMove: a.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), a.emit("_swiper"), a.params.init && a.init(), a } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, t) { const s = this; e = Math.min(Math.max(e, 0), 1); const a = s.minTranslate(), i = (s.maxTranslate() - a) * e + a; s.translateTo(i, void 0 === t ? 0 : t), s.updateActiveIndex(), s.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass))); e.emit("_containerClasses", t.join(" ")) } getSlideClasses(e) { const t = this; return e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = []; e.slides.each((s => { const a = e.getSlideClasses(s); t.push({ slideEl: s, classNames: a }), e.emit("_slideClass", s, a) })), e.emit("_slideClasses", t) } slidesPerViewDynamic(e = "current", t = !1) { const { params: s, slides: a, slidesGrid: i, slidesSizesGrid: r, size: n, activeIndex: l } = this; let o = 1; if (s.centeredSlides) { let e, t = a[l].swiperSlideSize; for (let s = l + 1; s < a.length; s += 1)a[s] && !e && (t += a[s].swiperSlideSize, o += 1, t > n && (e = !0)); for (let s = l - 1; s >= 0; s -= 1)a[s] && !e && (t += a[s].swiperSlideSize, o += 1, t > n && (e = !0)) } else if ("current" === e) for (let e = l + 1; e < a.length; e += 1) { (t ? i[e] + r[e] - i[l] < n : i[e] - i[l] < n) && (o += 1) } else for (let e = l - 1; e >= 0; e -= 1) { i[l] - i[e] < n && (o += 1) } return o } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: s } = e; function a() { const t = e.rtlTranslate ? -1 * e.translate : e.translate, s = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(s), e.updateActiveIndex(), e.updateSlidesClasses() } let i; s.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode && e.params.freeMode.enabled ? (a(), e.params.autoHeight && e.updateAutoHeight()) : (i = ("auto" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), i || a()), s.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e, t = !0) { const s = this, a = s.params.direction; return e || (e = "horizontal" === a ? "vertical" : "horizontal"), e === a || "horizontal" !== e && "vertical" !== e || (s.$el.removeClass(`${s.params.containerModifierClass}${a}`).addClass(`${s.params.containerModifierClass}${e}`), s.emitContainerClasses(), s.params.direction = e, s.slides.each((t => { "vertical" === e ? t.style.width = "" : t.style.height = "" })), s.emit("changeDirection"), t && s.update()), s } mount(e) { const t = this; if (t.mounted) return !0; const s = d(e || t.params.el); if (!(e = s[0])) return !1; e.swiper = t; const i = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`; let r = (() => { if (e && e.shadowRoot && e.shadowRoot.querySelector) { const t = d(e.shadowRoot.querySelector(i())); return t.children = e => s.children(e), t } return s.children(i()) })(); if (0 === r.length && t.params.createElements) { const e = a().createElement("div"); r = d(e), e.className = t.params.wrapperClass, s.append(e), s.children(`.${t.params.slideClass}`).each((e => { r.append(e) })) } return Object.assign(t, { $el: s, el: e, $wrapperEl: r, wrapperEl: r[0], mounted: !0, rtl: "rtl" === e.dir.toLowerCase() || "rtl" === s.css("direction"), rtlTranslate: "horizontal" === t.params.direction && ("rtl" === e.dir.toLowerCase() || "rtl" === s.css("direction")), wrongRTL: "-webkit-box" === r.css("display") }), !0 } init(e) { const t = this; if (t.initialized) return t; return !1 === t.mount(e) || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.params.loop && t.loopCreate(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.preloadImages && t.preloadImages(), t.params.loop ? t.slideTo(t.params.initialSlide + t.loopedSlides, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.attachEvents(), t.initialized = !0, t.emit("init"), t.emit("afterInit")), t } destroy(e = !0, t = !0) { const s = this, { params: a, $el: i, $wrapperEl: r, slides: n } = s; return void 0 === s.params || s.destroyed || (s.emit("beforeDestroy"), s.initialized = !1, s.detachEvents(), a.loop && s.loopDestroy(), t && (s.removeClasses(), i.removeAttr("style"), r.removeAttr("style"), n && n.length && n.removeClass([a.slideVisibleClass, a.slideActiveClass, a.slideNextClass, a.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), s.emit("destroy"), Object.keys(s.eventsListeners).forEach((e => { s.off(e) })), !1 !== e && (s.$el[0].swiper = null, function (e) { const t = e; Object.keys(t).forEach((e => { try { t[e] = null } catch (e) { } try { delete t[e] } catch (e) { } })) }(s)), s.destroyed = !0), null } static extendDefaults(e) { f(X, e) } static get extendedDefaults() { return X } static get defaults() { return G } static installModule(e) { H.prototype.__modules__ || (H.prototype.__modules__ = []); const t = H.prototype.__modules__; "function" == typeof e && t.indexOf(e) < 0 && t.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach((e => H.installModule(e))), H) : (H.installModule(e), H) } } function Y(e, t, s, i) { const r = a(); return e.params.createElements && Object.keys(i).forEach((a => { if (!s[a] && !0 === s.auto) { let n = e.$el.children(`.${i[a]}`)[0]; n || (n = r.createElement("div"), n.className = i[a], e.$el.append(n)), s[a] = n, t[a] = n } })), s } function W(e = "") { return `.${e.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}` } function R(e) { const t = this, { $wrapperEl: s, params: a } = t; if (a.loop && t.loopDestroy(), "object" == typeof e && "length" in e) for (let t = 0; t < e.length; t += 1)e[t] && s.append(e[t]); else s.append(e); a.loop && t.loopCreate(), a.observer || t.update() } function j(e) { const t = this, { params: s, $wrapperEl: a, activeIndex: i } = t; s.loop && t.loopDestroy(); let r = i + 1; if ("object" == typeof e && "length" in e) { for (let t = 0; t < e.length; t += 1)e[t] && a.prepend(e[t]); r = i + e.length } else a.prepend(e); s.loop && t.loopCreate(), s.observer || t.update(), t.slideTo(r, 0, !1) } function _(e, t) { const s = this, { $wrapperEl: a, params: i, activeIndex: r } = s; let n = r; i.loop && (n -= s.loopedSlides, s.loopDestroy(), s.slides = a.children(`.${i.slideClass}`)); const l = s.slides.length; if (e <= 0) return void s.prependSlide(t); if (e >= l) return void s.appendSlide(t); let o = n > e ? n + 1 : n; const d = []; for (let t = l - 1; t >= e; t -= 1) { const e = s.slides.eq(t); e.remove(), d.unshift(e) } if ("object" == typeof t && "length" in t) { for (let e = 0; e < t.length; e += 1)t[e] && a.append(t[e]); o = n > e ? n + t.length : n } else a.append(t); for (let e = 0; e < d.length; e += 1)a.append(d[e]); i.loop && s.loopCreate(), i.observer || s.update(), i.loop ? s.slideTo(o + s.loopedSlides, 0, !1) : s.slideTo(o, 0, !1) } function V(e) { const t = this, { params: s, $wrapperEl: a, activeIndex: i } = t; let r = i; s.loop && (r -= t.loopedSlides, t.loopDestroy(), t.slides = a.children(`.${s.slideClass}`)); let n, l = r; if ("object" == typeof e && "length" in e) { for (let s = 0; s < e.length; s += 1)n = e[s], t.slides[n] && t.slides.eq(n).remove(), n < l && (l -= 1); l = Math.max(l, 0) } else n = e, t.slides[n] && t.slides.eq(n).remove(), n < l && (l -= 1), l = Math.max(l, 0); s.loop && t.loopCreate(), s.observer || t.update(), s.loop ? t.slideTo(l + t.loopedSlides, 0, !1) : t.slideTo(l, 0, !1) } function q() { const e = this, t = []; for (let s = 0; s < e.slides.length; s += 1)t.push(s); e.removeSlide(t) } function F(e) { const { effect: t, swiper: s, on: a, setTranslate: i, setTransition: r, overwriteParams: n, perspective: l } = e; a("beforeInit", (() => { if (s.params.effect !== t) return; s.classNames.push(`${s.params.containerModifierClass}${t}`), l && l() && s.classNames.push(`${s.params.containerModifierClass}3d`); const e = n ? n() : {}; Object.assign(s.params, e), Object.assign(s.originalParams, e) })), a("setTranslate", (() => { s.params.effect === t && i() })), a("setTransition", ((e, a) => { s.params.effect === t && r(a) })) } function U(e, t) { return e.transformEl ? t.find(e.transformEl).css({ "backface-visibility": "hidden", "-webkit-backface-visibility": "hidden" }) : t } function K({ swiper: e, duration: t, transformEl: s, allSlides: a }) { const { slides: i, activeIndex: r, $wrapperEl: n } = e; if (e.params.virtualTranslate && 0 !== t) { let t, l = !1; t = a ? s ? i.find(s) : i : s ? i.eq(r).find(s) : i.eq(r), t.transitionEnd((() => { if (l) return; if (!e || e.destroyed) return; l = !0, e.animating = !1; const t = ["webkitTransitionEnd", "transitionend"]; for (let e = 0; e < t.length; e += 1)n.trigger(t[e]) })) } } function Z(e, t, s) { const a = "swiper-slide-shadow" + (s ? `-${s}` : ""), i = e.transformEl ? t.find(e.transformEl) : t; let r = i.children(`.${a}`); return r.length || (r = d(`<div class="swiper-slide-shadow${s ? `-${s}` : ""}"></div>`), i.append(r)), r } Object.keys(B).forEach((e => { Object.keys(B[e]).forEach((t => { H.prototype[t] = B[e][t] })) })), H.use([function ({ swiper: e, on: t, emit: s }) { const a = r(); let i = null; const n = () => { e && !e.destroyed && e.initialized && (s("beforeResize"), s("resize")) }, l = () => { e && !e.destroyed && e.initialized && s("orientationchange") }; t("init", (() => { e.params.resizeObserver && void 0 !== a.ResizeObserver ? e && !e.destroyed && e.initialized && (i = new ResizeObserver((t => { const { width: s, height: a } = e; let i = s, r = a; t.forEach((({ contentBoxSize: t, contentRect: s, target: a }) => { a && a !== e.el || (i = s ? s.width : (t[0] || t).inlineSize, r = s ? s.height : (t[0] || t).blockSize) })), i === s && r === a || n() })), i.observe(e.el)) : (a.addEventListener("resize", n), a.addEventListener("orientationchange", l)) })), t("destroy", (() => { i && i.unobserve && e.el && (i.unobserve(e.el), i = null), a.removeEventListener("resize", n), a.removeEventListener("orientationchange", l) })) }, function ({ swiper: e, extendParams: t, on: s, emit: a }) { const i = [], n = r(), l = (e, t = {}) => { const s = new (n.MutationObserver || n.WebkitMutationObserver)((e => { if (1 === e.length) return void a("observerUpdate", e[0]); const t = function () { a("observerUpdate", e[0]) }; n.requestAnimationFrame ? n.requestAnimationFrame(t) : n.setTimeout(t, 0) })); s.observe(e, { attributes: void 0 === t.attributes || t.attributes, childList: void 0 === t.childList || t.childList, characterData: void 0 === t.characterData || t.characterData }), i.push(s) }; t({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), s("init", (() => { if (e.params.observer) { if (e.params.observeParents) { const t = e.$el.parents(); for (let e = 0; e < t.length; e += 1)l(t[e]) } l(e.$el[0], { childList: e.params.observeSlideChildren }), l(e.$wrapperEl[0], { attributes: !1 }) } })), s("destroy", (() => { i.forEach((e => { e.disconnect() })), i.splice(0, i.length) })) }]); const J = [function ({ swiper: e, extendParams: t, on: s }) { let a; function i(t, s) { const a = e.params.virtual; if (a.cache && e.virtual.cache[s]) return e.virtual.cache[s]; const i = a.renderSlide ? d(a.renderSlide.call(e, t, s)) : d(`<div class="${e.params.slideClass}" data-swiper-slide-index="${s}">${t}</div>`); return i.attr("data-swiper-slide-index") || i.attr("data-swiper-slide-index", s), a.cache && (e.virtual.cache[s] = i), i } function r(t) { const { slidesPerView: s, slidesPerGroup: a, centeredSlides: r } = e.params, { addSlidesBefore: n, addSlidesAfter: l } = e.params.virtual, { from: o, to: d, slides: p, slidesGrid: c, offset: u } = e.virtual; e.params.cssMode || e.updateActiveIndex(); const h = e.activeIndex || 0; let m, f, g; m = e.rtlTranslate ? "right" : e.isHorizontal() ? "left" : "top", r ? (f = Math.floor(s / 2) + a + l, g = Math.floor(s / 2) + a + n) : (f = s + (a - 1) + l, g = a + n); const v = Math.max((h || 0) - g, 0), w = Math.min((h || 0) + f, p.length - 1), b = (e.slidesGrid[v] || 0) - (e.slidesGrid[0] || 0); function x() { e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.lazy && e.params.lazy.enabled && e.lazy.load() } if (Object.assign(e.virtual, { from: v, to: w, offset: b, slidesGrid: e.slidesGrid }), o === v && d === w && !t) return e.slidesGrid !== c && b !== u && e.slides.css(m, `${b}px`), void e.updateProgress(); if (e.params.virtual.renderExternal) return e.params.virtual.renderExternal.call(e, { offset: b, from: v, to: w, slides: function () { const e = []; for (let t = v; t <= w; t += 1)e.push(p[t]); return e }() }), void (e.params.virtual.renderExternalUpdate && x()); const y = [], E = []; if (t) e.$wrapperEl.find(`.${e.params.slideClass}`).remove(); else for (let t = o; t <= d; t += 1)(t < v || t > w) && e.$wrapperEl.find(`.${e.params.slideClass}[data-swiper-slide-index="${t}"]`).remove(); for (let e = 0; e < p.length; e += 1)e >= v && e <= w && (void 0 === d || t ? E.push(e) : (e > d && E.push(e), e < o && y.push(e))); E.forEach((t => { e.$wrapperEl.append(i(p[t], t)) })), y.sort(((e, t) => t - e)).forEach((t => { e.$wrapperEl.prepend(i(p[t], t)) })), e.$wrapperEl.children(".swiper-slide").css(m, `${b}px`), x() } t({ virtual: { enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, renderExternalUpdate: !0, addSlidesBefore: 0, addSlidesAfter: 0 } }), e.virtual = { cache: {}, from: void 0, to: void 0, slides: [], offset: 0, slidesGrid: [] }, s("beforeInit", (() => { e.params.virtual.enabled && (e.virtual.slides = e.params.virtual.slides, e.classNames.push(`${e.params.containerModifierClass}virtual`), e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0, e.params.initialSlide || r()) })), s("setTranslate", (() => { e.params.virtual.enabled && (e.params.cssMode && !e._immediateVirtual ? (clearTimeout(a), a = setTimeout((() => { r() }), 100)) : r()) })), s("init update resize", (() => { e.params.virtual.enabled && e.params.cssMode && g(e.wrapperEl, "--swiper-virtual-size", `${e.virtualSize}px`) })), Object.assign(e.virtual, { appendSlide: function (t) { if ("object" == typeof t && "length" in t) for (let s = 0; s < t.length; s += 1)t[s] && e.virtual.slides.push(t[s]); else e.virtual.slides.push(t); r(!0) }, prependSlide: function (t) { const s = e.activeIndex; let a = s + 1, i = 1; if (Array.isArray(t)) { for (let s = 0; s < t.length; s += 1)t[s] && e.virtual.slides.unshift(t[s]); a = s + t.length, i = t.length } else e.virtual.slides.unshift(t); if (e.params.virtual.cache) { const t = e.virtual.cache, s = {}; Object.keys(t).forEach((e => { const a = t[e], r = a.attr("data-swiper-slide-index"); r && a.attr("data-swiper-slide-index", parseInt(r, 10) + i), s[parseInt(e, 10) + i] = a })), e.virtual.cache = s } r(!0), e.slideTo(a, 0) }, removeSlide: function (t) { if (null == t) return; let s = e.activeIndex; if (Array.isArray(t)) for (let a = t.length - 1; a >= 0; a -= 1)e.virtual.slides.splice(t[a], 1), e.params.virtual.cache && delete e.virtual.cache[t[a]], t[a] < s && (s -= 1), s = Math.max(s, 0); else e.virtual.slides.splice(t, 1), e.params.virtual.cache && delete e.virtual.cache[t], t < s && (s -= 1), s = Math.max(s, 0); r(!0), e.slideTo(s, 0) }, removeAllSlides: function () { e.virtual.slides = [], e.params.virtual.cache && (e.virtual.cache = {}), r(!0), e.slideTo(0, 0) }, update: r }) }, function ({ swiper: e, extendParams: t, on: s, emit: i }) { const n = a(), l = r(); function o(t) { if (!e.enabled) return; const { rtlTranslate: s } = e; let a = t; a.originalEvent && (a = a.originalEvent); const r = a.keyCode || a.charCode, o = e.params.keyboard.pageUpDown, d = o && 33 === r, p = o && 34 === r, c = 37 === r, u = 39 === r, h = 38 === r, m = 40 === r; if (!e.allowSlideNext && (e.isHorizontal() && u || e.isVertical() && m || p)) return !1; if (!e.allowSlidePrev && (e.isHorizontal() && c || e.isVertical() && h || d)) return !1; if (!(a.shiftKey || a.altKey || a.ctrlKey || a.metaKey || n.activeElement && n.activeElement.nodeName && ("input" === n.activeElement.nodeName.toLowerCase() || "textarea" === n.activeElement.nodeName.toLowerCase()))) { if (e.params.keyboard.onlyInViewport && (d || p || c || u || h || m)) { let t = !1; if (e.$el.parents(`.${e.params.slideClass}`).length > 0 && 0 === e.$el.parents(`.${e.params.slideActiveClass}`).length) return; const a = e.$el, i = a[0].clientWidth, r = a[0].clientHeight, n = l.innerWidth, o = l.innerHeight, d = e.$el.offset(); s && (d.left -= e.$el[0].scrollLeft); const p = [[d.left, d.top], [d.left + i, d.top], [d.left, d.top + r], [d.left + i, d.top + r]]; for (let e = 0; e < p.length; e += 1) { const s = p[e]; if (s[0] >= 0 && s[0] <= n && s[1] >= 0 && s[1] <= o) { if (0 === s[0] && 0 === s[1]) continue; t = !0 } } if (!t) return } e.isHorizontal() ? ((d || p || c || u) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), ((p || u) && !s || (d || c) && s) && e.slideNext(), ((d || c) && !s || (p || u) && s) && e.slidePrev()) : ((d || p || h || m) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), (p || m) && e.slideNext(), (d || h) && e.slidePrev()), i("keyPress", r) } } function p() { e.keyboard.enabled || (d(n).on("keydown", o), e.keyboard.enabled = !0) } function c() { e.keyboard.enabled && (d(n).off("keydown", o), e.keyboard.enabled = !1) } e.keyboard = { enabled: !1 }, t({ keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } }), s("init", (() => { e.params.keyboard.enabled && p() })), s("destroy", (() => { e.keyboard.enabled && c() })), Object.assign(e.keyboard, { enable: p, disable: c }) }, function ({ swiper: e, extendParams: t, on: s, emit: a }) { const i = r(); let n; t({ mousewheel: { enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarget: "container", thresholdDelta: null, thresholdTime: null } }), e.mousewheel = { enabled: !1 }; let l, o = u(); const p = []; function h() { e.enabled && (e.mouseEntered = !0) } function m() { e.enabled && (e.mouseEntered = !1) } function f(t) { return !(e.params.mousewheel.thresholdDelta && t.delta < e.params.mousewheel.thresholdDelta) && (!(e.params.mousewheel.thresholdTime && u() - o < e.params.mousewheel.thresholdTime) && (t.delta >= 6 && u() - o < 60 || (t.direction < 0 ? e.isEnd && !e.params.loop || e.animating || (e.slideNext(), a("scroll", t.raw)) : e.isBeginning && !e.params.loop || e.animating || (e.slidePrev(), a("scroll", t.raw)), o = (new i.Date).getTime(), !1))) } function g(t) { let s = t, i = !0; if (!e.enabled) return; const r = e.params.mousewheel; e.params.cssMode && s.preventDefault(); let o = e.$el; if ("container" !== e.params.mousewheel.eventsTarget && (o = d(e.params.mousewheel.eventsTarget)), !e.mouseEntered && !o[0].contains(s.target) && !r.releaseOnEdges) return !0; s.originalEvent && (s = s.originalEvent); let h = 0; const m = e.rtlTranslate ? -1 : 1, g = function (e) { let t = 0, s = 0, a = 0, i = 0; return "detail" in e && (s = e.detail), "wheelDelta" in e && (s = -e.wheelDelta / 120), "wheelDeltaY" in e && (s = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = s, s = 0), a = 10 * t, i = 10 * s, "deltaY" in e && (i = e.deltaY), "deltaX" in e && (a = e.deltaX), e.shiftKey && !a && (a = i, i = 0), (a || i) && e.deltaMode && (1 === e.deltaMode ? (a *= 40, i *= 40) : (a *= 800, i *= 800)), a && !t && (t = a < 1 ? -1 : 1), i && !s && (s = i < 1 ? -1 : 1), { spinX: t, spinY: s, pixelX: a, pixelY: i } }(s); if (r.forceToAxis) if (e.isHorizontal()) { if (!(Math.abs(g.pixelX) > Math.abs(g.pixelY))) return !0; h = -g.pixelX * m } else { if (!(Math.abs(g.pixelY) > Math.abs(g.pixelX))) return !0; h = -g.pixelY } else h = Math.abs(g.pixelX) > Math.abs(g.pixelY) ? -g.pixelX * m : -g.pixelY; if (0 === h) return !0; r.invert && (h = -h); let v = e.getTranslate() + h * r.sensitivity; if (v >= e.minTranslate() && (v = e.minTranslate()), v <= e.maxTranslate() && (v = e.maxTranslate()), i = !!e.params.loop || !(v === e.minTranslate() || v === e.maxTranslate()), i && e.params.nested && s.stopPropagation(), e.params.freeMode && e.params.freeMode.enabled) { const t = { time: u(), delta: Math.abs(h), direction: Math.sign(h) }, i = l && t.time < l.time + 500 && t.delta <= l.delta && t.direction === l.direction; if (!i) { l = void 0, e.params.loop && e.loopFix(); let o = e.getTranslate() + h * r.sensitivity; const d = e.isBeginning, u = e.isEnd; if (o >= e.minTranslate() && (o = e.minTranslate()), o <= e.maxTranslate() && (o = e.maxTranslate()), e.setTransition(0), e.setTranslate(o), e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses(), (!d && e.isBeginning || !u && e.isEnd) && e.updateSlidesClasses(), e.params.freeMode.sticky) { clearTimeout(n), n = void 0, p.length >= 15 && p.shift(); const s = p.length ? p[p.length - 1] : void 0, a = p[0]; if (p.push(t), s && (t.delta > s.delta || t.direction !== s.direction)) p.splice(0); else if (p.length >= 15 && t.time - a.time < 500 && a.delta - t.delta >= 1 && t.delta <= 6) { const s = h > 0 ? .8 : .2; l = t, p.splice(0), n = c((() => { e.slideToClosest(e.params.speed, !0, void 0, s) }), 0) } n || (n = c((() => { l = t, p.splice(0), e.slideToClosest(e.params.speed, !0, void 0, .5) }), 500)) } if (i || a("scroll", s), e.params.autoplay && e.params.autoplayDisableOnInteraction && e.autoplay.stop(), o === e.minTranslate() || o === e.maxTranslate()) return !0 } } else { const s = { time: u(), delta: Math.abs(h), direction: Math.sign(h), raw: t }; p.length >= 2 && p.shift(); const a = p.length ? p[p.length - 1] : void 0; if (p.push(s), a ? (s.direction !== a.direction || s.delta > a.delta || s.time > a.time + 150) && f(s) : f(s), function (t) { const s = e.params.mousewheel; if (t.direction < 0) { if (e.isEnd && !e.params.loop && s.releaseOnEdges) return !0 } else if (e.isBeginning && !e.params.loop && s.releaseOnEdges) return !0; return !1 }(s)) return !0 } return s.preventDefault ? s.preventDefault() : s.returnValue = !1, !1 } function v(t) { let s = e.$el; "container" !== e.params.mousewheel.eventsTarget && (s = d(e.params.mousewheel.eventsTarget)), s[t]("mouseenter", h), s[t]("mouseleave", m), s[t]("wheel", g) } function w() { return e.params.cssMode ? (e.wrapperEl.removeEventListener("wheel", g), !0) : !e.mousewheel.enabled && (v("on"), e.mousewheel.enabled = !0, !0) } function b() { return e.params.cssMode ? (e.wrapperEl.addEventListener(event, g), !0) : !!e.mousewheel.enabled && (v("off"), e.mousewheel.enabled = !1, !0) } s("init", (() => { !e.params.mousewheel.enabled && e.params.cssMode && b(), e.params.mousewheel.enabled && w() })), s("destroy", (() => { e.params.cssMode && w(), e.mousewheel.enabled && b() })), Object.assign(e.mousewheel, { enable: w, disable: b }) }, function ({ swiper: e, extendParams: t, on: s, emit: a }) { function i(t) { let s; return t && (s = d(t), e.params.uniqueNavElements && "string" == typeof t && s.length > 1 && 1 === e.$el.find(t).length && (s = e.$el.find(t))), s } function r(t, s) { const a = e.params.navigation; t && t.length > 0 && (t[s ? "addClass" : "removeClass"](a.disabledClass), t[0] && "BUTTON" === t[0].tagName && (t[0].disabled = s), e.params.watchOverflow && e.enabled && t[e.isLocked ? "addClass" : "removeClass"](a.lockClass)) } function n() { if (e.params.loop) return; const { $nextEl: t, $prevEl: s } = e.navigation; r(s, e.isBeginning && !e.params.rewind), r(t, e.isEnd && !e.params.rewind) } function l(t) { t.preventDefault(), (!e.isBeginning || e.params.loop || e.params.rewind) && e.slidePrev() } function o(t) { t.preventDefault(), (!e.isEnd || e.params.loop || e.params.rewind) && e.slideNext() } function p() { const t = e.params.navigation; if (e.params.navigation = Y(e, e.originalParams.navigation, e.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !t.nextEl && !t.prevEl) return; const s = i(t.nextEl), a = i(t.prevEl); s && s.length > 0 && s.on("click", o), a && a.length > 0 && a.on("click", l), Object.assign(e.navigation, { $nextEl: s, nextEl: s && s[0], $prevEl: a, prevEl: a && a[0] }), e.enabled || (s && s.addClass(t.lockClass), a && a.addClass(t.lockClass)) } function c() { const { $nextEl: t, $prevEl: s } = e.navigation; t && t.length && (t.off("click", o), t.removeClass(e.params.navigation.disabledClass)), s && s.length && (s.off("click", l), s.removeClass(e.params.navigation.disabledClass)) } t({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock" } }), e.navigation = { nextEl: null, $nextEl: null, prevEl: null, $prevEl: null }, s("init", (() => { p(), n() })), s("toEdge fromEdge lock unlock", (() => { n() })), s("destroy", (() => { c() })), s("enable disable", (() => { const { $nextEl: t, $prevEl: s } = e.navigation; t && t[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass), s && s[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass) })), s("click", ((t, s) => { const { $nextEl: i, $prevEl: r } = e.navigation, n = s.target; if (e.params.navigation.hideOnClick && !d(n).is(r) && !d(n).is(i)) { if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === n || e.pagination.el.contains(n))) return; let t; i ? t = i.hasClass(e.params.navigation.hiddenClass) : r && (t = r.hasClass(e.params.navigation.hiddenClass)), a(!0 === t ? "navigationShow" : "navigationHide"), i && i.toggleClass(e.params.navigation.hiddenClass), r && r.toggleClass(e.params.navigation.hiddenClass) } })), Object.assign(e.navigation, { update: n, init: p, destroy: c }) }, function ({ swiper: e, extendParams: t, on: s, emit: a }) { const i = "swiper-pagination"; let r; t({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: e => e, formatFractionTotal: e => e, bulletClass: `${i}-bullet`, bulletActiveClass: `${i}-bullet-active`, modifierClass: `${i}-`, currentClass: `${i}-current`, totalClass: `${i}-total`, hiddenClass: `${i}-hidden`, progressbarFillClass: `${i}-progressbar-fill`, progressbarOppositeClass: `${i}-progressbar-opposite`, clickableClass: `${i}-clickable`, lockClass: `${i}-lock`, horizontalClass: `${i}-horizontal`, verticalClass: `${i}-vertical` } }), e.pagination = { el: null, $el: null, bullets: [] }; let n = 0; function l() { return !e.params.pagination.el || !e.pagination.el || !e.pagination.$el || 0 === e.pagination.$el.length } function o(t, s) { const { bulletActiveClass: a } = e.params.pagination; t[s]().addClass(`${a}-${s}`)[s]().addClass(`${a}-${s}-${s}`) } function p() { const t = e.rtl, s = e.params.pagination; if (l()) return; const i = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, p = e.pagination.$el; let c; const u = e.params.loop ? Math.ceil((i - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length; if (e.params.loop ? (c = Math.ceil((e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup), c > i - 1 - 2 * e.loopedSlides && (c -= i - 2 * e.loopedSlides), c > u - 1 && (c -= u), c < 0 && "bullets" !== e.params.paginationType && (c = u + c)) : c = void 0 !== e.snapIndex ? e.snapIndex : e.activeIndex || 0, "bullets" === s.type && e.pagination.bullets && e.pagination.bullets.length > 0) { const a = e.pagination.bullets; let i, l, u; if (s.dynamicBullets && (r = a.eq(0)[e.isHorizontal() ? "outerWidth" : "outerHeight"](!0), p.css(e.isHorizontal() ? "width" : "height", r * (s.dynamicMainBullets + 4) + "px"), s.dynamicMainBullets > 1 && void 0 !== e.previousIndex && (n += c - (e.previousIndex - e.loopedSlides || 0), n > s.dynamicMainBullets - 1 ? n = s.dynamicMainBullets - 1 : n < 0 && (n = 0)), i = Math.max(c - n, 0), l = i + (Math.min(a.length, s.dynamicMainBullets) - 1), u = (l + i) / 2), a.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => `${s.bulletActiveClass}${e}`)).join(" ")), p.length > 1) a.each((e => { const t = d(e), a = t.index(); a === c && t.addClass(s.bulletActiveClass), s.dynamicBullets && (a >= i && a <= l && t.addClass(`${s.bulletActiveClass}-main`), a === i && o(t, "prev"), a === l && o(t, "next")) })); else { const t = a.eq(c), r = t.index(); if (t.addClass(s.bulletActiveClass), s.dynamicBullets) { const t = a.eq(i), n = a.eq(l); for (let e = i; e <= l; e += 1)a.eq(e).addClass(`${s.bulletActiveClass}-main`); if (e.params.loop) if (r >= a.length) { for (let e = s.dynamicMainBullets; e >= 0; e -= 1)a.eq(a.length - e).addClass(`${s.bulletActiveClass}-main`); a.eq(a.length - s.dynamicMainBullets - 1).addClass(`${s.bulletActiveClass}-prev`) } else o(t, "prev"), o(n, "next"); else o(t, "prev"), o(n, "next") } } if (s.dynamicBullets) { const i = Math.min(a.length, s.dynamicMainBullets + 4), n = (r * i - r) / 2 - u * r, l = t ? "right" : "left"; a.css(e.isHorizontal() ? l : "top", `${n}px`) } } if ("fraction" === s.type && (p.find(W(s.currentClass)).text(s.formatFractionCurrent(c + 1)), p.find(W(s.totalClass)).text(s.formatFractionTotal(u))), "progressbar" === s.type) { let t; t = s.progressbarOpposite ? e.isHorizontal() ? "vertical" : "horizontal" : e.isHorizontal() ? "horizontal" : "vertical"; const a = (c + 1) / u; let i = 1, r = 1; "horizontal" === t ? i = a : r = a, p.find(W(s.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${i}) scaleY(${r})`).transition(e.params.speed) } "custom" === s.type && s.renderCustom ? (p.html(s.renderCustom(e, c + 1, u)), a("paginationRender", p[0])) : a("paginationUpdate", p[0]), e.params.watchOverflow && e.enabled && p[e.isLocked ? "addClass" : "removeClass"](s.lockClass) } function c() { const t = e.params.pagination; if (l()) return; const s = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, i = e.pagination.$el; let r = ""; if ("bullets" === t.type) { let a = e.params.loop ? Math.ceil((s - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length; e.params.freeMode && e.params.freeMode.enabled && !e.params.loop && a > s && (a = s); for (let s = 0; s < a; s += 1)t.renderBullet ? r += t.renderBullet.call(e, s, t.bulletClass) : r += `<${t.bulletElement} class="${t.bulletClass}"></${t.bulletElement}>`; i.html(r), e.pagination.bullets = i.find(W(t.bulletClass)) } "fraction" === t.type && (r = t.renderFraction ? t.renderFraction.call(e, t.currentClass, t.totalClass) : `<span class="${t.currentClass}"></span> / <span class="${t.totalClass}"></span>`, i.html(r)), "progressbar" === t.type && (r = t.renderProgressbar ? t.renderProgressbar.call(e, t.progressbarFillClass) : `<span class="${t.progressbarFillClass}"></span>`, i.html(r)), "custom" !== t.type && a("paginationRender", e.pagination.$el[0]) } function u() { e.params.pagination = Y(e, e.originalParams.pagination, e.params.pagination, { el: "swiper-pagination" }); const t = e.params.pagination; if (!t.el) return; let s = d(t.el); 0 !== s.length && (e.params.uniqueNavElements && "string" == typeof t.el && s.length > 1 && (s = e.$el.find(t.el), s.length > 1 && (s = s.filter((t => d(t).parents(".swiper")[0] === e.el)))), "bullets" === t.type && t.clickable && s.addClass(t.clickableClass), s.addClass(t.modifierClass + t.type), s.addClass(t.modifierClass + e.params.direction), "bullets" === t.type && t.dynamicBullets && (s.addClass(`${t.modifierClass}${t.type}-dynamic`), n = 0, t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)), "progressbar" === t.type && t.progressbarOpposite && s.addClass(t.progressbarOppositeClass), t.clickable && s.on("click", W(t.bulletClass), (function (t) { t.preventDefault(); let s = d(this).index() * e.params.slidesPerGroup; e.params.loop && (s += e.loopedSlides), e.slideTo(s) })), Object.assign(e.pagination, { $el: s, el: s[0] }), e.enabled || s.addClass(t.lockClass)) } function h() { const t = e.params.pagination; if (l()) return; const s = e.pagination.$el; s.removeClass(t.hiddenClass), s.removeClass(t.modifierClass + t.type), s.removeClass(t.modifierClass + e.params.direction), e.pagination.bullets && e.pagination.bullets.removeClass && e.pagination.bullets.removeClass(t.bulletActiveClass), t.clickable && s.off("click", W(t.bulletClass)) } s("init", (() => { u(), c(), p() })), s("activeIndexChange", (() => { (e.params.loop || void 0 === e.snapIndex) && p() })), s("snapIndexChange", (() => { e.params.loop || p() })), s("slidesLengthChange", (() => { e.params.loop && (c(), p()) })), s("snapGridLengthChange", (() => { e.params.loop || (c(), p()) })), s("destroy", (() => { h() })), s("enable disable", (() => { const { $el: t } = e.pagination; t && t[e.enabled ? "removeClass" : "addClass"](e.params.pagination.lockClass) })), s("lock unlock", (() => { p() })), s("click", ((t, s) => { const i = s.target, { $el: r } = e.pagination; if (e.params.pagination.el && e.params.pagination.hideOnClick && r.length > 0 && !d(i).hasClass(e.params.pagination.bulletClass)) { if (e.navigation && (e.navigation.nextEl && i === e.navigation.nextEl || e.navigation.prevEl && i === e.navigation.prevEl)) return; const t = r.hasClass(e.params.pagination.hiddenClass); a(!0 === t ? "paginationShow" : "paginationHide"), r.toggleClass(e.params.pagination.hiddenClass) } })), Object.assign(e.pagination, { render: c, update: p, init: u, destroy: h }) }, function ({ swiper: e, extendParams: t, on: s, emit: i }) { const r = a(); let n, l, o, p, u = !1, h = null, m = null; function f() { if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: t, rtlTranslate: s, progress: a } = e, { $dragEl: i, $el: r } = t, n = e.params.scrollbar; let d = l, p = (o - l) * a; s ? (p = -p, p > 0 ? (d = l - p, p = 0) : -p + l > o && (d = o + p)) : p < 0 ? (d = l + p, p = 0) : p + l > o && (d = o - p), e.isHorizontal() ? (i.transform(`translate3d(${p}px, 0, 0)`), i[0].style.width = `${d}px`) : (i.transform(`translate3d(0px, ${p}px, 0)`), i[0].style.height = `${d}px`), n.hide && (clearTimeout(h), r[0].style.opacity = 1, h = setTimeout((() => { r[0].style.opacity = 0, r.transition(400) }), 1e3)) } function g() { if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: t } = e, { $dragEl: s, $el: a } = t; s[0].style.width = "", s[0].style.height = "", o = e.isHorizontal() ? a[0].offsetWidth : a[0].offsetHeight, p = e.size / (e.virtualSize + e.params.slidesOffsetBefore - (e.params.centeredSlides ? e.snapGrid[0] : 0)), l = "auto" === e.params.scrollbar.dragSize ? o * p : parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? s[0].style.width = `${l}px` : s[0].style.height = `${l}px`, a[0].style.display = p >= 1 ? "none" : "", e.params.scrollbar.hide && (a[0].style.opacity = 0), e.params.watchOverflow && e.enabled && t.$el[e.isLocked ? "addClass" : "removeClass"](e.params.scrollbar.lockClass) } function v(t) { return e.isHorizontal() ? "touchstart" === t.type || "touchmove" === t.type ? t.targetTouches[0].clientX : t.clientX : "touchstart" === t.type || "touchmove" === t.type ? t.targetTouches[0].clientY : t.clientY } function w(t) { const { scrollbar: s, rtlTranslate: a } = e, { $el: i } = s; let r; r = (v(t) - i.offset()[e.isHorizontal() ? "left" : "top"] - (null !== n ? n : l / 2)) / (o - l), r = Math.max(Math.min(r, 1), 0), a && (r = 1 - r); const d = e.minTranslate() + (e.maxTranslate() - e.minTranslate()) * r; e.updateProgress(d), e.setTranslate(d), e.updateActiveIndex(), e.updateSlidesClasses() } function b(t) { const s = e.params.scrollbar, { scrollbar: a, $wrapperEl: r } = e, { $el: l, $dragEl: o } = a; u = !0, n = t.target === o[0] || t.target === o ? v(t) - t.target.getBoundingClientRect()[e.isHorizontal() ? "left" : "top"] : null, t.preventDefault(), t.stopPropagation(), r.transition(100), o.transition(100), w(t), clearTimeout(m), l.transition(0), s.hide && l.css("opacity", 1), e.params.cssMode && e.$wrapperEl.css("scroll-snap-type", "none"), i("scrollbarDragStart", t) } function x(t) { const { scrollbar: s, $wrapperEl: a } = e, { $el: r, $dragEl: n } = s; u && (t.preventDefault ? t.preventDefault() : t.returnValue = !1, w(t), a.transition(0), r.transition(0), n.transition(0), i("scrollbarDragMove", t)) } function y(t) { const s = e.params.scrollbar, { scrollbar: a, $wrapperEl: r } = e, { $el: n } = a; u && (u = !1, e.params.cssMode && (e.$wrapperEl.css("scroll-snap-type", ""), r.transition("")), s.hide && (clearTimeout(m), m = c((() => { n.css("opacity", 0), n.transition(400) }), 1e3)), i("scrollbarDragEnd", t), s.snapOnRelease && e.slideToClosest()) } function E(t) { const { scrollbar: s, touchEventsTouch: a, touchEventsDesktop: i, params: n, support: l } = e, o = s.$el[0], d = !(!l.passiveListener || !n.passiveListeners) && { passive: !1, capture: !1 }, p = !(!l.passiveListener || !n.passiveListeners) && { passive: !0, capture: !1 }; if (!o) return; const c = "on" === t ? "addEventListener" : "removeEventListener"; l.touch ? (o[c](a.start, b, d), o[c](a.move, x, d), o[c](a.end, y, p)) : (o[c](i.start, b, d), r[c](i.move, x, d), r[c](i.end, y, p)) } function T() { const { scrollbar: t, $el: s } = e; e.params.scrollbar = Y(e, e.originalParams.scrollbar, e.params.scrollbar, { el: "swiper-scrollbar" }); const a = e.params.scrollbar; if (!a.el) return; let i = d(a.el); e.params.uniqueNavElements && "string" == typeof a.el && i.length > 1 && 1 === s.find(a.el).length && (i = s.find(a.el)); let r = i.find(`.${e.params.scrollbar.dragClass}`); 0 === r.length && (r = d(`<div class="${e.params.scrollbar.dragClass}"></div>`), i.append(r)), Object.assign(t, { $el: i, el: i[0], $dragEl: r, dragEl: r[0] }), a.draggable && e.params.scrollbar.el && E("on"), i && i[e.enabled ? "removeClass" : "addClass"](e.params.scrollbar.lockClass) } function C() { e.params.scrollbar.el && E("off") } t({ scrollbar: { el: null, dragSize: "auto", hide: !1, draggable: !1, snapOnRelease: !0, lockClass: "swiper-scrollbar-lock", dragClass: "swiper-scrollbar-drag" } }), e.scrollbar = { el: null, dragEl: null, $el: null, $dragEl: null }, s("init", (() => { T(), g(), f() })), s("update resize observerUpdate lock unlock", (() => { g() })), s("setTranslate", (() => { f() })), s("setTransition", ((t, s) => { !function (t) { e.params.scrollbar.el && e.scrollbar.el && e.scrollbar.$dragEl.transition(t) }(s) })), s("enable disable", (() => { const { $el: t } = e.scrollbar; t && t[e.enabled ? "removeClass" : "addClass"](e.params.scrollbar.lockClass) })), s("destroy", (() => { C() })), Object.assign(e.scrollbar, { updateSize: g, setTranslate: f, init: T, destroy: C }) }, function ({ swiper: e, extendParams: t, on: s }) { t({ parallax: { enabled: !1 } }); const a = (t, s) => { const { rtl: a } = e, i = d(t), r = a ? -1 : 1, n = i.attr("data-swiper-parallax") || "0"; let l = i.attr("data-swiper-parallax-x"), o = i.attr("data-swiper-parallax-y"); const p = i.attr("data-swiper-parallax-scale"), c = i.attr("data-swiper-parallax-opacity"); if (l || o ? (l = l || "0", o = o || "0") : e.isHorizontal() ? (l = n, o = "0") : (o = n, l = "0"), l = l.indexOf("%") >= 0 ? parseInt(l, 10) * s * r + "%" : l * s * r + "px", o = o.indexOf("%") >= 0 ? parseInt(o, 10) * s + "%" : o * s + "px", null != c) { const e = c - (c - 1) * (1 - Math.abs(s)); i[0].style.opacity = e } if (null == p) i.transform(`translate3d(${l}, ${o}, 0px)`); else { const e = p - (p - 1) * (1 - Math.abs(s)); i.transform(`translate3d(${l}, ${o}, 0px) scale(${e})`) } }, i = () => { const { $el: t, slides: s, progress: i, snapGrid: r } = e; t.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e => { a(e, i) })), s.each(((t, s) => { let n = t.progress; e.params.slidesPerGroup > 1 && "auto" !== e.params.slidesPerView && (n += Math.ceil(s / 2) - i * (r.length - 1)), n = Math.min(Math.max(n, -1), 1), d(t).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e => { a(e, n) })) })) }; s("beforeInit", (() => { e.params.parallax.enabled && (e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0) })), s("init", (() => { e.params.parallax.enabled && i() })), s("setTranslate", (() => { e.params.parallax.enabled && i() })), s("setTransition", ((t, s) => { e.params.parallax.enabled && ((t = e.params.speed) => { const { $el: s } = e; s.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e => { const s = d(e); let a = parseInt(s.attr("data-swiper-parallax-duration"), 10) || t; 0 === t && (a = 0), s.transition(a) })) })(s) })) }, function ({ swiper: e, extendParams: t, on: s, emit: a }) { const i = r(); t({ zoom: { enabled: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: "swiper-zoom-container", zoomedSlideClass: "swiper-slide-zoomed" } }), e.zoom = { enabled: !1 }; let n, l, o, p = 1, c = !1; const u = { $slideEl: void 0, slideWidth: void 0, slideHeight: void 0, $imageEl: void 0, $imageWrapEl: void 0, maxRatio: 3 }, m = { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} }, f = { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 }; let g = 1; function v(e) { if (e.targetTouches.length < 2) return 1; const t = e.targetTouches[0].pageX, s = e.targetTouches[0].pageY, a = e.targetTouches[1].pageX, i = e.targetTouches[1].pageY; return Math.sqrt((a - t) ** 2 + (i - s) ** 2) } function w(t) { const s = e.support, a = e.params.zoom; if (l = !1, o = !1, !s.gestures) { if ("touchstart" !== t.type || "touchstart" === t.type && t.targetTouches.length < 2) return; l = !0, u.scaleStart = v(t) } u.$slideEl && u.$slideEl.length || (u.$slideEl = d(t.target).closest(`.${e.params.slideClass}`), 0 === u.$slideEl.length && (u.$slideEl = e.slides.eq(e.activeIndex)), u.$imageEl = u.$slideEl.find(`.${a.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), u.$imageWrapEl = u.$imageEl.parent(`.${a.containerClass}`), u.maxRatio = u.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, 0 !== u.$imageWrapEl.length) ? (u.$imageEl && u.$imageEl.transition(0), c = !0) : u.$imageEl = void 0 } function b(t) { const s = e.support, a = e.params.zoom, i = e.zoom; if (!s.gestures) { if ("touchmove" !== t.type || "touchmove" === t.type && t.targetTouches.length < 2) return; o = !0, u.scaleMove = v(t) } u.$imageEl && 0 !== u.$imageEl.length ? (s.gestures ? i.scale = t.scale * p : i.scale = u.scaleMove / u.scaleStart * p, i.scale > u.maxRatio && (i.scale = u.maxRatio - 1 + (i.scale - u.maxRatio + 1) ** .5), i.scale < a.minRatio && (i.scale = a.minRatio + 1 - (a.minRatio - i.scale + 1) ** .5), u.$imageEl.transform(`translate3d(0,0,0) scale(${i.scale})`)) : "gesturechange" === t.type && w(t) } function x(t) { const s = e.device, a = e.support, i = e.params.zoom, r = e.zoom; if (!a.gestures) { if (!l || !o) return; if ("touchend" !== t.type || "touchend" === t.type && t.changedTouches.length < 2 && !s.android) return; l = !1, o = !1 } u.$imageEl && 0 !== u.$imageEl.length && (r.scale = Math.max(Math.min(r.scale, u.maxRatio), i.minRatio), u.$imageEl.transition(e.params.speed).transform(`translate3d(0,0,0) scale(${r.scale})`), p = r.scale, c = !1, 1 === r.scale && (u.$slideEl = void 0)) } function y(t) { const s = e.zoom; if (!u.$imageEl || 0 === u.$imageEl.length) return; if (e.allowClick = !1, !m.isTouched || !u.$slideEl) return; m.isMoved || (m.width = u.$imageEl[0].offsetWidth, m.height = u.$imageEl[0].offsetHeight, m.startX = h(u.$imageWrapEl[0], "x") || 0, m.startY = h(u.$imageWrapEl[0], "y") || 0, u.slideWidth = u.$slideEl[0].offsetWidth, u.slideHeight = u.$slideEl[0].offsetHeight, u.$imageWrapEl.transition(0)); const a = m.width * s.scale, i = m.height * s.scale; if (!(a < u.slideWidth && i < u.slideHeight)) { if (m.minX = Math.min(u.slideWidth / 2 - a / 2, 0), m.maxX = -m.minX, m.minY = Math.min(u.slideHeight / 2 - i / 2, 0), m.maxY = -m.minY, m.touchesCurrent.x = "touchmove" === t.type ? t.targetTouches[0].pageX : t.pageX, m.touchesCurrent.y = "touchmove" === t.type ? t.targetTouches[0].pageY : t.pageY, !m.isMoved && !c) { if (e.isHorizontal() && (Math.floor(m.minX) === Math.floor(m.startX) && m.touchesCurrent.x < m.touchesStart.x || Math.floor(m.maxX) === Math.floor(m.startX) && m.touchesCurrent.x > m.touchesStart.x)) return void (m.isTouched = !1); if (!e.isHorizontal() && (Math.floor(m.minY) === Math.floor(m.startY) && m.touchesCurrent.y < m.touchesStart.y || Math.floor(m.maxY) === Math.floor(m.startY) && m.touchesCurrent.y > m.touchesStart.y)) return void (m.isTouched = !1) } t.cancelable && t.preventDefault(), t.stopPropagation(), m.isMoved = !0, m.currentX = m.touchesCurrent.x - m.touchesStart.x + m.startX, m.currentY = m.touchesCurrent.y - m.touchesStart.y + m.startY, m.currentX < m.minX && (m.currentX = m.minX + 1 - (m.minX - m.currentX + 1) ** .8), m.currentX > m.maxX && (m.currentX = m.maxX - 1 + (m.currentX - m.maxX + 1) ** .8), m.currentY < m.minY && (m.currentY = m.minY + 1 - (m.minY - m.currentY + 1) ** .8), m.currentY > m.maxY && (m.currentY = m.maxY - 1 + (m.currentY - m.maxY + 1) ** .8), f.prevPositionX || (f.prevPositionX = m.touchesCurrent.x), f.prevPositionY || (f.prevPositionY = m.touchesCurrent.y), f.prevTime || (f.prevTime = Date.now()), f.x = (m.touchesCurrent.x - f.prevPositionX) / (Date.now() - f.prevTime) / 2, f.y = (m.touchesCurrent.y - f.prevPositionY) / (Date.now() - f.prevTime) / 2, Math.abs(m.touchesCurrent.x - f.prevPositionX) < 2 && (f.x = 0), Math.abs(m.touchesCurrent.y - f.prevPositionY) < 2 && (f.y = 0), f.prevPositionX = m.touchesCurrent.x, f.prevPositionY = m.touchesCurrent.y, f.prevTime = Date.now(), u.$imageWrapEl.transform(`translate3d(${m.currentX}px, ${m.currentY}px,0)`) } } function E() { const t = e.zoom; u.$slideEl && e.previousIndex !== e.activeIndex && (u.$imageEl && u.$imageEl.transform("translate3d(0,0,0) scale(1)"), u.$imageWrapEl && u.$imageWrapEl.transform("translate3d(0,0,0)"), t.scale = 1, p = 1, u.$slideEl = void 0, u.$imageEl = void 0, u.$imageWrapEl = void 0) } function T(t) { const s = e.zoom, a = e.params.zoom; if (u.$slideEl || (t && t.target && (u.$slideEl = d(t.target).closest(`.${e.params.slideClass}`)), u.$slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? u.$slideEl = e.$wrapperEl.children(`.${e.params.slideActiveClass}`) : u.$slideEl = e.slides.eq(e.activeIndex)), u.$imageEl = u.$slideEl.find(`.${a.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), u.$imageWrapEl = u.$imageEl.parent(`.${a.containerClass}`)), !u.$imageEl || 0 === u.$imageEl.length || !u.$imageWrapEl || 0 === u.$imageWrapEl.length) return; let r, n, l, o, c, h, f, g, v, w, b, x, y, E, T, C, $, S; e.params.cssMode && (e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.touchAction = "none"), u.$slideEl.addClass(`${a.zoomedSlideClass}`), void 0 === m.touchesStart.x && t ? (r = "touchend" === t.type ? t.changedTouches[0].pageX : t.pageX, n = "touchend" === t.type ? t.changedTouches[0].pageY : t.pageY) : (r = m.touchesStart.x, n = m.touchesStart.y), s.scale = u.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, p = u.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, t ? ($ = u.$slideEl[0].offsetWidth, S = u.$slideEl[0].offsetHeight, l = u.$slideEl.offset().left + i.scrollX, o = u.$slideEl.offset().top + i.scrollY, c = l + $ / 2 - r, h = o + S / 2 - n, v = u.$imageEl[0].offsetWidth, w = u.$imageEl[0].offsetHeight, b = v * s.scale, x = w * s.scale, y = Math.min($ / 2 - b / 2, 0), E = Math.min(S / 2 - x / 2, 0), T = -y, C = -E, f = c * s.scale, g = h * s.scale, f < y && (f = y), f > T && (f = T), g < E && (g = E), g > C && (g = C)) : (f = 0, g = 0), u.$imageWrapEl.transition(300).transform(`translate3d(${f}px, ${g}px,0)`), u.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${s.scale})`) } function C() { const t = e.zoom, s = e.params.zoom; u.$slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? u.$slideEl = e.$wrapperEl.children(`.${e.params.slideActiveClass}`) : u.$slideEl = e.slides.eq(e.activeIndex), u.$imageEl = u.$slideEl.find(`.${s.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), u.$imageWrapEl = u.$imageEl.parent(`.${s.containerClass}`)), u.$imageEl && 0 !== u.$imageEl.length && u.$imageWrapEl && 0 !== u.$imageWrapEl.length && (e.params.cssMode && (e.wrapperEl.style.overflow = "", e.wrapperEl.style.touchAction = ""), t.scale = 1, p = 1, u.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), u.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), u.$slideEl.removeClass(`${s.zoomedSlideClass}`), u.$slideEl = void 0) } function $(t) { const s = e.zoom; s.scale && 1 !== s.scale ? C() : T(t) } function S() { const t = e.support; return { passiveListener: !("touchstart" !== e.touchEvents.start || !t.passiveListener || !e.params.passiveListeners) && { passive: !0, capture: !1 }, activeListenerWithCapture: !t.passiveListener || { passive: !1, capture: !0 } } } function M() { return `.${e.params.slideClass}` } function P(t) { const { passiveListener: s } = S(), a = M(); e.$wrapperEl[t]("gesturestart", a, w, s), e.$wrapperEl[t]("gesturechange", a, b, s), e.$wrapperEl[t]("gestureend", a, x, s) } function k() { n || (n = !0, P("on")) } function z() { n && (n = !1, P("off")) } function O() { const t = e.zoom; if (t.enabled) return; t.enabled = !0; const s = e.support, { passiveListener: a, activeListenerWithCapture: i } = S(), r = M(); s.gestures ? (e.$wrapperEl.on(e.touchEvents.start, k, a), e.$wrapperEl.on(e.touchEvents.end, z, a)) : "touchstart" === e.touchEvents.start && (e.$wrapperEl.on(e.touchEvents.start, r, w, a), e.$wrapperEl.on(e.touchEvents.move, r, b, i), e.$wrapperEl.on(e.touchEvents.end, r, x, a), e.touchEvents.cancel && e.$wrapperEl.on(e.touchEvents.cancel, r, x, a)), e.$wrapperEl.on(e.touchEvents.move, `.${e.params.zoom.containerClass}`, y, i) } function I() { const t = e.zoom; if (!t.enabled) return; const s = e.support; t.enabled = !1; const { passiveListener: a, activeListenerWithCapture: i } = S(), r = M(); s.gestures ? (e.$wrapperEl.off(e.touchEvents.start, k, a), e.$wrapperEl.off(e.touchEvents.end, z, a)) : "touchstart" === e.touchEvents.start && (e.$wrapperEl.off(e.touchEvents.start, r, w, a), e.$wrapperEl.off(e.touchEvents.move, r, b, i), e.$wrapperEl.off(e.touchEvents.end, r, x, a), e.touchEvents.cancel && e.$wrapperEl.off(e.touchEvents.cancel, r, x, a)), e.$wrapperEl.off(e.touchEvents.move, `.${e.params.zoom.containerClass}`, y, i) } Object.defineProperty(e.zoom, "scale", { get: () => g, set(e) { if (g !== e) { const t = u.$imageEl ? u.$imageEl[0] : void 0, s = u.$slideEl ? u.$slideEl[0] : void 0; a("zoomChange", e, t, s) } g = e } }), s("init", (() => { e.params.zoom.enabled && O() })), s("destroy", (() => { I() })), s("touchStart", ((t, s) => { e.zoom.enabled && function (t) { const s = e.device; u.$imageEl && 0 !== u.$imageEl.length && (m.isTouched || (s.android && t.cancelable && t.preventDefault(), m.isTouched = !0, m.touchesStart.x = "touchstart" === t.type ? t.targetTouches[0].pageX : t.pageX, m.touchesStart.y = "touchstart" === t.type ? t.targetTouches[0].pageY : t.pageY)) }(s) })), s("touchEnd", ((t, s) => { e.zoom.enabled && function () { const t = e.zoom; if (!u.$imageEl || 0 === u.$imageEl.length) return; if (!m.isTouched || !m.isMoved) return m.isTouched = !1, void (m.isMoved = !1); m.isTouched = !1, m.isMoved = !1; let s = 300, a = 300; const i = f.x * s, r = m.currentX + i, n = f.y * a, l = m.currentY + n; 0 !== f.x && (s = Math.abs((r - m.currentX) / f.x)), 0 !== f.y && (a = Math.abs((l - m.currentY) / f.y)); const o = Math.max(s, a); m.currentX = r, m.currentY = l; const d = m.width * t.scale, p = m.height * t.scale; m.minX = Math.min(u.slideWidth / 2 - d / 2, 0), m.maxX = -m.minX, m.minY = Math.min(u.slideHeight / 2 - p / 2, 0), m.maxY = -m.minY, m.currentX = Math.max(Math.min(m.currentX, m.maxX), m.minX), m.currentY = Math.max(Math.min(m.currentY, m.maxY), m.minY), u.$imageWrapEl.transition(o).transform(`translate3d(${m.currentX}px, ${m.currentY}px,0)`) }() })), s("doubleTap", ((t, s) => { !e.animating && e.params.zoom.enabled && e.zoom.enabled && e.params.zoom.toggle && $(s) })), s("transitionEnd", (() => { e.zoom.enabled && e.params.zoom.enabled && E() })), s("slideChange", (() => { e.zoom.enabled && e.params.zoom.enabled && e.params.cssMode && E() })), Object.assign(e.zoom, { enable: O, disable: I, in: T, out: C, toggle: $ }) }, function ({ swiper: e, extendParams: t, on: s, emit: a }) { t({ lazy: { checkInView: !1, enabled: !1, loadPrevNext: !1, loadPrevNextAmount: 1, loadOnTransitionStart: !1, scrollingElement: "", elementClass: "swiper-lazy", loadingClass: "swiper-lazy-loading", loadedClass: "swiper-lazy-loaded", preloaderClass: "swiper-lazy-preloader" } }), e.lazy = {}; let i = !1, n = !1; function l(t, s = !0) { const i = e.params.lazy; if (void 0 === t) return; if (0 === e.slides.length) return; const r = e.virtual && e.params.virtual.enabled ? e.$wrapperEl.children(`.${e.params.slideClass}[data-swiper-slide-index="${t}"]`) : e.slides.eq(t), n = r.find(`.${i.elementClass}:not(.${i.loadedClass}):not(.${i.loadingClass})`); !r.hasClass(i.elementClass) || r.hasClass(i.loadedClass) || r.hasClass(i.loadingClass) || n.push(r[0]), 0 !== n.length && n.each((t => { const n = d(t); n.addClass(i.loadingClass); const o = n.attr("data-background"), p = n.attr("data-src"), c = n.attr("data-srcset"), u = n.attr("data-sizes"), h = n.parent("picture"); e.loadImage(n[0], p || o, c, u, !1, (() => { if (null != e && e && (!e || e.params) && !e.destroyed) { if (o ? (n.css("background-image", `url("${o}")`), n.removeAttr("data-background")) : (c && (n.attr("srcset", c), n.removeAttr("data-srcset")), u && (n.attr("sizes", u), n.removeAttr("data-sizes")), h.length && h.children("source").each((e => { const t = d(e); t.attr("data-srcset") && (t.attr("srcset", t.attr("data-srcset")), t.removeAttr("data-srcset")) })), p && (n.attr("src", p), n.removeAttr("data-src"))), n.addClass(i.loadedClass).removeClass(i.loadingClass), r.find(`.${i.preloaderClass}`).remove(), e.params.loop && s) { const t = r.attr("data-swiper-slide-index"); if (r.hasClass(e.params.slideDuplicateClass)) { l(e.$wrapperEl.children(`[data-swiper-slide-index="${t}"]:not(.${e.params.slideDuplicateClass})`).index(), !1) } else { l(e.$wrapperEl.children(`.${e.params.slideDuplicateClass}[data-swiper-slide-index="${t}"]`).index(), !1) } } a("lazyImageReady", r[0], n[0]), e.params.autoHeight && e.updateAutoHeight() } })), a("lazyImageLoad", r[0], n[0]) })) } function o() { const { $wrapperEl: t, params: s, slides: a, activeIndex: i } = e, r = e.virtual && s.virtual.enabled, o = s.lazy; let p = s.slidesPerView; function c(e) { if (r) { if (t.children(`.${s.slideClass}[data-swiper-slide-index="${e}"]`).length) return !0 } else if (a[e]) return !0; return !1 } function u(e) { return r ? d(e).attr("data-swiper-slide-index") : d(e).index() } if ("auto" === p && (p = 0), n || (n = !0), e.params.watchSlidesProgress) t.children(`.${s.slideVisibleClass}`).each((e => { l(r ? d(e).attr("data-swiper-slide-index") : d(e).index()) })); else if (p > 1) for (let e = i; e < i + p; e += 1)c(e) && l(e); else l(i); if (o.loadPrevNext) if (p > 1 || o.loadPrevNextAmount && o.loadPrevNextAmount > 1) { const e = o.loadPrevNextAmount, t = p, s = Math.min(i + t + Math.max(e, t), a.length), r = Math.max(i - Math.max(t, e), 0); for (let e = i + p; e < s; e += 1)c(e) && l(e); for (let e = r; e < i; e += 1)c(e) && l(e) } else { const e = t.children(`.${s.slideNextClass}`); e.length > 0 && l(u(e)); const a = t.children(`.${s.slidePrevClass}`); a.length > 0 && l(u(a)) } } function p() { const t = r(); if (!e || e.destroyed) return; const s = e.params.lazy.scrollingElement ? d(e.params.lazy.scrollingElement) : d(t), a = s[0] === t, n = a ? t.innerWidth : s[0].offsetWidth, l = a ? t.innerHeight : s[0].offsetHeight, c = e.$el.offset(), { rtlTranslate: u } = e; let h = !1; u && (c.left -= e.$el[0].scrollLeft); const m = [[c.left, c.top], [c.left + e.width, c.top], [c.left, c.top + e.height], [c.left + e.width, c.top + e.height]]; for (let e = 0; e < m.length; e += 1) { const t = m[e]; if (t[0] >= 0 && t[0] <= n && t[1] >= 0 && t[1] <= l) { if (0 === t[0] && 0 === t[1]) continue; h = !0 } } const f = !("touchstart" !== e.touchEvents.start || !e.support.passiveListener || !e.params.passiveListeners) && { passive: !0, capture: !1 }; h ? (o(), s.off("scroll", p, f)) : i || (i = !0, s.on("scroll", p, f)) } s("beforeInit", (() => { e.params.lazy.enabled && e.params.preloadImages && (e.params.preloadImages = !1) })), s("init", (() => { e.params.lazy.enabled && (e.params.lazy.checkInView ? p() : o()) })), s("scroll", (() => { e.params.freeMode && e.params.freeMode.enabled && !e.params.freeMode.sticky && o() })), s("scrollbarDragMove resize _freeModeNoMomentumRelease", (() => { e.params.lazy.enabled && (e.params.lazy.checkInView ? p() : o()) })), s("transitionStart", (() => { e.params.lazy.enabled && (e.params.lazy.loadOnTransitionStart || !e.params.lazy.loadOnTransitionStart && !n) && (e.params.lazy.checkInView ? p() : o()) })), s("transitionEnd", (() => { e.params.lazy.enabled && !e.params.lazy.loadOnTransitionStart && (e.params.lazy.checkInView ? p() : o()) })), s("slideChange", (() => { const { lazy: t, cssMode: s, watchSlidesProgress: a, touchReleaseOnEdges: i, resistanceRatio: r } = e.params; t.enabled && (s || a && (i || 0 === r)) && o() })), Object.assign(e.lazy, { load: o, loadInSlide: l }) }, function ({ swiper: e, extendParams: t, on: s }) { function a(e, t) { const s = function () { let e, t, s; return (a, i) => { for (t = -1, e = a.length; e - t > 1;)s = e + t >> 1, a[s] <= i ? t = s : e = s; return e } }(); let a, i; return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) { return e ? (i = s(this.x, e), a = i - 1, (e - this.x[a]) * (this.y[i] - this.y[a]) / (this.x[i] - this.x[a]) + this.y[a]) : 0 }, this } function i() { e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline) } t({ controller: { control: void 0, inverse: !1, by: "slide" } }), e.controller = { control: void 0 }, s("beforeInit", (() => { e.controller.control = e.params.controller.control })), s("update", (() => { i() })), s("resize", (() => { i() })), s("observerUpdate", (() => { i() })), s("setTranslate", ((t, s, a) => { e.controller.control && e.controller.setTranslate(s, a) })), s("setTransition", ((t, s, a) => { e.controller.control && e.controller.setTransition(s, a) })), Object.assign(e.controller, { setTranslate: function (t, s) { const i = e.controller.control; let r, n; const l = e.constructor; function o(t) { const s = e.rtlTranslate ? -e.translate : e.translate; "slide" === e.params.controller.by && (!function (t) { e.controller.spline || (e.controller.spline = e.params.loop ? new a(e.slidesGrid, t.slidesGrid) : new a(e.snapGrid, t.snapGrid)) }(t), n = -e.controller.spline.interpolate(-s)), n && "container" !== e.params.controller.by || (r = (t.maxTranslate() - t.minTranslate()) / (e.maxTranslate() - e.minTranslate()), n = (s - e.minTranslate()) * r + t.minTranslate()), e.params.controller.inverse && (n = t.maxTranslate() - n), t.updateProgress(n), t.setTranslate(n, e), t.updateActiveIndex(), t.updateSlidesClasses() } if (Array.isArray(i)) for (let e = 0; e < i.length; e += 1)i[e] !== s && i[e] instanceof l && o(i[e]); else i instanceof l && s !== i && o(i) }, setTransition: function (t, s) { const a = e.constructor, i = e.controller.control; let r; function n(s) { s.setTransition(t, e), 0 !== t && (s.transitionStart(), s.params.autoHeight && c((() => { s.updateAutoHeight() })), s.$wrapperEl.transitionEnd((() => { i && (s.params.loop && "slide" === e.params.controller.by && s.loopFix(), s.transitionEnd()) }))) } if (Array.isArray(i)) for (r = 0; r < i.length; r += 1)i[r] !== s && i[r] instanceof a && n(i[r]); else i instanceof a && s !== i && n(i) } }) }, function ({ swiper: e, extendParams: t, on: s }) { t({ a11y: { enabled: !0, notificationClass: "swiper-notification", prevSlideMessage: "Previous slide", nextSlideMessage: "Next slide", firstSlideMessage: "This is the first slide", lastSlideMessage: "This is the last slide", paginationBulletMessage: "Go to slide {{index}}", slideLabelMessage: "{{index}} / {{slidesLength}}", containerMessage: null, containerRoleDescriptionMessage: null, itemRoleDescriptionMessage: null, slideRole: "group" } }); let a = null; function i(e) { const t = a; 0 !== t.length && (t.html(""), t.html(e)) } function r(e) { e.attr("tabIndex", "0") } function n(e) { e.attr("tabIndex", "-1") } function l(e, t) { e.attr("role", t) } function o(e, t) { e.attr("aria-roledescription", t) } function p(e, t) { e.attr("aria-label", t) } function c(e) { e.attr("aria-disabled", !0) } function u(e) { e.attr("aria-disabled", !1) } function h(t) { if (13 !== t.keyCode && 32 !== t.keyCode) return; const s = e.params.a11y, a = d(t.target); e.navigation && e.navigation.$nextEl && a.is(e.navigation.$nextEl) && (e.isEnd && !e.params.loop || e.slideNext(), e.isEnd ? i(s.lastSlideMessage) : i(s.nextSlideMessage)), e.navigation && e.navigation.$prevEl && a.is(e.navigation.$prevEl) && (e.isBeginning && !e.params.loop || e.slidePrev(), e.isBeginning ? i(s.firstSlideMessage) : i(s.prevSlideMessage)), e.pagination && a.is(W(e.params.pagination.bulletClass)) && a[0].click() } function m() { if (e.params.loop || e.params.rewind || !e.navigation) return; const { $nextEl: t, $prevEl: s } = e.navigation; s && s.length > 0 && (e.isBeginning ? (c(s), n(s)) : (u(s), r(s))), t && t.length > 0 && (e.isEnd ? (c(t), n(t)) : (u(t), r(t))) } function f() { return e.pagination && e.pagination.bullets && e.pagination.bullets.length } function g() { return f() && e.params.pagination.clickable } const v = (e, t, s) => { r(e), "BUTTON" !== e[0].tagName && (l(e, "button"), e.on("keydown", h)), p(e, s), function (e, t) { e.attr("aria-controls", t) }(e, t) }; function w() { const t = e.params.a11y; e.$el.append(a); const s = e.$el; t.containerRoleDescriptionMessage && o(s, t.containerRoleDescriptionMessage), t.containerMessage && p(s, t.containerMessage); const i = e.$wrapperEl, r = i.attr("id") || `swiper-wrapper-${function (e = 16) { return "x".repeat(e).replace(/x/g, (() => Math.round(16 * Math.random()).toString(16))) }(16)}`, n = e.params.autoplay && e.params.autoplay.enabled ? "off" : "polite"; var c; c = r, i.attr("id", c), function (e, t) { e.attr("aria-live", t) }(i, n), t.itemRoleDescriptionMessage && o(d(e.slides), t.itemRoleDescriptionMessage), l(d(e.slides), t.slideRole); const u = e.params.loop ? e.slides.filter((t => !t.classList.contains(e.params.slideDuplicateClass))).length : e.slides.length; let m, f; e.slides.each(((s, a) => { const i = d(s), r = e.params.loop ? parseInt(i.attr("data-swiper-slide-index"), 10) : a; p(i, t.slideLabelMessage.replace(/\{\{index\}\}/, r + 1).replace(/\{\{slidesLength\}\}/, u)) })), e.navigation && e.navigation.$nextEl && (m = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (f = e.navigation.$prevEl), m && m.length && v(m, r, t.nextSlideMessage), f && f.length && v(f, r, t.prevSlideMessage), g() && e.pagination.$el.on("keydown", W(e.params.pagination.bulletClass), h) } s("beforeInit", (() => { a = d(`<span class="${e.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`) })), s("afterInit", (() => { e.params.a11y.enabled && (w(), m()) })), s("toEdge", (() => { e.params.a11y.enabled && m() })), s("fromEdge", (() => { e.params.a11y.enabled && m() })), s("paginationUpdate", (() => { e.params.a11y.enabled && function () { const t = e.params.a11y; f() && e.pagination.bullets.each((s => { const a = d(s); e.params.pagination.clickable && (r(a), e.params.pagination.renderBullet || (l(a, "button"), p(a, t.paginationBulletMessage.replace(/\{\{index\}\}/, a.index() + 1)))), a.is(`.${e.params.pagination.bulletActiveClass}`) ? a.attr("aria-current", "true") : a.removeAttr("aria-current") })) }() })), s("destroy", (() => { e.params.a11y.enabled && function () { let t, s; a && a.length > 0 && a.remove(), e.navigation && e.navigation.$nextEl && (t = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (s = e.navigation.$prevEl), t && t.off("keydown", h), s && s.off("keydown", h), g() && e.pagination.$el.off("keydown", W(e.params.pagination.bulletClass), h) }() })) }, function ({ swiper: e, extendParams: t, on: s }) { t({ history: { enabled: !1, root: "", replaceState: !1, key: "slides" } }); let a = !1, i = {}; const n = e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), l = e => { const t = r(); let s; s = e ? new URL(e) : t.location; const a = s.pathname.slice(1).split("/").filter((e => "" !== e)), i = a.length; return { key: a[i - 2], value: a[i - 1] } }, o = (t, s) => { const i = r(); if (!a || !e.params.history.enabled) return; let l; l = e.params.url ? new URL(e.params.url) : i.location; const o = e.slides.eq(s); let d = n(o.attr("data-history")); if (e.params.history.root.length > 0) { let s = e.params.history.root; "/" === s[s.length - 1] && (s = s.slice(0, s.length - 1)), d = `${s}/${t}/${d}` } else l.pathname.includes(t) || (d = `${t}/${d}`); const p = i.history.state; p && p.value === d || (e.params.history.replaceState ? i.history.replaceState({ value: d }, null, d) : i.history.pushState({ value: d }, null, d)) }, d = (t, s, a) => { if (s) for (let i = 0, r = e.slides.length; i < r; i += 1) { const r = e.slides.eq(i); if (n(r.attr("data-history")) === s && !r.hasClass(e.params.slideDuplicateClass)) { const s = r.index(); e.slideTo(s, t, a) } } else e.slideTo(0, t, a) }, p = () => { i = l(e.params.url), d(e.params.speed, e.paths.value, !1) }; s("init", (() => { e.params.history.enabled && (() => { const t = r(); if (e.params.history) { if (!t.history || !t.history.pushState) return e.params.history.enabled = !1, void (e.params.hashNavigation.enabled = !0); a = !0, i = l(e.params.url), (i.key || i.value) && (d(0, i.value, e.params.runCallbacksOnInit), e.params.history.replaceState || t.addEventListener("popstate", p)) } })() })), s("destroy", (() => { e.params.history.enabled && (() => { const t = r(); e.params.history.replaceState || t.removeEventListener("popstate", p) })() })), s("transitionEnd _freeModeNoMomentumRelease", (() => { a && o(e.params.history.key, e.activeIndex) })), s("slideChange", (() => { a && e.params.cssMode && o(e.params.history.key, e.activeIndex) })) }, function ({ swiper: e, extendParams: t, emit: s, on: i }) { let n = !1; const l = a(), o = r(); t({ hashNavigation: { enabled: !1, replaceState: !1, watchState: !1 } }); const p = () => { s("hashChange"); const t = l.location.hash.replace("#", ""); if (t !== e.slides.eq(e.activeIndex).attr("data-hash")) { const s = e.$wrapperEl.children(`.${e.params.slideClass}[data-hash="${t}"]`).index(); if (void 0 === s) return; e.slideTo(s) } }, c = () => { if (n && e.params.hashNavigation.enabled) if (e.params.hashNavigation.replaceState && o.history && o.history.replaceState) o.history.replaceState(null, null, `#${e.slides.eq(e.activeIndex).attr("data-hash")}` || ""), s("hashSet"); else { const t = e.slides.eq(e.activeIndex), a = t.attr("data-hash") || t.attr("data-history"); l.location.hash = a || "", s("hashSet") } }; i("init", (() => { e.params.hashNavigation.enabled && (() => { if (!e.params.hashNavigation.enabled || e.params.history && e.params.history.enabled) return; n = !0; const t = l.location.hash.replace("#", ""); if (t) { const s = 0; for (let a = 0, i = e.slides.length; a < i; a += 1) { const i = e.slides.eq(a); if ((i.attr("data-hash") || i.attr("data-history")) === t && !i.hasClass(e.params.slideDuplicateClass)) { const t = i.index(); e.slideTo(t, s, e.params.runCallbacksOnInit, !0) } } } e.params.hashNavigation.watchState && d(o).on("hashchange", p) })() })), i("destroy", (() => { e.params.hashNavigation.enabled && e.params.hashNavigation.watchState && d(o).off("hashchange", p) })), i("transitionEnd _freeModeNoMomentumRelease", (() => { n && c() })), i("slideChange", (() => { n && e.params.cssMode && c() })) }, function ({ swiper: e, extendParams: t, on: s, emit: i }) { let r; function n() { const t = e.slides.eq(e.activeIndex); let s = e.params.autoplay.delay; t.attr("data-swiper-autoplay") && (s = t.attr("data-swiper-autoplay") || e.params.autoplay.delay), clearTimeout(r), r = c((() => { let t; e.params.autoplay.reverseDirection ? e.params.loop ? (e.loopFix(), t = e.slidePrev(e.params.speed, !0, !0), i("autoplay")) : e.isBeginning ? e.params.autoplay.stopOnLastSlide ? o() : (t = e.slideTo(e.slides.length - 1, e.params.speed, !0, !0), i("autoplay")) : (t = e.slidePrev(e.params.speed, !0, !0), i("autoplay")) : e.params.loop ? (e.loopFix(), t = e.slideNext(e.params.speed, !0, !0), i("autoplay")) : e.isEnd ? e.params.autoplay.stopOnLastSlide ? o() : (t = e.slideTo(0, e.params.speed, !0, !0), i("autoplay")) : (t = e.slideNext(e.params.speed, !0, !0), i("autoplay")), (e.params.cssMode && e.autoplay.running || !1 === t) && n() }), s) } function l() { return void 0 === r && (!e.autoplay.running && (e.autoplay.running = !0, i("autoplayStart"), n(), !0)) } function o() { return !!e.autoplay.running && (void 0 !== r && (r && (clearTimeout(r), r = void 0), e.autoplay.running = !1, i("autoplayStop"), !0)) } function d(t) { e.autoplay.running && (e.autoplay.paused || (r && clearTimeout(r), e.autoplay.paused = !0, 0 !== t && e.params.autoplay.waitForTransition ? ["transitionend", "webkitTransitionEnd"].forEach((t => { e.$wrapperEl[0].addEventListener(t, u) })) : (e.autoplay.paused = !1, n()))) } function p() { const t = a(); "hidden" === t.visibilityState && e.autoplay.running && d(), "visible" === t.visibilityState && e.autoplay.paused && (n(), e.autoplay.paused = !1) } function u(t) { e && !e.destroyed && e.$wrapperEl && t.target === e.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach((t => { e.$wrapperEl[0].removeEventListener(t, u) })), e.autoplay.paused = !1, e.autoplay.running ? n() : o()) } function h() { e.params.autoplay.disableOnInteraction ? o() : d(), ["transitionend", "webkitTransitionEnd"].forEach((t => { e.$wrapperEl[0].removeEventListener(t, u) })) } function m() { e.params.autoplay.disableOnInteraction || (e.autoplay.paused = !1, n()) } e.autoplay = { running: !1, paused: !1 }, t({ autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !0, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1 } }), s("init", (() => { if (e.params.autoplay.enabled) { l(); a().addEventListener("visibilitychange", p), e.params.autoplay.pauseOnMouseEnter && (e.$el.on("mouseenter", h), e.$el.on("mouseleave", m)) } })), s("beforeTransitionStart", ((t, s, a) => { e.autoplay.running && (a || !e.params.autoplay.disableOnInteraction ? e.autoplay.pause(s) : o()) })), s("sliderFirstMove", (() => { e.autoplay.running && (e.params.autoplay.disableOnInteraction ? o() : d()) })), s("touchEnd", (() => { e.params.cssMode && e.autoplay.paused && !e.params.autoplay.disableOnInteraction && n() })), s("destroy", (() => { e.$el.off("mouseenter", h), e.$el.off("mouseleave", m), e.autoplay.running && o(); a().removeEventListener("visibilitychange", p) })), Object.assign(e.autoplay, { pause: d, run: n, start: l, stop: o }) }, function ({ swiper: e, extendParams: t, on: s }) { t({ thumbs: { swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: "swiper-slide-thumb-active", thumbsContainerClass: "swiper-thumbs" } }); let a = !1, i = !1; function r() { const t = e.thumbs.swiper; if (!t) return; const s = t.clickedIndex, a = t.clickedSlide; if (a && d(a).hasClass(e.params.thumbs.slideThumbActiveClass)) return; if (null == s) return; let i; if (i = t.params.loop ? parseInt(d(t.clickedSlide).attr("data-swiper-slide-index"), 10) : s, e.params.loop) { let t = e.activeIndex; e.slides.eq(t).hasClass(e.params.slideDuplicateClass) && (e.loopFix(), e._clientLeft = e.$wrapperEl[0].clientLeft, t = e.activeIndex); const s = e.slides.eq(t).prevAll(`[data-swiper-slide-index="${i}"]`).eq(0).index(), a = e.slides.eq(t).nextAll(`[data-swiper-slide-index="${i}"]`).eq(0).index(); i = void 0 === s ? a : void 0 === a ? s : a - t < t - s ? a : s } e.slideTo(i) } function n() { const { thumbs: t } = e.params; if (a) return !1; a = !0; const s = e.constructor; if (t.swiper instanceof s) e.thumbs.swiper = t.swiper, Object.assign(e.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), Object.assign(e.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 }); else if (m(t.swiper)) { const a = Object.assign({}, t.swiper); Object.assign(a, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), e.thumbs.swiper = new s(a), i = !0 } return e.thumbs.swiper.$el.addClass(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on("tap", r), !0 } function l(t) { const s = e.thumbs.swiper; if (!s) return; const a = "auto" === s.params.slidesPerView ? s.slidesPerViewDynamic() : s.params.slidesPerView, i = e.params.thumbs.autoScrollOffset, r = i && !s.params.loop; if (e.realIndex !== s.realIndex || r) { let n, l, o = s.activeIndex; if (s.params.loop) { s.slides.eq(o).hasClass(s.params.slideDuplicateClass) && (s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft, o = s.activeIndex); const t = s.slides.eq(o).prevAll(`[data-swiper-slide-index="${e.realIndex}"]`).eq(0).index(), a = s.slides.eq(o).nextAll(`[data-swiper-slide-index="${e.realIndex}"]`).eq(0).index(); n = void 0 === t ? a : void 0 === a ? t : a - o == o - t ? s.params.slidesPerGroup > 1 ? a : o : a - o < o - t ? a : t, l = e.activeIndex > e.previousIndex ? "next" : "prev" } else n = e.realIndex, l = n > e.previousIndex ? "next" : "prev"; r && (n += "next" === l ? i : -1 * i), s.visibleSlidesIndexes && s.visibleSlidesIndexes.indexOf(n) < 0 && (s.params.centeredSlides ? n = n > o ? n - Math.floor(a / 2) + 1 : n + Math.floor(a / 2) - 1 : n > o && s.params.slidesPerGroup, s.slideTo(n, t ? 0 : void 0)) } let n = 1; const l = e.params.thumbs.slideThumbActiveClass; if (e.params.slidesPerView > 1 && !e.params.centeredSlides && (n = e.params.slidesPerView), e.params.thumbs.multipleActiveThumbs || (n = 1), n = Math.floor(n), s.slides.removeClass(l), s.params.loop || s.params.virtual && s.params.virtual.enabled) for (let t = 0; t < n; t += 1)s.$wrapperEl.children(`[data-swiper-slide-index="${e.realIndex + t}"]`).addClass(l); else for (let t = 0; t < n; t += 1)s.slides.eq(e.realIndex + t).addClass(l) } e.thumbs = { swiper: null }, s("beforeInit", (() => { const { thumbs: t } = e.params; t && t.swiper && (n(), l(!0)) })), s("slideChange update resize observerUpdate", (() => { e.thumbs.swiper && l() })), s("setTransition", ((t, s) => { const a = e.thumbs.swiper; a && a.setTransition(s) })), s("beforeDestroy", (() => { const t = e.thumbs.swiper; t && i && t && t.destroy() })), Object.assign(e.thumbs, { init: n, update: l }) }, function ({ swiper: e, extendParams: t, emit: s, once: a }) { t({ freeMode: { enabled: !1, momentum: !0, momentumRatio: 1, momentumBounce: !0, momentumBounceRatio: 1, momentumVelocityRatio: 1, sticky: !1, minimumVelocity: .02 } }), Object.assign(e, { freeMode: { onTouchMove: function () { const { touchEventsData: t, touches: s } = e; 0 === t.velocities.length && t.velocities.push({ position: s[e.isHorizontal() ? "startX" : "startY"], time: t.touchStartTime }), t.velocities.push({ position: s[e.isHorizontal() ? "currentX" : "currentY"], time: u() }) }, onTouchEnd: function ({ currentPos: t }) { const { params: i, $wrapperEl: r, rtlTranslate: n, snapGrid: l, touchEventsData: o } = e, d = u() - o.touchStartTime; if (t < -e.minTranslate()) e.slideTo(e.activeIndex); else if (t > -e.maxTranslate()) e.slides.length < l.length ? e.slideTo(l.length - 1) : e.slideTo(e.slides.length - 1); else { if (i.freeMode.momentum) { if (o.velocities.length > 1) { const t = o.velocities.pop(), s = o.velocities.pop(), a = t.position - s.position, r = t.time - s.time; e.velocity = a / r, e.velocity /= 2, Math.abs(e.velocity) < i.freeMode.minimumVelocity && (e.velocity = 0), (r > 150 || u() - t.time > 300) && (e.velocity = 0) } else e.velocity = 0; e.velocity *= i.freeMode.momentumVelocityRatio, o.velocities.length = 0; let t = 1e3 * i.freeMode.momentumRatio; const d = e.velocity * t; let p = e.translate + d; n && (p = -p); let c, h = !1; const m = 20 * Math.abs(e.velocity) * i.freeMode.momentumBounceRatio; let f; if (p < e.maxTranslate()) i.freeMode.momentumBounce ? (p + e.maxTranslate() < -m && (p = e.maxTranslate() - m), c = e.maxTranslate(), h = !0, o.allowMomentumBounce = !0) : p = e.maxTranslate(), i.loop && i.centeredSlides && (f = !0); else if (p > e.minTranslate()) i.freeMode.momentumBounce ? (p - e.minTranslate() > m && (p = e.minTranslate() + m), c = e.minTranslate(), h = !0, o.allowMomentumBounce = !0) : p = e.minTranslate(), i.loop && i.centeredSlides && (f = !0); else if (i.freeMode.sticky) { let t; for (let e = 0; e < l.length; e += 1)if (l[e] > -p) { t = e; break } p = Math.abs(l[t] - p) < Math.abs(l[t - 1] - p) || "next" === e.swipeDirection ? l[t] : l[t - 1], p = -p } if (f && a("transitionEnd", (() => { e.loopFix() })), 0 !== e.velocity) { if (t = n ? Math.abs((-p - e.translate) / e.velocity) : Math.abs((p - e.translate) / e.velocity), i.freeMode.sticky) { const s = Math.abs((n ? -p : p) - e.translate), a = e.slidesSizesGrid[e.activeIndex]; t = s < a ? i.speed : s < 2 * a ? 1.5 * i.speed : 2.5 * i.speed } } else if (i.freeMode.sticky) return void e.slideToClosest(); i.freeMode.momentumBounce && h ? (e.updateProgress(c), e.setTransition(t), e.setTranslate(p), e.transitionStart(!0, e.swipeDirection), e.animating = !0, r.transitionEnd((() => { e && !e.destroyed && o.allowMomentumBounce && (s("momentumBounce"), e.setTransition(i.speed), setTimeout((() => { e.setTranslate(c), r.transitionEnd((() => { e && !e.destroyed && e.transitionEnd() })) }), 0)) }))) : e.velocity ? (s("_freeModeNoMomentumRelease"), e.updateProgress(p), e.setTransition(t), e.setTranslate(p), e.transitionStart(!0, e.swipeDirection), e.animating || (e.animating = !0, r.transitionEnd((() => { e && !e.destroyed && e.transitionEnd() })))) : e.updateProgress(p), e.updateActiveIndex(), e.updateSlidesClasses() } else { if (i.freeMode.sticky) return void e.slideToClosest(); i.freeMode && s("_freeModeNoMomentumRelease") } (!i.freeMode.momentum || d >= i.longSwipesMs) && (e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses()) } } } }) }, function ({ swiper: e, extendParams: t }) { let s, a, i; t({ grid: { rows: 1, fill: "column" } }), e.grid = { initSlides: t => { const { slidesPerView: r } = e.params, { rows: n, fill: l } = e.params.grid; a = s / n, i = Math.floor(t / n), s = Math.floor(t / n) === t / n ? t : Math.ceil(t / n) * n, "auto" !== r && "row" === l && (s = Math.max(s, r * n)) }, updateSlide: (t, r, n, l) => { const { slidesPerGroup: o, spaceBetween: d } = e.params, { rows: p, fill: c } = e.params.grid; let u, h, m; if ("row" === c && o > 1) { const e = Math.floor(t / (o * p)), a = t - p * o * e, i = 0 === e ? o : Math.min(Math.ceil((n - e * p * o) / p), o); m = Math.floor(a / i), h = a - m * i + e * o, u = h + m * s / p, r.css({ "-webkit-order": u, order: u }) } else "column" === c ? (h = Math.floor(t / p), m = t - h * p, (h > i || h === i && m === p - 1) && (m += 1, m >= p && (m = 0, h += 1))) : (m = Math.floor(t / a), h = t - m * a); r.css(l("margin-top"), 0 !== m ? d && `${d}px` : "") }, updateWrapperSize: (t, a, i) => { const { spaceBetween: r, centeredSlides: n, roundLengths: l } = e.params, { rows: o } = e.params.grid; if (e.virtualSize = (t + r) * s, e.virtualSize = Math.ceil(e.virtualSize / o) - r, e.$wrapperEl.css({ [i("width")]: `${e.virtualSize + r}px` }), n) { a.splice(0, a.length); const t = []; for (let s = 0; s < a.length; s += 1) { let i = a[s]; l && (i = Math.floor(i)), a[s] < e.virtualSize + a[0] && t.push(i) } a.push(...t) } } } }, function ({ swiper: e }) { Object.assign(e, { appendSlide: R.bind(e), prependSlide: j.bind(e), addSlide: _.bind(e), removeSlide: V.bind(e), removeAllSlides: q.bind(e) }) }, function ({ swiper: e, extendParams: t, on: s }) { t({ fadeEffect: { crossFade: !1, transformEl: null } }), F({ effect: "fade", swiper: e, on: s, setTranslate: () => { const { slides: t } = e, s = e.params.fadeEffect; for (let a = 0; a < t.length; a += 1) { const t = e.slides.eq(a); let i = -t[0].swiperSlideOffset; e.params.virtualTranslate || (i -= e.translate); let r = 0; e.isHorizontal() || (r = i, i = 0); const n = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(t[0].progress), 0) : 1 + Math.min(Math.max(t[0].progress, -1), 0); U(s, t).css({ opacity: n }).transform(`translate3d(${i}px, ${r}px, 0px)`) } }, setTransition: t => { const { transformEl: s } = e.params.fadeEffect; (s ? e.slides.find(s) : e.slides).transition(t), K({ swiper: e, duration: t, transformEl: s, allSlides: !0 }) }, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !e.params.cssMode }) }) }, function ({ swiper: e, extendParams: t, on: s }) { t({ cubeEffect: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94 } }), F({ effect: "cube", swiper: e, on: s, setTranslate: () => { const { $el: t, $wrapperEl: s, slides: a, width: i, height: r, rtlTranslate: n, size: l, browser: o } = e, p = e.params.cubeEffect, c = e.isHorizontal(), u = e.virtual && e.params.virtual.enabled; let h, m = 0; p.shadow && (c ? (h = s.find(".swiper-cube-shadow"), 0 === h.length && (h = d('<div class="swiper-cube-shadow"></div>'), s.append(h)), h.css({ height: `${i}px` })) : (h = t.find(".swiper-cube-shadow"), 0 === h.length && (h = d('<div class="swiper-cube-shadow"></div>'), t.append(h)))); for (let e = 0; e < a.length; e += 1) { const t = a.eq(e); let s = e; u && (s = parseInt(t.attr("data-swiper-slide-index"), 10)); let i = 90 * s, r = Math.floor(i / 360); n && (i = -i, r = Math.floor(-i / 360)); const o = Math.max(Math.min(t[0].progress, 1), -1); let h = 0, f = 0, g = 0; s % 4 == 0 ? (h = 4 * -r * l, g = 0) : (s - 1) % 4 == 0 ? (h = 0, g = 4 * -r * l) : (s - 2) % 4 == 0 ? (h = l + 4 * r * l, g = l) : (s - 3) % 4 == 0 && (h = -l, g = 3 * l + 4 * l * r), n && (h = -h), c || (f = h, h = 0); const v = `rotateX(${c ? 0 : -i}deg) rotateY(${c ? i : 0}deg) translate3d(${h}px, ${f}px, ${g}px)`; if (o <= 1 && o > -1 && (m = 90 * s + 90 * o, n && (m = 90 * -s - 90 * o)), t.transform(v), p.slideShadows) { let e = c ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"), s = c ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom"); 0 === e.length && (e = d(`<div class="swiper-slide-shadow-${c ? "left" : "top"}"></div>`), t.append(e)), 0 === s.length && (s = d(`<div class="swiper-slide-shadow-${c ? "right" : "bottom"}"></div>`), t.append(s)), e.length && (e[0].style.opacity = Math.max(-o, 0)), s.length && (s[0].style.opacity = Math.max(o, 0)) } } if (s.css({ "-webkit-transform-origin": `50% 50% -${l / 2}px`, "transform-origin": `50% 50% -${l / 2}px` }), p.shadow) if (c) h.transform(`translate3d(0px, ${i / 2 + p.shadowOffset}px, ${-i / 2}px) rotateX(90deg) rotateZ(0deg) scale(${p.shadowScale})`); else { const e = Math.abs(m) - 90 * Math.floor(Math.abs(m) / 90), t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2), s = p.shadowScale, a = p.shadowScale / t, i = p.shadowOffset; h.transform(`scale3d(${s}, 1, ${a}) translate3d(0px, ${r / 2 + i}px, ${-r / 2 / a}px) rotateX(-90deg)`) } const f = o.isSafari || o.isWebView ? -l / 2 : 0; s.transform(`translate3d(0px,0,${f}px) rotateX(${e.isHorizontal() ? 0 : m}deg) rotateY(${e.isHorizontal() ? -m : 0}deg)`) }, setTransition: t => { const { $el: s, slides: a } = e; a.transition(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(t), e.params.cubeEffect.shadow && !e.isHorizontal() && s.find(".swiper-cube-shadow").transition(t) }, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0 }) }) }, function ({ swiper: e, extendParams: t, on: s }) { t({ flipEffect: { slideShadows: !0, limitRotation: !0, transformEl: null } }), F({ effect: "flip", swiper: e, on: s, setTranslate: () => { const { slides: t, rtlTranslate: s } = e, a = e.params.flipEffect; for (let i = 0; i < t.length; i += 1) { const r = t.eq(i); let n = r[0].progress; e.params.flipEffect.limitRotation && (n = Math.max(Math.min(r[0].progress, 1), -1)); const l = r[0].swiperSlideOffset; let o = -180 * n, d = 0, p = e.params.cssMode ? -l - e.translate : -l, c = 0; if (e.isHorizontal() ? s && (o = -o) : (c = p, p = 0, d = -o, o = 0), r[0].style.zIndex = -Math.abs(Math.round(n)) + t.length, a.slideShadows) { let t = e.isHorizontal() ? r.find(".swiper-slide-shadow-left") : r.find(".swiper-slide-shadow-top"), s = e.isHorizontal() ? r.find(".swiper-slide-shadow-right") : r.find(".swiper-slide-shadow-bottom"); 0 === t.length && (t = Z(a, r, e.isHorizontal() ? "left" : "top")), 0 === s.length && (s = Z(a, r, e.isHorizontal() ? "right" : "bottom")), t.length && (t[0].style.opacity = Math.max(-n, 0)), s.length && (s[0].style.opacity = Math.max(n, 0)) } const u = `translate3d(${p}px, ${c}px, 0px) rotateX(${d}deg) rotateY(${o}deg)`; U(a, r).transform(u) } }, setTransition: t => { const { transformEl: s } = e.params.flipEffect; (s ? e.slides.find(s) : e.slides).transition(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(t), K({ swiper: e, duration: t, transformEl: s }) }, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !e.params.cssMode }) }) }, function ({ swiper: e, extendParams: t, on: s }) { t({ coverflowEffect: { rotate: 50, stretch: 0, depth: 100, scale: 1, modifier: 1, slideShadows: !0, transformEl: null } }), F({ effect: "coverflow", swiper: e, on: s, setTranslate: () => { const { width: t, height: s, slides: a, slidesSizesGrid: i } = e, r = e.params.coverflowEffect, n = e.isHorizontal(), l = e.translate, o = n ? t / 2 - l : s / 2 - l, d = n ? r.rotate : -r.rotate, p = r.depth; for (let e = 0, t = a.length; e < t; e += 1) { const t = a.eq(e), s = i[e], l = (o - t[0].swiperSlideOffset - s / 2) / s * r.modifier; let c = n ? d * l : 0, u = n ? 0 : d * l, h = -p * Math.abs(l), m = r.stretch; "string" == typeof m && -1 !== m.indexOf("%") && (m = parseFloat(r.stretch) / 100 * s); let f = n ? 0 : m * l, g = n ? m * l : 0, v = 1 - (1 - r.scale) * Math.abs(l); Math.abs(g) < .001 && (g = 0), Math.abs(f) < .001 && (f = 0), Math.abs(h) < .001 && (h = 0), Math.abs(c) < .001 && (c = 0), Math.abs(u) < .001 && (u = 0), Math.abs(v) < .001 && (v = 0); const w = `translate3d(${g}px,${f}px,${h}px)  rotateX(${u}deg) rotateY(${c}deg) scale(${v})`; if (U(r, t).transform(w), t[0].style.zIndex = 1 - Math.abs(Math.round(l)), r.slideShadows) { let e = n ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"), s = n ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom"); 0 === e.length && (e = Z(r, t, n ? "left" : "top")), 0 === s.length && (s = Z(r, t, n ? "right" : "bottom")), e.length && (e[0].style.opacity = l > 0 ? l : 0), s.length && (s[0].style.opacity = -l > 0 ? -l : 0) } } }, setTransition: t => { const { transformEl: s } = e.params.coverflowEffect; (s ? e.slides.find(s) : e.slides).transition(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(t) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0 }) }) }, function ({ swiper: e, extendParams: t, on: s }) { t({ creativeEffect: { transformEl: null, limitProgress: 1, shadowPerProgress: !1, progressMultiplier: 1, perspective: !0, prev: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 }, next: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 } } }); const a = e => "string" == typeof e ? e : `${e}px`; F({ effect: "creative", swiper: e, on: s, setTranslate: () => { const { slides: t, $wrapperEl: s, slidesSizesGrid: i } = e, r = e.params.creativeEffect, { progressMultiplier: n } = r, l = e.params.centeredSlides; if (l) { const t = i[0] / 2 - e.params.slidesOffsetBefore || 0; s.transform(`translateX(calc(50% - ${t}px))`) } for (let s = 0; s < t.length; s += 1) { const i = t.eq(s), o = i[0].progress, d = Math.min(Math.max(i[0].progress, -r.limitProgress), r.limitProgress); let p = d; l || (p = Math.min(Math.max(i[0].originalProgress, -r.limitProgress), r.limitProgress)); const c = i[0].swiperSlideOffset, u = [e.params.cssMode ? -c - e.translate : -c, 0, 0], h = [0, 0, 0]; let m = !1; e.isHorizontal() || (u[1] = u[0], u[0] = 0); let f = { translate: [0, 0, 0], rotate: [0, 0, 0], scale: 1, opacity: 1 }; d < 0 ? (f = r.next, m = !0) : d > 0 && (f = r.prev, m = !0), u.forEach(((e, t) => { u[t] = `calc(${e}px + (${a(f.translate[t])} * ${Math.abs(d * n)}))` })), h.forEach(((e, t) => { h[t] = f.rotate[t] * Math.abs(d * n) })), i[0].style.zIndex = -Math.abs(Math.round(o)) + t.length; const g = u.join(", "), v = `rotateX(${h[0]}deg) rotateY(${h[1]}deg) rotateZ(${h[2]}deg)`, w = p < 0 ? `scale(${1 + (1 - f.scale) * p * n})` : `scale(${1 - (1 - f.scale) * p * n})`, b = p < 0 ? 1 + (1 - f.opacity) * p * n : 1 - (1 - f.opacity) * p * n, x = `translate3d(${g}) ${v} ${w}`; if (m && f.shadow || !m) { let e = i.children(".swiper-slide-shadow"); if (0 === e.length && f.shadow && (e = Z(r, i)), e.length) { const t = r.shadowPerProgress ? d * (1 / r.limitProgress) : d; e[0].style.opacity = Math.min(Math.max(Math.abs(t), 0), 1) } } const y = U(r, i); y.transform(x).css({ opacity: b }), f.origin && y.css("transform-origin", f.origin) } }, setTransition: t => { const { transformEl: s } = e.params.creativeEffect; (s ? e.slides.find(s) : e.slides).transition(t).find(".swiper-slide-shadow").transition(t), K({ swiper: e, duration: t, transformEl: s, allSlides: !0 }) }, perspective: () => e.params.creativeEffect.perspective, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !e.params.cssMode }) }) }, function ({ swiper: e, extendParams: t, on: s }) { t({ cardsEffect: { slideShadows: !0, transformEl: null } }), F({ effect: "cards", swiper: e, on: s, setTranslate: () => { const { slides: t, activeIndex: s } = e, a = e.params.cardsEffect, { startTranslate: i, isTouched: r } = e.touchEventsData, n = e.translate; for (let l = 0; l < t.length; l += 1) { const o = t.eq(l), d = o[0].progress, p = Math.min(Math.max(d, -4), 4); let c = o[0].swiperSlideOffset; e.params.centeredSlides && !e.params.cssMode && e.$wrapperEl.transform(`translateX(${e.minTranslate()}px)`), e.params.centeredSlides && e.params.cssMode && (c -= t[0].swiperSlideOffset); let u = e.params.cssMode ? -c - e.translate : -c, h = 0; const m = -100 * Math.abs(p); let f = 1, g = -2 * p, v = 8 - .75 * Math.abs(p); const w = (l === s || l === s - 1) && p > 0 && p < 1 && (r || e.params.cssMode) && n < i, b = (l === s || l === s + 1) && p < 0 && p > -1 && (r || e.params.cssMode) && n > i; if (w || b) { const e = (1 - Math.abs((Math.abs(p) - .5) / .5)) ** .5; g += -28 * p * e, f += -.5 * e, v += 96 * e, h = -25 * e * Math.abs(p) + "%" } if (u = p < 0 ? `calc(${u}px + (${v * Math.abs(p)}%))` : p > 0 ? `calc(${u}px + (-${v * Math.abs(p)}%))` : `${u}px`, !e.isHorizontal()) { const e = h; h = u, u = e } const x = `\n        translate3d(${u}, ${h}, ${m}px)\n        rotateZ(${g}deg)\n        scale(${p < 0 ? "" + (1 + (1 - f) * p) : "" + (1 - (1 - f) * p)})\n      `; if (a.slideShadows) { let e = o.find(".swiper-slide-shadow"); 0 === e.length && (e = Z(a, o)), e.length && (e[0].style.opacity = Math.min(Math.max((Math.abs(p) - .5) / .5, 0), 1)) } o[0].style.zIndex = -Math.abs(Math.round(d)) + t.length; U(a, o).transform(x) } }, setTransition: t => { const { transformEl: s } = e.params.cardsEffect; (s ? e.slides.find(s) : e.slides).transition(t).find(".swiper-slide-shadow").transition(t), K({ swiper: e, duration: t, transformEl: s }) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !e.params.cssMode }) }) }]; return H.use(J), H }));





/*!
 * GSAP 3.11.3
 * https://greensock.com
 * 
 * @license Copyright 2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */

!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = t || self).window = t.window || {}) }(this, function (e) { "use strict"; function _inheritsLoose(t, e) { t.prototype = Object.create(e.prototype), (t.prototype.constructor = t).__proto__ = e } function _assertThisInitialized(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function r(t) { return "string" == typeof t } function s(t) { return "function" == typeof t } function t(t) { return "number" == typeof t } function u(t) { return void 0 === t } function v(t) { return "object" == typeof t } function w(t) { return !1 !== t } function x() { return "undefined" != typeof window } function y(t) { return s(t) || r(t) } function P(t) { return (i = yt(t, ot)) && Ce } function Q(t, e) { return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()") } function R(t, e) { return !e && console.warn(t) } function S(t, e) { return t && (ot[t] = e) && i && (i[t] = e) || ot } function T() { return 0 } function ea(t) { var e, r, i = t[0]; if (v(i) || s(i) || (t = [t]), !(e = (i._gsap || {}).harness)) { for (r = gt.length; r-- && !gt[r].targetTest(i);); e = gt[r] } for (r = t.length; r--;)t[r] && (t[r]._gsap || (t[r]._gsap = new jt(t[r], e))) || t.splice(r, 1); return t } function fa(t) { return t._gsap || ea(Ot(t))[0]._gsap } function ga(t, e, r) { return (r = t[e]) && s(r) ? t[e]() : u(r) && t.getAttribute && t.getAttribute(e) || r } function ha(t, e) { return (t = t.split(",")).forEach(e) || t } function ia(t) { return Math.round(1e5 * t) / 1e5 || 0 } function ja(t) { return Math.round(1e7 * t) / 1e7 || 0 } function ka(t, e) { var r = e.charAt(0), i = parseFloat(e.substr(2)); return t = parseFloat(t), "+" === r ? t + i : "-" === r ? t - i : "*" === r ? t * i : t / i } function la(t, e) { for (var r = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < r;); return i < r } function ma() { var t, e, r = ct.length, i = ct.slice(0); for (dt = {}, t = ct.length = 0; t < r; t++)(e = i[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0) } function na(t, e, r, i) { ct.length && ma(), t.render(e, r, i || B && e < 0 && (t._initted || t._startAt)), ct.length && ma() } function oa(t) { var e = parseFloat(t); return (e || 0 === e) && (t + "").match(at).length < 2 ? e : r(t) ? t.trim() : t } function pa(t) { return t } function qa(t, e) { for (var r in e) r in t || (t[r] = e[r]); return t } function ta(t, e) { for (var r in e) "__proto__" !== r && "constructor" !== r && "prototype" !== r && (t[r] = v(e[r]) ? ta(t[r] || (t[r] = {}), e[r]) : e[r]); return t } function ua(t, e) { var r, i = {}; for (r in t) r in e || (i[r] = t[r]); return i } function va(t) { var e = t.parent || L, r = t.keyframes ? function _setKeyframeDefaults(i) { return function (t, e) { for (var r in e) r in t || "duration" === r && i || "ease" === r || (t[r] = e[r]) } }($(t.keyframes)) : qa; if (w(t.inherit)) for (; e;)r(t, e.vars.defaults), e = e.parent || e._dp; return t } function xa(t, e, r, i, n) { void 0 === r && (r = "_first"), void 0 === i && (i = "_last"); var a, s = t[i]; if (n) for (a = e[n]; s && s[n] > a;)s = s._prev; return s ? (e._next = s._next, s._next = e) : (e._next = t[r], t[r] = e), e._next ? e._next._prev = e : t[i] = e, e._prev = s, e.parent = e._dp = t, e } function ya(t, e, r, i) { void 0 === r && (r = "_first"), void 0 === i && (i = "_last"); var n = e._prev, a = e._next; n ? n._next = a : t[r] === e && (t[r] = a), a ? a._prev = n : t[i] === e && (t[i] = n), e._next = e._prev = e.parent = null } function za(t, e) { !t.parent || e && !t.parent.autoRemoveChildren || t.parent.remove(t), t._act = 0 } function Aa(t, e) { if (t && (!e || e._end > t._dur || e._start < 0)) for (var r = t; r;)r._dirty = 1, r = r.parent; return t } function Ca(t, e, r, i) { return t._startAt && (B ? t._startAt.revert(ht) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(e, !0, i)) } function Ea(t) { return t._repeat ? Tt(t._tTime, t = t.duration() + t._rDelay) * t : 0 } function Ga(t, e) { return (t - e._start) * e._ts + (0 <= e._ts ? 0 : e._dirty ? e.totalDuration() : e._tDur) } function Ha(t) { return t._end = ja(t._start + (t._tDur / Math.abs(t._ts || t._rts || V) || 0)) } function Ia(t, e) { var r = t._dp; return r && r.smoothChildTiming && t._ts && (t._start = ja(r._time - (0 < t._ts ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), Ha(t), r._dirty || Aa(r, t)), t } function Ja(t, e) { var r; if ((e._time || e._initted && !e._dur) && (r = Ga(t.rawTime(), e), (!e._dur || kt(0, e.totalDuration(), r) - e._tTime > V) && e.render(r, !0)), Aa(t, e)._dp && t._initted && t._time >= t._dur && t._ts) { if (t._dur < t.duration()) for (r = t; r._dp;)0 <= r.rawTime() && r.totalTime(r._tTime), r = r._dp; t._zTime = -V } } function Ka(e, r, i, n) { return r.parent && za(r), r._start = ja((t(i) ? i : i || e !== L ? xt(e, i, r) : e._time) + r._delay), r._end = ja(r._start + (r.totalDuration() / Math.abs(r.timeScale()) || 0)), xa(e, r, "_first", "_last", e._sort ? "_start" : 0), bt(r) || (e._recent = r), n || Ja(e, r), e._ts < 0 && Ia(e, e._tTime), e } function La(t, e) { return (ot.ScrollTrigger || Q("scrollTrigger", e)) && ot.ScrollTrigger.create(e, t) } function Ma(t, e, r, i, n) { return Ht(t, e, n), t._initted ? !r && t._pt && !B && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && f !== Et.frame ? (ct.push(t), t._lazy = [n, i], 1) : void 0 : 1 } function Ra(t, e, r, i) { var n = t._repeat, a = ja(e) || 0, s = t._tTime / t._tDur; return s && !i && (t._time *= a / t._dur), t._dur = a, t._tDur = n ? n < 0 ? 1e10 : ja(a * (n + 1) + t._rDelay * n) : a, 0 < s && !i && Ia(t, t._tTime = t._tDur * s), t.parent && Ha(t), r || Aa(t.parent, t), t } function Sa(t) { return t instanceof Ut ? Aa(t) : Ra(t, t._dur) } function Va(e, r, i) { var n, a, s = t(r[1]), o = (s ? 2 : 1) + (e < 2 ? 0 : 1), u = r[o]; if (s && (u.duration = r[1]), u.parent = i, e) { for (n = u, a = i; a && !("immediateRender" in n);)n = a.vars.defaults || {}, a = w(a.vars.inherit) && a.parent; u.immediateRender = w(n.immediateRender), e < 2 ? u.runBackwards = 1 : u.startAt = r[o - 1] } return new Gt(r[0], u, r[1 + o]) } function Wa(t, e) { return t || 0 === t ? e(t) : e } function Ya(t, e) { return r(t) && (e = st.exec(t)) ? e[1] : "" } function _a(t, e) { return t && v(t) && "length" in t && (!e && !t.length || t.length - 1 in t && v(t[0])) && !t.nodeType && t !== h } function cb(r) { return r = Ot(r)[0] || R("Invalid scope") || {}, function (t) { var e = r.current || r.nativeElement || r; return Ot(t, e.querySelectorAll ? e : e === r ? R("Invalid scope") || a.createElement("div") : r) } } function db(t) { return t.sort(function () { return .5 - Math.random() }) } function eb(t) { if (s(t)) return t; var p = v(t) ? t : { each: t }, _ = Yt(p.ease), m = p.from || 0, g = parseFloat(p.base) || 0, y = {}, e = 0 < m && m < 1, T = isNaN(m) || e, b = p.axis, w = m, x = m; return r(m) ? w = x = { center: .5, edges: .5, end: 1 }[m] || 0 : !e && T && (w = m[0], x = m[1]), function (t, e, r) { var i, n, a, s, o, u, h, l, f, c = (r || p).length, d = y[c]; if (!d) { if (!(f = "auto" === p.grid ? 0 : (p.grid || [1, U])[1])) { for (h = -U; h < (h = r[f++].getBoundingClientRect().left) && f < c;); f-- } for (d = y[c] = [], i = T ? Math.min(f, c) * w - .5 : m % f, n = f === U ? 0 : T ? c * x / f - .5 : m / f | 0, l = U, u = h = 0; u < c; u++)a = u % f - i, s = n - (u / f | 0), d[u] = o = b ? Math.abs("y" === b ? s : a) : K(a * a + s * s), h < o && (h = o), o < l && (l = o); "random" === m && db(d), d.max = h - l, d.min = l, d.v = c = (parseFloat(p.amount) || parseFloat(p.each) * (c < f ? c - 1 : b ? "y" === b ? c / f : f : Math.max(f, c / f)) || 0) * ("edges" === m ? -1 : 1), d.b = c < 0 ? g - c : g, d.u = Ya(p.amount || p.each) || 0, _ = _ && c < 0 ? Lt(_) : _ } return c = (d[t] - d.min) / d.max || 0, ja(d.b + (_ ? _(c) : c) * d.v) + d.u } } function fb(i) { var n = Math.pow(10, ((i + "").split(".")[1] || "").length); return function (e) { var r = ja(Math.round(parseFloat(e) / i) * i * n); return (r - r % 1) / n + (t(e) ? 0 : Ya(e)) } } function gb(h, e) { var l, f, r = $(h); return !r && v(h) && (l = r = h.radius || U, h.values ? (h = Ot(h.values), (f = !t(h[0])) && (l *= l)) : h = fb(h.increment)), Wa(e, r ? s(h) ? function (t) { return f = h(t), Math.abs(f - t) <= l ? f : t } : function (e) { for (var r, i, n = parseFloat(f ? e.x : e), a = parseFloat(f ? e.y : 0), s = U, o = 0, u = h.length; u--;)(r = f ? (r = h[u].x - n) * r + (i = h[u].y - a) * i : Math.abs(h[u] - n)) < s && (s = r, o = u); return o = !l || s <= l ? h[o] : e, f || o === e || t(e) ? o : o + Ya(e) } : fb(h)) } function hb(t, e, r, i) { return Wa($(t) ? !e : !0 === r ? !!(r = 0) : !i, function () { return $(t) ? t[~~(Math.random() * t.length)] : (r = r || 1e-5) && (i = r < 1 ? Math.pow(10, (r + "").length - 2) : 1) && Math.floor(Math.round((t - r / 2 + Math.random() * (e - t + .99 * r)) / r) * r * i) / i }) } function lb(e, r, t) { return Wa(t, function (t) { return e[~~r(t)] }) } function ob(t) { for (var e, r, i, n, a = 0, s = ""; ~(e = t.indexOf("random(", a));)i = t.indexOf(")", e), n = "[" === t.charAt(e + 7), r = t.substr(e + 7, i - e - 7).match(n ? at : tt), s += t.substr(a, e - a) + hb(n ? r : +r[0], n ? 0 : +r[1], +r[2] || 1e-5), a = i + 1; return s + t.substr(a, t.length - a) } function rb(t, e, r) { var i, n, a, s = t.labels, o = U; for (i in s) (n = s[i] - e) < 0 == !!r && n && o > (n = Math.abs(n)) && (a = i, o = n); return a } function tb(t) { return za(t), t.scrollTrigger && t.scrollTrigger.kill(!!B), t.progress() < 1 && Ct(t, "onInterrupt"), t } function yb(t, e, r) { return (6 * (t += t < 0 ? 1 : 1 < t ? -1 : 0) < 1 ? e + (r - e) * t * 6 : t < .5 ? r : 3 * t < 2 ? e + (r - e) * (2 / 3 - t) * 6 : e) * At + .5 | 0 } function zb(e, r, i) { var n, a, s, o, u, h, l, f, c, d, p = e ? t(e) ? [e >> 16, e >> 8 & At, e & At] : 0 : St.black; if (!p) { if ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)), St[e]) p = St[e]; else if ("#" === e.charAt(0)) { if (e.length < 6 && (e = "#" + (n = e.charAt(1)) + n + (a = e.charAt(2)) + a + (s = e.charAt(3)) + s + (5 === e.length ? e.charAt(4) + e.charAt(4) : "")), 9 === e.length) return [(p = parseInt(e.substr(1, 6), 16)) >> 16, p >> 8 & At, p & At, parseInt(e.substr(7), 16) / 255]; p = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & At, e & At] } else if ("hsl" === e.substr(0, 3)) if (p = d = e.match(tt), r) { if (~e.indexOf("=")) return p = e.match(et), i && p.length < 4 && (p[3] = 1), p } else o = +p[0] % 360 / 360, u = p[1] / 100, n = 2 * (h = p[2] / 100) - (a = h <= .5 ? h * (u + 1) : h + u - h * u), 3 < p.length && (p[3] *= 1), p[0] = yb(o + 1 / 3, n, a), p[1] = yb(o, n, a), p[2] = yb(o - 1 / 3, n, a); else p = e.match(tt) || St.transparent; p = p.map(Number) } return r && !d && (n = p[0] / At, a = p[1] / At, s = p[2] / At, h = ((l = Math.max(n, a, s)) + (f = Math.min(n, a, s))) / 2, l === f ? o = u = 0 : (c = l - f, u = .5 < h ? c / (2 - l - f) : c / (l + f), o = l === n ? (a - s) / c + (a < s ? 6 : 0) : l === a ? (s - n) / c + 2 : (n - a) / c + 4, o *= 60), p[0] = ~~(o + .5), p[1] = ~~(100 * u + .5), p[2] = ~~(100 * h + .5)), i && p.length < 4 && (p[3] = 1), p } function Ab(t) { var r = [], i = [], n = -1; return t.split(Rt).forEach(function (t) { var e = t.match(rt) || []; r.push.apply(r, e), i.push(n += e.length + 1) }), r.c = i, r } function Bb(t, e, r) { var i, n, a, s, o = "", u = (t + o).match(Rt), h = e ? "hsla(" : "rgba(", l = 0; if (!u) return t; if (u = u.map(function (t) { return (t = zb(t, e, 1)) && h + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")" }), r && (a = Ab(t), (i = r.c).join(o) !== a.c.join(o))) for (s = (n = t.replace(Rt, "1").split(rt)).length - 1; l < s; l++)o += n[l] + (~i.indexOf(l) ? u.shift() || h + "0,0,0,0)" : (a.length ? a : u.length ? u : r).shift()); if (!n) for (s = (n = t.split(Rt)).length - 1; l < s; l++)o += n[l] + u[l]; return o + n[s] } function Eb(t) { var e, r = t.join(" "); if (Rt.lastIndex = 0, Rt.test(r)) return e = Dt.test(r), t[1] = Bb(t[1], e), t[0] = Bb(t[0], e, Ab(t[1])), !0 } function Nb(t) { var e = (t + "").split("("), r = Ft[e[0]]; return r && 1 < e.length && r.config ? r.config.apply(null, ~t.indexOf("{") ? [function _parseObjectInString(t) { for (var e, r, i, n = {}, a = t.substr(1, t.length - 3).split(":"), s = a[0], o = 1, u = a.length; o < u; o++)r = a[o], e = o !== u - 1 ? r.lastIndexOf(",") : r.length, i = r.substr(0, e), n[s] = isNaN(i) ? i.replace(Bt, "").trim() : +i, s = r.substr(e + 1).trim(); return n }(e[1])] : function _valueInParentheses(t) { var e = t.indexOf("(") + 1, r = t.indexOf(")"), i = t.indexOf("(", e); return t.substring(e, ~i && i < r ? t.indexOf(")", r + 1) : r) }(t).split(",").map(oa)) : Ft._CE && It.test(t) ? Ft._CE("", t) : r } function Pb(t, e) { for (var r, i = t._first; i;)i instanceof Ut ? Pb(i, e) : !i.vars.yoyoEase || i._yoyo && i._repeat || i._yoyo === e || (i.timeline ? Pb(i.timeline, e) : (r = i._ease, i._ease = i._yEase, i._yEase = r, i._yoyo = e)), i = i._next } function Rb(t, e, r, i) { void 0 === r && (r = function easeOut(t) { return 1 - e(1 - t) }), void 0 === i && (i = function easeInOut(t) { return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2 }); var n, a = { easeIn: e, easeOut: r, easeInOut: i }; return ha(t, function (t) { for (var e in Ft[t] = ot[t] = a, Ft[n = t.toLowerCase()] = r, a) Ft[n + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = Ft[t + "." + e] = a[e] }), a } function Sb(e) { return function (t) { return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2 } } function Tb(r, t, e) { function Hm(t) { return 1 === t ? 1 : i * Math.pow(2, -10 * t) * G((t - a) * n) + 1 } var i = 1 <= t ? t : 1, n = (e || (r ? .3 : .45)) / (t < 1 ? t : 1), a = n / W * (Math.asin(1 / i) || 0), s = "out" === r ? Hm : "in" === r ? function (t) { return 1 - Hm(1 - t) } : Sb(Hm); return n = W / n, s.config = function (t, e) { return Tb(r, t, e) }, s } function Ub(e, r) { function Pm(t) { return t ? --t * t * ((r + 1) * t + r) + 1 : 0 } void 0 === r && (r = 1.70158); var t = "out" === e ? Pm : "in" === e ? function (t) { return 1 - Pm(1 - t) } : Sb(Pm); return t.config = function (t) { return Ub(e, t) }, t } var I, B, l, L, h, n, a, i, o, f, c, d, p, _, m, g, b, k, M, O, C, A, D, E, z, F, Y, N, j = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, q = { duration: .5, overwrite: !1, delay: 0 }, U = 1e8, V = 1 / U, W = 2 * Math.PI, X = W / 4, H = 0, K = Math.sqrt, Z = Math.cos, G = Math.sin, J = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () { }, $ = Array.isArray, tt = /(?:-?\.?\d|\.)+/gi, et = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, rt = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, it = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, nt = /[+-]=-?[.\d]+/, at = /[^,'"\[\]\s]+/gi, st = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, ot = {}, ut = { suppressEvents: !0, isStart: !0, kill: !1 }, ht = { suppressEvents: !0, kill: !1 }, lt = { suppressEvents: !0 }, ft = {}, ct = [], dt = {}, pt = {}, _t = {}, mt = 30, gt = [], vt = "", yt = function _merge(t, e) { for (var r in e) t[r] = e[r]; return t }, Tt = function _animationCycle(t, e) { var r = Math.floor(t /= e); return t && r === t ? r - 1 : r }, bt = function _isFromOrFromStart(t) { var e = t.data; return "isFromStart" === e || "isStart" === e }, wt = { _start: 0, endTime: T, totalDuration: T }, xt = function _parsePosition(t, e, i) { var n, a, s, o = t.labels, u = t._recent || wt, h = t.duration() >= U ? u.endTime(!1) : t._dur; return r(e) && (isNaN(e) || e in o) ? (a = e.charAt(0), s = "%" === e.substr(-1), n = e.indexOf("="), "<" === a || ">" === a ? (0 <= n && (e = e.replace(/=/, "")), ("<" === a ? u._start : u.endTime(0 <= u._repeat)) + (parseFloat(e.substr(1)) || 0) * (s ? (n < 0 ? u : i).totalDuration() / 100 : 1)) : n < 0 ? (e in o || (o[e] = h), o[e]) : (a = parseFloat(e.charAt(n - 1) + e.substr(n + 1)), s && i && (a = a / 100 * ($(i) ? i[0] : i).totalDuration()), 1 < n ? _parsePosition(t, e.substr(0, n - 1), i) + a : h + a)) : null == e ? h : +e }, kt = function _clamp(t, e, r) { return r < t ? t : e < r ? e : r }, Mt = [].slice, Ot = function toArray(t, e, i) { return l && !e && l.selector ? l.selector(t) : !r(t) || i || !n && zt() ? $(t) ? function _flatten(t, e, i) { return void 0 === i && (i = []), t.forEach(function (t) { return r(t) && !e || _a(t, 1) ? i.push.apply(i, Ot(t)) : i.push(t) }) || i }(t, i) : _a(t) ? Mt.call(t, 0) : t ? [t] : [] : Mt.call((e || a).querySelectorAll(t), 0) }, Pt = function mapRange(e, t, r, i, n) { var a = t - e, s = i - r; return Wa(n, function (t) { return r + ((t - e) / a * s || 0) }) }, Ct = function _callback(t, e, r) { var i, n, a, s = t.vars, o = s[e], u = l, h = t._ctx; if (o) return i = s[e + "Params"], n = s.callbackScope || t, r && ct.length && ma(), h && (l = h), a = i ? o.apply(n, i) : o.call(n), l = u, a }, At = 255, St = { aqua: [0, At, At], lime: [0, At, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, At], navy: [0, 0, 128], white: [At, At, At], olive: [128, 128, 0], yellow: [At, At, 0], orange: [At, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [At, 0, 0], pink: [At, 192, 203], cyan: [0, At, At], transparent: [At, At, At, 0] }, Rt = function () { var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b"; for (t in St) e += "|" + t + "\\b"; return new RegExp(e + ")", "gi") }(), Dt = /hsl[a]?\(/, Et = (M = Date.now, O = 500, C = 33, A = M(), D = A, z = E = 1e3 / 240, g = { time: 0, frame: 0, tick: function tick() { wl(!0) }, deltaRatio: function deltaRatio(t) { return b / (1e3 / (t || 60)) }, wake: function wake() { o && (!n && x() && (h = n = window, a = h.document || {}, ot.gsap = Ce, (h.gsapVersions || (h.gsapVersions = [])).push(Ce.version), P(i || h.GreenSockGlobals || !h.gsap && h || {}), m = h.requestAnimationFrame), p && g.sleep(), _ = m || function (t) { return setTimeout(t, z - 1e3 * g.time + 1 | 0) }, d = 1, wl(2)) }, sleep: function sleep() { (m ? h.cancelAnimationFrame : clearTimeout)(p), d = 0, _ = T }, lagSmoothing: function lagSmoothing(t, e) { O = t || 1e8, C = Math.min(e, O, 0) }, fps: function fps(t) { E = 1e3 / (t || 240), z = 1e3 * g.time + E }, add: function add(n, t, e) { var a = t ? function (t, e, r, i) { n(t, e, r, i), g.remove(a) } : n; return g.remove(n), F[e ? "unshift" : "push"](a), zt(), a }, remove: function remove(t, e) { ~(e = F.indexOf(t)) && F.splice(e, 1) && e <= k && k-- }, _listeners: F = [] }), zt = function _wake() { return !d && Et.wake() }, Ft = {}, It = /^[\d.\-M][\d.\-,\s]/, Bt = /["']/g, Lt = function _invertEase(e) { return function (t) { return 1 - e(1 - t) } }, Yt = function _parseEase(t, e) { return t && (s(t) ? t : Ft[t] || Nb(t)) || e }; function wl(t) { var e, r, i, n, a = M() - D, s = !0 === t; if (O < a && (A += a - C), (0 < (e = (i = (D += a) - A) - z) || s) && (n = ++g.frame, b = i - 1e3 * g.time, g.time = i /= 1e3, z += e + (E <= e ? 4 : E - e), r = 1), s || (p = _(wl)), r) for (k = 0; k < F.length; k++)F[k](i, b, n, t) } function en(t) { return t < N ? Y * t * t : t < .7272727272727273 ? Y * Math.pow(t - 1.5 / 2.75, 2) + .75 : t < .9090909090909092 ? Y * (t -= 2.25 / 2.75) * t + .9375 : Y * Math.pow(t - 2.625 / 2.75, 2) + .984375 } ha("Linear,Quad,Cubic,Quart,Quint,Strong", function (t, e) { var r = e < 5 ? e + 1 : e; Rb(t + ",Power" + (r - 1), e ? function (t) { return Math.pow(t, r) } : function (t) { return t }, function (t) { return 1 - Math.pow(1 - t, r) }, function (t) { return t < .5 ? Math.pow(2 * t, r) / 2 : 1 - Math.pow(2 * (1 - t), r) / 2 }) }), Ft.Linear.easeNone = Ft.none = Ft.Linear.easeIn, Rb("Elastic", Tb("in"), Tb("out"), Tb()), Y = 7.5625, N = 1 / 2.75, Rb("Bounce", function (t) { return 1 - en(1 - t) }, en), Rb("Expo", function (t) { return t ? Math.pow(2, 10 * (t - 1)) : 0 }), Rb("Circ", function (t) { return -(K(1 - t * t) - 1) }), Rb("Sine", function (t) { return 1 === t ? 1 : 1 - Z(t * X) }), Rb("Back", Ub("in"), Ub("out"), Ub()), Ft.SteppedEase = Ft.steps = ot.SteppedEase = { config: function config(t, e) { void 0 === t && (t = 1); var r = 1 / t, i = t + (e ? 0 : 1), n = e ? 1 : 0; return function (t) { return ((i * kt(0, .99999999, t) | 0) + n) * r } } }, q.ease = Ft["quad.out"], ha("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (t) { return vt += t + "," + t + "Params," }); var Nt, jt = function GSCache(t, e) { this.id = H++, (t._gsap = this).target = t, this.harness = e, this.get = e ? e.get : ga, this.set = e ? e.getSetter : re }, qt = ((Nt = Animation.prototype).delay = function delay(t) { return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay }, Nt.duration = function duration(t) { return arguments.length ? this.totalDuration(0 < this._repeat ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur }, Nt.totalDuration = function totalDuration(t) { return arguments.length ? (this._dirty = 0, Ra(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur }, Nt.totalTime = function totalTime(t, e) { if (zt(), !arguments.length) return this._tTime; var r = this._dp; if (r && r.smoothChildTiming && this._ts) { for (Ia(this, t), !r._dp || r.parent || Ja(r, this); r && r.parent;)r.parent._time !== r._start + (0 <= r._ts ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0), r = r.parent; !this.parent && this._dp.autoRemoveChildren && (0 < this._ts && t < this._tDur || this._ts < 0 && 0 < t || !this._tDur && !t) && Ka(this._dp, this, this._start - this._delay) } return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === V || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), na(this, t, e)), this }, Nt.time = function time(t, e) { return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Ea(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time }, Nt.totalProgress = function totalProgress(t, e) { return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio }, Nt.progress = function progress(t, e) { return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Ea(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio }, Nt.iteration = function iteration(t, e) { var r = this.duration() + this._rDelay; return arguments.length ? this.totalTime(this._time + (t - 1) * r, e) : this._repeat ? Tt(this._tTime, r) + 1 : 1 }, Nt.timeScale = function timeScale(t) { if (!arguments.length) return this._rts === -V ? 0 : this._rts; if (this._rts === t) return this; var e = this.parent && this._ts ? Ga(this.parent._time, this) : this._tTime; return this._rts = +t || 0, this._ts = this._ps || t === -V ? 0 : this._rts, this.totalTime(kt(-this._delay, this._tDur, e), !0), Ha(this), function _recacheAncestors(t) { for (var e = t.parent; e && e.parent;)e._dirty = 1, e.totalDuration(), e = e.parent; return t }(this) }, Nt.paused = function paused(t) { return arguments.length ? (this._ps !== t && ((this._ps = t) ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (zt(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== V && (this._tTime -= V)))), this) : this._ps }, Nt.startTime = function startTime(t) { if (arguments.length) { this._start = t; var e = this.parent || this._dp; return !e || !e._sort && this.parent || Ka(e, this, t - this._delay), this } return this._start }, Nt.endTime = function endTime(t) { return this._start + (w(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1) }, Nt.rawTime = function rawTime(t) { var e = this.parent || this._dp; return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Ga(e.rawTime(t), this) : this._tTime : this._tTime }, Nt.revert = function revert(t) { void 0 === t && (t = lt); var e = B; return B = t, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(t), this.totalTime(-.01, t.suppressEvents)), "nested" !== this.data && !1 !== t.kill && this.kill(), B = e, this }, Nt.globalTime = function globalTime(t) { for (var e = this, r = arguments.length ? t : e.rawTime(); e;)r = e._start + r / (e._ts || 1), e = e._dp; return !this.parent && this.vars.immediateRender ? -1 : r }, Nt.repeat = function repeat(t) { return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, Sa(this)) : -2 === this._repeat ? 1 / 0 : this._repeat }, Nt.repeatDelay = function repeatDelay(t) { if (arguments.length) { var e = this._time; return this._rDelay = t, Sa(this), e ? this.time(e) : this } return this._rDelay }, Nt.yoyo = function yoyo(t) { return arguments.length ? (this._yoyo = t, this) : this._yoyo }, Nt.seek = function seek(t, e) { return this.totalTime(xt(this, t), w(e)) }, Nt.restart = function restart(t, e) { return this.play().totalTime(t ? -this._delay : 0, w(e)) }, Nt.play = function play(t, e) { return null != t && this.seek(t, e), this.reversed(!1).paused(!1) }, Nt.reverse = function reverse(t, e) { return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1) }, Nt.pause = function pause(t, e) { return null != t && this.seek(t, e), this.paused(!0) }, Nt.resume = function resume() { return this.paused(!1) }, Nt.reversed = function reversed(t) { return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -V : 0)), this) : this._rts < 0 }, Nt.invalidate = function invalidate() { return this._initted = this._act = 0, this._zTime = -V, this }, Nt.isActive = function isActive() { var t, e = this.parent || this._dp, r = this._start; return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= r && t < this.endTime(!0) - V)) }, Nt.eventCallback = function eventCallback(t, e, r) { var i = this.vars; return 1 < arguments.length ? (e ? (i[t] = e, r && (i[t + "Params"] = r), "onUpdate" === t && (this._onUpdate = e)) : delete i[t], this) : i[t] }, Nt.then = function then(t) { var i = this; return new Promise(function (e) { function zo() { var t = i.then; i.then = null, s(r) && (r = r(i)) && (r.then || r === i) && (i.then = t), e(r), i.then = t } var r = s(t) ? t : pa; i._initted && 1 === i.totalProgress() && 0 <= i._ts || !i._tTime && i._ts < 0 ? zo() : i._prom = zo }) }, Nt.kill = function kill() { tb(this) }, Animation); function Animation(t) { this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Ra(this, +t.duration, 1, 1), this.data = t.data, l && (this._ctx = l).data.push(this), d || Et.wake() } qa(qt.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: !1, parent: null, _initted: !1, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -V, _prom: 0, _ps: !1, _rts: 1 }); var Ut = function (i) { function Timeline(t, e) { var r; return void 0 === t && (t = {}), (r = i.call(this, t) || this).labels = {}, r.smoothChildTiming = !!t.smoothChildTiming, r.autoRemoveChildren = !!t.autoRemoveChildren, r._sort = w(t.sortChildren), L && Ka(t.parent || L, _assertThisInitialized(r), e), t.reversed && r.reverse(), t.paused && r.paused(!0), t.scrollTrigger && La(_assertThisInitialized(r), t.scrollTrigger), r } _inheritsLoose(Timeline, i); var e = Timeline.prototype; return e.to = function to(t, e, r) { return Va(0, arguments, this), this }, e.from = function from(t, e, r) { return Va(1, arguments, this), this }, e.fromTo = function fromTo(t, e, r, i) { return Va(2, arguments, this), this }, e.set = function set(t, e, r) { return e.duration = 0, e.parent = this, va(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new Gt(t, e, xt(this, r), 1), this }, e.call = function call(t, e, r) { return Ka(this, Gt.delayedCall(0, t, e), r) }, e.staggerTo = function staggerTo(t, e, r, i, n, a, s) { return r.duration = e, r.stagger = r.stagger || i, r.onComplete = a, r.onCompleteParams = s, r.parent = this, new Gt(t, r, xt(this, n)), this }, e.staggerFrom = function staggerFrom(t, e, r, i, n, a, s) { return r.runBackwards = 1, va(r).immediateRender = w(r.immediateRender), this.staggerTo(t, e, r, i, n, a, s) }, e.staggerFromTo = function staggerFromTo(t, e, r, i, n, a, s, o) { return i.startAt = r, va(i).immediateRender = w(i.immediateRender), this.staggerTo(t, e, i, n, a, s, o) }, e.render = function render(t, e, r) { var i, n, a, s, o, u, h, l, f, c, d, p, _ = this._time, m = this._dirty ? this.totalDuration() : this._tDur, g = this._dur, v = t <= 0 ? 0 : ja(t), y = this._zTime < 0 != t < 0 && (this._initted || !g); if (this !== L && m < v && 0 <= t && (v = m), v !== this._tTime || r || y) { if (_ !== this._time && g && (v += this._time - _, t += this._time - _), i = v, f = this._start, u = !(l = this._ts), y && (g || (_ = this._zTime), !t && e || (this._zTime = t)), this._repeat) { if (d = this._yoyo, o = g + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * o + t, e, r); if (i = ja(v % o), v === m ? (s = this._repeat, i = g) : ((s = ~~(v / o)) && s === v / o && (i = g, s--), g < i && (i = g)), c = Tt(this._tTime, o), !_ && this._tTime && c !== s && (c = s), d && 1 & s && (i = g - i, p = 1), s !== c && !this._lock) { var T = d && 1 & c, b = T === (d && 1 & s); if (s < c && (T = !T), _ = T ? 0 : g, this._lock = 1, this.render(_ || (p ? 0 : ja(s * o)), e, !g)._lock = 0, this._tTime = v, !e && this.parent && Ct(this, "onRepeat"), this.vars.repeatRefresh && !p && (this.invalidate()._lock = 1), _ && _ !== this._time || u != !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this; if (g = this._dur, m = this._tDur, b && (this._lock = 2, _ = T ? g : -1e-4, this.render(_, !0), this.vars.repeatRefresh && !p && this.invalidate()), this._lock = 0, !this._ts && !u) return this; Pb(this, p) } } if (this._hasPause && !this._forcing && this._lock < 2 && (h = function _findNextPauseTween(t, e, r) { var i; if (e < r) for (i = t._first; i && i._start <= r;) { if ("isPause" === i.data && i._start > e) return i; i = i._next } else for (i = t._last; i && i._start >= r;) { if ("isPause" === i.data && i._start < e) return i; i = i._prev } }(this, ja(_), ja(i))) && (v -= i - (i = h._start)), this._tTime = v, this._time = i, this._act = !l, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t, _ = 0), !_ && i && !e && (Ct(this, "onStart"), this._tTime !== v)) return this; if (_ <= i && 0 <= t) for (n = this._first; n;) { if (a = n._next, (n._act || i >= n._start) && n._ts && h !== n) { if (n.parent !== this) return this.render(t, e, r); if (n.render(0 < n._ts ? (i - n._start) * n._ts : (n._dirty ? n.totalDuration() : n._tDur) + (i - n._start) * n._ts, e, r), i !== this._time || !this._ts && !u) { h = 0, a && (v += this._zTime = -V); break } } n = a } else { n = this._last; for (var w = t < 0 ? t : i; n;) { if (a = n._prev, (n._act || w <= n._end) && n._ts && h !== n) { if (n.parent !== this) return this.render(t, e, r); if (n.render(0 < n._ts ? (w - n._start) * n._ts : (n._dirty ? n.totalDuration() : n._tDur) + (w - n._start) * n._ts, e, r || B && (n._initted || n._startAt)), i !== this._time || !this._ts && !u) { h = 0, a && (v += this._zTime = w ? -V : V); break } } n = a } } if (h && !e && (this.pause(), h.render(_ <= i ? 0 : -V)._zTime = _ <= i ? 1 : -1, this._ts)) return this._start = f, Ha(this), this.render(t, e, r); this._onUpdate && !e && Ct(this, "onUpdate", !0), (v === m && this._tTime >= this.totalDuration() || !v && _) && (f !== this._start && Math.abs(l) === Math.abs(this._ts) || this._lock || (!t && g || !(v === m && 0 < this._ts || !v && this._ts < 0) || za(this, 1), e || t < 0 && !_ || !v && !_ && m || (Ct(this, v === m && 0 <= t ? "onComplete" : "onReverseComplete", !0), !this._prom || v < m && 0 < this.timeScale() || this._prom()))) } return this }, e.add = function add(e, i) { var n = this; if (t(i) || (i = xt(this, i, e)), !(e instanceof qt)) { if ($(e)) return e.forEach(function (t) { return n.add(t, i) }), this; if (r(e)) return this.addLabel(e, i); if (!s(e)) return this; e = Gt.delayedCall(0, e) } return this !== e ? Ka(this, e, i) : this }, e.getChildren = function getChildren(t, e, r, i) { void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === r && (r = !0), void 0 === i && (i = -U); for (var n = [], a = this._first; a;)a._start >= i && (a instanceof Gt ? e && n.push(a) : (r && n.push(a), t && n.push.apply(n, a.getChildren(!0, e, r)))), a = a._next; return n }, e.getById = function getById(t) { for (var e = this.getChildren(1, 1, 1), r = e.length; r--;)if (e[r].vars.id === t) return e[r] }, e.remove = function remove(t) { return r(t) ? this.removeLabel(t) : s(t) ? this.killTweensOf(t) : (ya(this, t), t === this._recent && (this._recent = this._last), Aa(this)) }, e.totalTime = function totalTime(t, e) { return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = ja(Et.time - (0 < this._ts ? t / this._ts : (this.totalDuration() - t) / -this._ts))), i.prototype.totalTime.call(this, t, e), this._forcing = 0, this) : this._tTime }, e.addLabel = function addLabel(t, e) { return this.labels[t] = xt(this, e), this }, e.removeLabel = function removeLabel(t) { return delete this.labels[t], this }, e.addPause = function addPause(t, e, r) { var i = Gt.delayedCall(0, e || T, r); return i.data = "isPause", this._hasPause = 1, Ka(this, i, xt(this, t)) }, e.removePause = function removePause(t) { var e = this._first; for (t = xt(this, t); e;)e._start === t && "isPause" === e.data && za(e), e = e._next }, e.killTweensOf = function killTweensOf(t, e, r) { for (var i = this.getTweensOf(t, r), n = i.length; n--;)Vt !== i[n] && i[n].kill(t, e); return this }, e.getTweensOf = function getTweensOf(e, r) { for (var i, n = [], a = Ot(e), s = this._first, o = t(r); s;)s instanceof Gt ? la(s._targets, a) && (o ? (!Vt || s._initted && s._ts) && s.globalTime(0) <= r && s.globalTime(s.totalDuration()) > r : !r || s.isActive()) && n.push(s) : (i = s.getTweensOf(a, r)).length && n.push.apply(n, i), s = s._next; return n }, e.tweenTo = function tweenTo(t, e) { e = e || {}; var r, i = this, n = xt(i, t), a = e.startAt, s = e.onStart, o = e.onStartParams, u = e.immediateRender, h = Gt.to(i, qa({ ease: e.ease || "none", lazy: !1, immediateRender: !1, time: n, overwrite: "auto", duration: e.duration || Math.abs((n - (a && "time" in a ? a.time : i._time)) / i.timeScale()) || V, onStart: function onStart() { if (i.pause(), !r) { var t = e.duration || Math.abs((n - (a && "time" in a ? a.time : i._time)) / i.timeScale()); h._dur !== t && Ra(h, t, 0, 1).render(h._time, !0, !0), r = 1 } s && s.apply(h, o || []) } }, e)); return u ? h.render(0) : h }, e.tweenFromTo = function tweenFromTo(t, e, r) { return this.tweenTo(e, qa({ startAt: { time: xt(this, t) } }, r)) }, e.recent = function recent() { return this._recent }, e.nextLabel = function nextLabel(t) { return void 0 === t && (t = this._time), rb(this, xt(this, t)) }, e.previousLabel = function previousLabel(t) { return void 0 === t && (t = this._time), rb(this, xt(this, t), 1) }, e.currentLabel = function currentLabel(t) { return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + V) }, e.shiftChildren = function shiftChildren(t, e, r) { void 0 === r && (r = 0); for (var i, n = this._first, a = this.labels; n;)n._start >= r && (n._start += t, n._end += t), n = n._next; if (e) for (i in a) a[i] >= r && (a[i] += t); return Aa(this) }, e.invalidate = function invalidate(t) { var e = this._first; for (this._lock = 0; e;)e.invalidate(t), e = e._next; return i.prototype.invalidate.call(this, t) }, e.clear = function clear(t) { void 0 === t && (t = !0); for (var e, r = this._first; r;)e = r._next, this.remove(r), r = e; return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), Aa(this) }, e.totalDuration = function totalDuration(t) { var e, r, i, n = 0, a = this, s = a._last, o = U; if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -t : t)); if (a._dirty) { for (i = a.parent; s;)e = s._prev, s._dirty && s.totalDuration(), o < (r = s._start) && a._sort && s._ts && !a._lock ? (a._lock = 1, Ka(a, s, r - s._delay, 1)._lock = 0) : o = r, r < 0 && s._ts && (n -= r, (!i && !a._dp || i && i.smoothChildTiming) && (a._start += r / a._ts, a._time -= r, a._tTime -= r), a.shiftChildren(-r, !1, -Infinity), o = 0), s._end > n && s._ts && (n = s._end), s = e; Ra(a, a === L && a._time > n ? a._time : n, 1, 1), a._dirty = 0 } return a._tDur }, Timeline.updateRoot = function updateRoot(t) { if (L._ts && (na(L, Ga(t, L)), f = Et.frame), Et.frame >= mt) { mt += j.autoSleep || 120; var e = L._first; if ((!e || !e._ts) && j.autoSleep && Et._listeners.length < 2) { for (; e && !e._ts;)e = e._next; e || Et.sleep() } } }, Timeline }(qt); qa(Ut.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 }); function _b(t, e, i, n, a, o) { var u, h, l, f; if (pt[t] && !1 !== (u = new pt[t]).init(a, u.rawVars ? e[t] : function _processVars(t, e, i, n, a) { if (s(t) && (t = Qt(t, a, e, i, n)), !v(t) || t.style && t.nodeType || $(t) || J(t)) return r(t) ? Qt(t, a, e, i, n) : t; var o, u = {}; for (o in t) u[o] = Qt(t[o], a, e, i, n); return u }(e[t], n, a, o, i), i, n, o) && (i._pt = h = new pe(i._pt, a, t, 0, 1, u.render, u, 0, u.priority), i !== c)) for (l = i._ptLookup[i._targets.indexOf(a)], f = u._props.length; f--;)l[u._props[f]] = h; return u } function fc(t, r, e, i) { var n, a, s = r.ease || i || "power1.inOut"; if ($(r)) a = e[t] || (e[t] = []), r.forEach(function (t, e) { return a.push({ t: e / (r.length - 1) * 100, v: t, e: s }) }); else for (n in r) a = e[n] || (e[n] = []), "ease" === n || a.push({ t: parseFloat(t), v: r[n], e: s }) } var Vt, Wt, Xt = function _addPropTween(t, e, i, n, a, o, u, h, l, f) { s(n) && (n = n(a || 0, t, o)); var c, d = t[e], p = "get" !== i ? i : s(d) ? l ? t[e.indexOf("set") || !s(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : d, _ = s(d) ? l ? ee : $t : Jt; if (r(n) && (~n.indexOf("random(") && (n = ob(n)), "=" === n.charAt(1) && (!(c = ka(p, n) + (Ya(p) || 0)) && 0 !== c || (n = c))), !f || p !== n || Wt) return isNaN(p * n) || "" === n ? (d || e in t || Q(e, n), function _addComplexStringPropTween(t, e, r, i, n, a, s) { var o, u, h, l, f, c, d, p, _ = new pe(this._pt, t, e, 0, 1, se, null, n), m = 0, g = 0; for (_.b = r, _.e = i, r += "", (d = ~(i += "").indexOf("random(")) && (i = ob(i)), a && (a(p = [r, i], t, e), r = p[0], i = p[1]), u = r.match(it) || []; o = it.exec(i);)l = o[0], f = i.substring(m, o.index), h ? h = (h + 1) % 5 : "rgba(" === f.substr(-5) && (h = 1), l !== u[g++] && (c = parseFloat(u[g - 1]) || 0, _._pt = { _next: _._pt, p: f || 1 === g ? f : ",", s: c, c: "=" === l.charAt(1) ? ka(c, l) - c : parseFloat(l) - c, m: h && h < 4 ? Math.round : 0 }, m = it.lastIndex); return _.c = m < i.length ? i.substring(m, i.length) : "", _.fp = s, (nt.test(i) || d) && (_.e = 0), this._pt = _ }.call(this, t, e, p, n, _, h || j.stringFilter, l)) : (c = new pe(this._pt, t, e, +p || 0, n - (p || 0), "boolean" == typeof d ? ae : ne, 0, _), l && (c.fp = l), u && c.modifier(u, this, t), this._pt = c) }, Ht = function _initTween(t, e, r) { var i, n, a, s, o, u, h, l, f, c, d, p, _, m = t.vars, g = m.ease, v = m.startAt, y = m.immediateRender, T = m.lazy, b = m.onUpdate, x = m.onUpdateParams, k = m.callbackScope, M = m.runBackwards, O = m.yoyoEase, P = m.keyframes, C = m.autoRevert, A = t._dur, S = t._startAt, R = t._targets, D = t.parent, E = D && "nested" === D.data ? D.vars.targets : R, z = "auto" === t._overwrite && !I, F = t.timeline; if (!F || P && g || (g = "none"), t._ease = Yt(g, q.ease), t._yEase = O ? Lt(Yt(!0 === O ? g : O, q.ease)) : 0, O && t._yoyo && !t._repeat && (O = t._yEase, t._yEase = t._ease, t._ease = O), t._from = !F && !!m.runBackwards, !F || P && !m.stagger) { if (p = (l = R[0] ? fa(R[0]).harness : 0) && m[l.prop], i = ua(m, ft), S && (S._zTime < 0 && S.progress(1), e < 0 && M && y && !C ? S.render(-1, !0) : S.revert(M && A ? ht : ut), S._lazy = 0), v) { if (za(t._startAt = Gt.set(R, qa({ data: "isStart", overwrite: !1, parent: D, immediateRender: !0, lazy: w(T), startAt: null, delay: 0, onUpdate: b, onUpdateParams: x, callbackScope: k, stagger: 0 }, v))), e < (t._startAt._dp = 0) && (B || !y && !C) && t._startAt.revert(ht), y && A && e <= 0 && r <= 0) return void (e && (t._zTime = e)) } else if (M && A && !S) if (e && (y = !1), a = qa({ overwrite: !1, data: "isFromStart", lazy: y && w(T), immediateRender: y, stagger: 0, parent: D }, i), p && (a[l.prop] = p), za(t._startAt = Gt.set(R, a)), e < (t._startAt._dp = 0) && (B ? t._startAt.revert(ht) : t._startAt.render(-1, !0)), t._zTime = e, y) { if (!e) return } else _initTween(t._startAt, V, V); for (t._pt = t._ptCache = 0, T = A && w(T) || T && !A, n = 0; n < R.length; n++) { if (h = (o = R[n])._gsap || ea(R)[n]._gsap, t._ptLookup[n] = c = {}, dt[h.id] && ct.length && ma(), d = E === R ? n : E.indexOf(o), l && !1 !== (f = new l).init(o, p || i, t, d, E) && (t._pt = s = new pe(t._pt, o, f.name, 0, 1, f.render, f, 0, f.priority), f._props.forEach(function (t) { c[t] = s }), f.priority && (u = 1)), !l || p) for (a in i) pt[a] && (f = _b(a, i, t, d, o, E)) ? f.priority && (u = 1) : c[a] = s = Xt.call(t, o, a, "get", i[a], d, E, 0, m.stringFilter); t._op && t._op[n] && t.kill(o, t._op[n]), z && t._pt && (Vt = t, L.killTweensOf(o, c, t.globalTime(e)), _ = !t.parent, Vt = 0), t._pt && T && (dt[h.id] = 1) } u && de(t), t._onInit && t._onInit(t) } t._onUpdate = b, t._initted = (!t._op || t._pt) && !_, P && e <= 0 && F.render(U, !0, !0) }, Qt = function _parseFuncOrString(t, e, i, n, a) { return s(t) ? t.call(e, i, n, a) : r(t) && ~t.indexOf("random(") ? ob(t) : t }, Kt = vt + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", Zt = {}; ha(Kt + ",id,stagger,delay,duration,paused,scrollTrigger", function (t) { return Zt[t] = 1 }); var Gt = function (z) { function Tween(e, r, i, n) { var a; "number" == typeof r && (i.duration = r, r = i, i = null); var s, o, u, h, l, f, c, d, p = (a = z.call(this, n ? r : va(r)) || this).vars, _ = p.duration, m = p.delay, g = p.immediateRender, T = p.stagger, b = p.overwrite, x = p.keyframes, k = p.defaults, M = p.scrollTrigger, O = p.yoyoEase, P = r.parent || L, C = ($(e) || J(e) ? t(e[0]) : "length" in r) ? [e] : Ot(e); if (a._targets = C.length ? ea(C) : R("GSAP target " + e + " not found. https://greensock.com", !j.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = b, x || T || y(_) || y(m)) { if (r = a.vars, (s = a.timeline = new Ut({ data: "nested", defaults: k || {}, targets: P && "nested" === P.data ? P.vars.targets : C })).kill(), s.parent = s._dp = _assertThisInitialized(a), s._start = 0, T || y(_) || y(m)) { if (h = C.length, c = T && eb(T), v(T)) for (l in T) ~Kt.indexOf(l) && ((d = d || {})[l] = T[l]); for (o = 0; o < h; o++)(u = ua(r, Zt)).stagger = 0, O && (u.yoyoEase = O), d && yt(u, d), f = C[o], u.duration = +Qt(_, _assertThisInitialized(a), o, f, C), u.delay = (+Qt(m, _assertThisInitialized(a), o, f, C) || 0) - a._delay, !T && 1 === h && u.delay && (a._delay = m = u.delay, a._start += m, u.delay = 0), s.to(f, u, c ? c(o, f, C) : 0), s._ease = Ft.none; s.duration() ? _ = m = 0 : a.timeline = 0 } else if (x) { va(qa(s.vars.defaults, { ease: "none" })), s._ease = Yt(x.ease || r.ease || "none"); var A, S, D, E = 0; if ($(x)) x.forEach(function (t) { return s.to(C, t, ">") }), s.duration(); else { for (l in u = {}, x) "ease" === l || "easeEach" === l || fc(l, x[l], u, x.easeEach); for (l in u) for (A = u[l].sort(function (t, e) { return t.t - e.t }), o = E = 0; o < A.length; o++)(D = { ease: (S = A[o]).e, duration: (S.t - (o ? A[o - 1].t : 0)) / 100 * _ })[l] = S.v, s.to(C, D, E), E += D.duration; s.duration() < _ && s.to({}, { duration: _ - s.duration() }) } } _ || a.duration(_ = s.duration()) } else a.timeline = 0; return !0 !== b || I || (Vt = _assertThisInitialized(a), L.killTweensOf(C), Vt = 0), Ka(P, _assertThisInitialized(a), i), r.reversed && a.reverse(), r.paused && a.paused(!0), (g || !_ && !x && a._start === ja(P._time) && w(g) && function _hasNoPausedAncestors(t) { return !t || t._ts && _hasNoPausedAncestors(t.parent) }(_assertThisInitialized(a)) && "nested" !== P.data) && (a._tTime = -V, a.render(Math.max(0, -m) || 0)), M && La(_assertThisInitialized(a), M), a } _inheritsLoose(Tween, z); var e = Tween.prototype; return e.render = function render(t, e, r) { var i, n, a, s, o, u, h, l, f, c = this._time, d = this._tDur, p = this._dur, _ = t < 0, m = d - V < t && !_ ? d : t < V ? 0 : t; if (p) { if (m !== this._tTime || !t || r || !this._initted && this._tTime || this._startAt && this._zTime < 0 != _) { if (i = m, l = this.timeline, this._repeat) { if (s = p + this._rDelay, this._repeat < -1 && _) return this.totalTime(100 * s + t, e, r); if (i = ja(m % s), m === d ? (a = this._repeat, i = p) : ((a = ~~(m / s)) && a === m / s && (i = p, a--), p < i && (i = p)), (u = this._yoyo && 1 & a) && (f = this._yEase, i = p - i), o = Tt(this._tTime, s), i === c && !r && this._initted) return this._tTime = m, this; a !== o && (l && this._yEase && Pb(l, u), !this.vars.repeatRefresh || u || this._lock || (this._lock = r = 1, this.render(ja(s * a), !0).invalidate()._lock = 0)) } if (!this._initted) { if (Ma(this, _ ? t : i, r, e, m)) return this._tTime = 0, this; if (c !== this._time) return this; if (p !== this._dur) return this.render(t, e, r) } if (this._tTime = m, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = h = (f || this._ease)(i / p), this._from && (this.ratio = h = 1 - h), i && !c && !e && (Ct(this, "onStart"), this._tTime !== m)) return this; for (n = this._pt; n;)n.r(h, n.d), n = n._next; l && l.render(t < 0 ? t : !i && u ? -V : l._dur * l._ease(i / this._dur), e, r) || this._startAt && (this._zTime = t), this._onUpdate && !e && (_ && Ca(this, t, 0, r), Ct(this, "onUpdate")), this._repeat && a !== o && this.vars.onRepeat && !e && this.parent && Ct(this, "onRepeat"), m !== this._tDur && m || this._tTime !== m || (_ && !this._onUpdate && Ca(this, t, 0, !0), !t && p || !(m === this._tDur && 0 < this._ts || !m && this._ts < 0) || za(this, 1), e || _ && !c || !(m || c || u) || (Ct(this, m === d ? "onComplete" : "onReverseComplete", !0), !this._prom || m < d && 0 < this.timeScale() || this._prom())) } } else !function _renderZeroDurationTween(t, e, r, i) { var n, a, s, o = t.ratio, u = e < 0 || !e && (!t._start && function _parentPlayheadIsBeforeStart(t) { var e = t.parent; return e && e._ts && e._initted && !e._lock && (e.rawTime() < 0 || _parentPlayheadIsBeforeStart(e)) }(t) && (t._initted || !bt(t)) || (t._ts < 0 || t._dp._ts < 0) && !bt(t)) ? 0 : 1, h = t._rDelay, l = 0; if (h && t._repeat && (l = kt(0, t._tDur, e), a = Tt(l, h), t._yoyo && 1 & a && (u = 1 - u), a !== Tt(t._tTime, h) && (o = 1 - u, t.vars.repeatRefresh && t._initted && t.invalidate())), u !== o || B || i || t._zTime === V || !e && t._zTime) { if (!t._initted && Ma(t, e, i, r, l)) return; for (s = t._zTime, t._zTime = e || (r ? V : 0), r = r || e && !s, t.ratio = u, t._from && (u = 1 - u), t._time = 0, t._tTime = l, n = t._pt; n;)n.r(u, n.d), n = n._next; e < 0 && Ca(t, e, 0, !0), t._onUpdate && !r && Ct(t, "onUpdate"), l && t._repeat && !r && t.parent && Ct(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === u && (u && za(t, 1), r || B || (Ct(t, u ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom())) } else t._zTime || (t._zTime = e) }(this, t, e, r); return this }, e.targets = function targets() { return this._targets }, e.invalidate = function invalidate(t) { return t && this.vars.runBackwards || (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(t), z.prototype.invalidate.call(this, t) }, e.resetTo = function resetTo(t, e, r, i) { d || Et.wake(), this._ts || this.play(); var n, a = Math.min(this._dur, (this._dp._time - this._start) * this._ts); return this._initted || Ht(this, a), n = this._ease(a / this._dur), function _updatePropTweens(t, e, r, i, n, a, s) { var o, u, h, l, f = (t._pt && t._ptCache || (t._ptCache = {}))[e]; if (!f) for (f = t._ptCache[e] = [], h = t._ptLookup, l = t._targets.length; l--;) { if ((o = h[l][e]) && o.d && o.d._pt) for (o = o.d._pt; o && o.p !== e && o.fp !== e;)o = o._next; if (!o) return Wt = 1, t.vars[e] = "+=0", Ht(t, s), Wt = 0, 1; f.push(o) } for (l = f.length; l--;)(o = (u = f[l])._pt || u).s = !i && 0 !== i || n ? o.s + (i || 0) + a * o.c : i, o.c = r - o.s, u.e && (u.e = ia(r) + Ya(u.e)), u.b && (u.b = o.s + Ya(u.b)) }(this, t, e, r, i, n, a) ? this.resetTo(t, e, r, i) : (Ia(this, 0), this.parent || xa(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0)) }, e.kill = function kill(t, e) { if (void 0 === e && (e = "all"), !(t || e && "all" !== e)) return this._lazy = this._pt = 0, this.parent ? tb(this) : this; if (this.timeline) { var i = this.timeline.totalDuration(); return this.timeline.killTweensOf(t, e, Vt && !0 !== Vt.vars.overwrite)._first || tb(this), this.parent && i !== this.timeline.totalDuration() && Ra(this, this._dur * this.timeline._tDur / i, 0, 1), this } var n, a, s, o, u, h, l, f = this._targets, c = t ? Ot(t) : f, d = this._ptLookup, p = this._pt; if ((!e || "all" === e) && function _arraysMatch(t, e) { for (var r = t.length, i = r === e.length; i && r-- && t[r] === e[r];); return r < 0 }(f, c)) return "all" === e && (this._pt = 0), tb(this); for (n = this._op = this._op || [], "all" !== e && (r(e) && (u = {}, ha(e, function (t) { return u[t] = 1 }), e = u), e = function _addAliasesToVars(t, e) { var r, i, n, a, s = t[0] ? fa(t[0]).harness : 0, o = s && s.aliases; if (!o) return e; for (i in r = yt({}, e), o) if (i in r) for (n = (a = o[i].split(",")).length; n--;)r[a[n]] = r[i]; return r }(f, e)), l = f.length; l--;)if (~c.indexOf(f[l])) for (u in a = d[l], "all" === e ? (n[l] = e, o = a, s = {}) : (s = n[l] = n[l] || {}, o = e), o) (h = a && a[u]) && ("kill" in h.d && !0 !== h.d.kill(u) || ya(this, h, "_pt"), delete a[u]), "all" !== s && (s[u] = 1); return this._initted && !this._pt && p && tb(this), this }, Tween.to = function to(t, e, r) { return new Tween(t, e, r) }, Tween.from = function from(t, e) { return Va(1, arguments) }, Tween.delayedCall = function delayedCall(t, e, r, i) { return new Tween(e, 0, { immediateRender: !1, lazy: !1, overwrite: !1, delay: t, onComplete: e, onReverseComplete: e, onCompleteParams: r, onReverseCompleteParams: r, callbackScope: i }) }, Tween.fromTo = function fromTo(t, e, r) { return Va(2, arguments) }, Tween.set = function set(t, e) { return e.duration = 0, e.repeatDelay || (e.repeat = 0), new Tween(t, e) }, Tween.killTweensOf = function killTweensOf(t, e, r) { return L.killTweensOf(t, e, r) }, Tween }(qt); qa(Gt.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }), ha("staggerTo,staggerFrom,staggerFromTo", function (r) { Gt[r] = function () { var t = new Ut, e = Mt.call(arguments, 0); return e.splice("staggerFromTo" === r ? 5 : 4, 0, 0), t[r].apply(t, e) } }); function nc(t, e, r) { return t.setAttribute(e, r) } function vc(t, e, r, i) { i.mSet(t, e, i.m.call(i.tween, r, i.mt), i) } var Jt = function _setterPlain(t, e, r) { return t[e] = r }, $t = function _setterFunc(t, e, r) { return t[e](r) }, ee = function _setterFuncWithParam(t, e, r, i) { return t[e](i.fp, r) }, re = function _getSetter(t, e) { return s(t[e]) ? $t : u(t[e]) && t.setAttribute ? nc : Jt }, ne = function _renderPlain(t, e) { return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e) }, ae = function _renderBoolean(t, e) { return e.set(e.t, e.p, !!(e.s + e.c * t), e) }, se = function _renderComplexString(t, e) { var r = e._pt, i = ""; if (!t && e.b) i = e.b; else if (1 === t && e.e) i = e.e; else { for (; r;)i = r.p + (r.m ? r.m(r.s + r.c * t) : Math.round(1e4 * (r.s + r.c * t)) / 1e4) + i, r = r._next; i += e.c } e.set(e.t, e.p, i, e) }, oe = function _renderPropTweens(t, e) { for (var r = e._pt; r;)r.r(t, r.d), r = r._next }, le = function _addPluginModifier(t, e, r, i) { for (var n, a = this._pt; a;)n = a._next, a.p === i && a.modifier(t, e, r), a = n }, fe = function _killPropTweensOf(t) { for (var e, r, i = this._pt; i;)r = i._next, i.p === t && !i.op || i.op === t ? ya(this, i, "_pt") : i.dep || (e = 1), i = r; return !e }, de = function _sortPropTweensByPriority(t) { for (var e, r, i, n, a = t._pt; a;) { for (e = a._next, r = i; r && r.pr > a.pr;)r = r._next; (a._prev = r ? r._prev : n) ? a._prev._next = a : i = a, (a._next = r) ? r._prev = a : n = a, a = e } t._pt = i }, pe = (PropTween.prototype.modifier = function modifier(t, e, r) { this.mSet = this.mSet || this.set, this.set = vc, this.m = t, this.mt = r, this.tween = e }, PropTween); function PropTween(t, e, r, i, n, a, s, o, u) { this.t = e, this.s = i, this.c = n, this.p = r, this.r = a || ne, this.d = s || this, this.set = o || Jt, this.pr = u || 0, (this._next = t) && (t._prev = this) } ha(vt + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (t) { return ft[t] = 1 }), ot.TweenMax = ot.TweenLite = Gt, ot.TimelineLite = ot.TimelineMax = Ut, L = new Ut({ sortChildren: !1, defaults: q, autoRemoveChildren: !0, id: "root", smoothChildTiming: !0 }), j.stringFilter = Eb; function Cc(t) { return (Te[t] || we).map(function (t) { return t() }) } function Dc() { var t = Date.now(), o = []; 2 < t - xe && (Cc("matchMediaInit"), ye.forEach(function (t) { var e, r, i, n, a = t.queries, s = t.conditions; for (r in a) (e = h.matchMedia(a[r]).matches) && (i = 1), e !== s[r] && (s[r] = e, n = 1); n && (t.revert(), i && o.push(t)) }), Cc("matchMediaRevert"), o.forEach(function (t) { return t.onMatch(t) }), xe = t, Cc("matchMedia")) } var _e, ye = [], Te = {}, we = [], xe = 0, ke = ((_e = Context.prototype).add = function add(t, i, n) { function Cw() { var t, e = l, r = a.selector; return e && e !== a && e.data.push(a), n && (a.selector = cb(n)), l = a, t = i.apply(a, arguments), s(t) && a._r.push(t), l = e, a.selector = r, a.isReverted = !1, t } s(t) && (n = i, i = t, t = s); var a = this; return a.last = Cw, t === s ? Cw(a) : t ? a[t] = Cw : Cw }, _e.ignore = function ignore(t) { var e = l; l = null, t(this), l = e }, _e.getTweens = function getTweens() { var e = []; return this.data.forEach(function (t) { return t instanceof Context ? e.push.apply(e, t.getTweens()) : t instanceof Gt && !(t.parent && "nested" === t.parent.data) && e.push(t) }), e }, _e.clear = function clear() { this._r.length = this.data.length = 0 }, _e.kill = function kill(e, t) { var r = this; if (e) { var i = this.getTweens(); this.data.forEach(function (t) { "isFlip" === t.data && (t.revert(), t.getChildren(!0, !0, !1).forEach(function (t) { return i.splice(i.indexOf(t), 1) })) }), i.map(function (t) { return { g: t.globalTime(0), t: t } }).sort(function (t, e) { return e.g - t.g || -1 }).forEach(function (t) { return t.t.revert(e) }), this.data.forEach(function (t) { return !(t instanceof qt) && t.revert && t.revert(e) }), this._r.forEach(function (t) { return t(e, r) }), this.isReverted = !0 } else this.data.forEach(function (t) { return t.kill && t.kill() }); if (this.clear(), t) { var n = ye.indexOf(this); ~n && ye.splice(n, 1) } }, _e.revert = function revert(t) { this.kill(t || {}) }, Context); function Context(t, e) { this.selector = e && cb(e), this.data = [], this._r = [], this.isReverted = !1, t && this.add(t) } var Me, Oe = ((Me = MatchMedia.prototype).add = function add(t, e, r) { v(t) || (t = { matches: t }); var i, n, a, s = new ke(0, r || this.scope), o = s.conditions = {}; for (n in this.contexts.push(s), e = s.add("onMatch", e), s.queries = t) "all" === n ? a = 1 : (i = h.matchMedia(t[n])) && (ye.indexOf(s) < 0 && ye.push(s), (o[n] = i.matches) && (a = 1), i.addListener ? i.addListener(Dc) : i.addEventListener("change", Dc)); return a && e(s), this }, Me.revert = function revert(t) { this.kill(t || {}) }, Me.kill = function kill(e) { this.contexts.forEach(function (t) { return t.kill(e, !0) }) }, MatchMedia); function MatchMedia(t) { this.contexts = [], this.scope = t } var Pe = { registerPlugin: function registerPlugin() { for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)e[r] = arguments[r]; e.forEach(function (t) { return function _createPlugin(t) { var e = (t = !t.name && t.default || t).name, r = s(t), i = e && !r && t.init ? function () { this._props = [] } : t, n = { init: T, render: oe, add: Xt, kill: fe, modifier: le, rawVars: 0 }, a = { targetTest: 0, get: 0, getSetter: re, aliases: {}, register: 0 }; if (zt(), t !== i) { if (pt[e]) return; qa(i, qa(ua(t, n), a)), yt(i.prototype, yt(n, ua(t, a))), pt[i.prop = e] = i, t.targetTest && (gt.push(i), ft[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin" } S(e, i), t.register && t.register(Ce, i, pe) }(t) }) }, timeline: function timeline(t) { return new Ut(t) }, getTweensOf: function getTweensOf(t, e) { return L.getTweensOf(t, e) }, getProperty: function getProperty(i, t, e, n) { r(i) && (i = Ot(i)[0]); var a = fa(i || {}).get, s = e ? pa : oa; return "native" === e && (e = ""), i ? t ? s((pt[t] && pt[t].get || a)(i, t, e, n)) : function (t, e, r) { return s((pt[t] && pt[t].get || a)(i, t, e, r)) } : i }, quickSetter: function quickSetter(r, e, i) { if (1 < (r = Ot(r)).length) { var n = r.map(function (t) { return Ce.quickSetter(t, e, i) }), a = n.length; return function (t) { for (var e = a; e--;)n[e](t) } } r = r[0] || {}; var s = pt[e], o = fa(r), u = o.harness && (o.harness.aliases || {})[e] || e, h = s ? function (t) { var e = new s; c._pt = 0, e.init(r, i ? t + i : t, c, 0, [r]), e.render(1, e), c._pt && oe(1, c) } : o.set(r, u); return s ? h : function (t) { return h(r, u, i ? t + i : t, o, 1) } }, quickTo: function quickTo(t, i, e) { function Ux(t, e, r) { return n.resetTo(i, t, e, r) } var r, n = Ce.to(t, yt(((r = {})[i] = "+=0.1", r.paused = !0, r), e || {})); return Ux.tween = n, Ux }, isTweening: function isTweening(t) { return 0 < L.getTweensOf(t, !0).length }, defaults: function defaults(t) { return t && t.ease && (t.ease = Yt(t.ease, q.ease)), ta(q, t || {}) }, config: function config(t) { return ta(j, t || {}) }, registerEffect: function registerEffect(t) { var i = t.name, n = t.effect, e = t.plugins, a = t.defaults, r = t.extendTimeline; (e || "").split(",").forEach(function (t) { return t && !pt[t] && !ot[t] && R(i + " effect requires " + t + " plugin.") }), _t[i] = function (t, e, r) { return n(Ot(t), qa(e || {}, a), r) }, r && (Ut.prototype[i] = function (t, e, r) { return this.add(_t[i](t, v(e) ? e : (r = e) && {}, this), r) }) }, registerEase: function registerEase(t, e) { Ft[t] = Yt(e) }, parseEase: function parseEase(t, e) { return arguments.length ? Yt(t, e) : Ft }, getById: function getById(t) { return L.getById(t) }, exportRoot: function exportRoot(t, e) { void 0 === t && (t = {}); var r, i, n = new Ut(t); for (n.smoothChildTiming = w(t.smoothChildTiming), L.remove(n), n._dp = 0, n._time = n._tTime = L._time, r = L._first; r;)i = r._next, !e && !r._dur && r instanceof Gt && r.vars.onComplete === r._targets[0] || Ka(n, r, r._start - r._delay), r = i; return Ka(L, n, 0), n }, context: function context(t, e) { return t ? new ke(t, e) : l }, matchMedia: function matchMedia(t) { return new Oe(t) }, matchMediaRefresh: function matchMediaRefresh() { return ye.forEach(function (t) { var e, r, i = t.conditions; for (r in i) i[r] && (i[r] = !1, e = 1); e && t.revert() }) || Dc() }, addEventListener: function addEventListener(t, e) { var r = Te[t] || (Te[t] = []); ~r.indexOf(e) || r.push(e) }, removeEventListener: function removeEventListener(t, e) { var r = Te[t], i = r && r.indexOf(e); 0 <= i && r.splice(i, 1) }, utils: { wrap: function wrap(e, t, r) { var i = t - e; return $(e) ? lb(e, wrap(0, e.length), t) : Wa(r, function (t) { return (i + (t - e) % i) % i + e }) }, wrapYoyo: function wrapYoyo(e, t, r) { var i = t - e, n = 2 * i; return $(e) ? lb(e, wrapYoyo(0, e.length - 1), t) : Wa(r, function (t) { return e + (i < (t = (n + (t - e) % n) % n || 0) ? n - t : t) }) }, distribute: eb, random: hb, snap: gb, normalize: function normalize(t, e, r) { return Pt(t, e, 0, 1, r) }, getUnit: Ya, clamp: function clamp(e, r, t) { return Wa(t, function (t) { return kt(e, r, t) }) }, splitColor: zb, toArray: Ot, selector: cb, mapRange: Pt, pipe: function pipe() { for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)e[r] = arguments[r]; return function (t) { return e.reduce(function (t, e) { return e(t) }, t) } }, unitize: function unitize(e, r) { return function (t) { return e(parseFloat(t)) + (r || Ya(t)) } }, interpolate: function interpolate(e, i, t, n) { var a = isNaN(e + i) ? 0 : function (t) { return (1 - t) * e + t * i }; if (!a) { var s, o, u, h, l, f = r(e), c = {}; if (!0 === t && (n = 1) && (t = null), f) e = { p: e }, i = { p: i }; else if ($(e) && !$(i)) { for (u = [], h = e.length, l = h - 2, o = 1; o < h; o++)u.push(interpolate(e[o - 1], e[o])); h--, a = function func(t) { t *= h; var e = Math.min(l, ~~t); return u[e](t - e) }, t = i } else n || (e = yt($(e) ? [] : {}, e)); if (!u) { for (s in i) Xt.call(c, e, s, "get", i[s]); a = function func(t) { return oe(t, c) || (f ? e.p : e) } } } return Wa(t, a) }, shuffle: db }, install: P, effects: _t, ticker: Et, updateRoot: Ut.updateRoot, plugins: pt, globalTimeline: L, core: { PropTween: pe, globals: S, Tween: Gt, Timeline: Ut, Animation: qt, getCache: fa, _removeLinkedListItem: ya, reverting: function reverting() { return B }, context: function context(t) { return t && l && (l.data.push(t), t._ctx = l), l }, suppressOverwrites: function suppressOverwrites(t) { return I = t } } }; ha("to,from,fromTo,delayedCall,set,killTweensOf", function (t) { return Pe[t] = Gt[t] }), Et.add(Ut.updateRoot), c = Pe.to({}, { duration: 0 }); function Hc(t, e) { for (var r = t._pt; r && r.p !== e && r.op !== e && r.fp !== e;)r = r._next; return r } function Jc(t, a) { return { name: t, rawVars: 1, init: function init(t, n, e) { e._onInit = function (t) { var e, i; if (r(n) && (e = {}, ha(n, function (t) { return e[t] = 1 }), n = e), a) { for (i in e = {}, n) e[i] = a(n[i]); n = e } !function _addModifiers(t, e) { var r, i, n, a = t._targets; for (r in e) for (i = a.length; i--;)(n = (n = t._ptLookup[i][r]) && n.d) && (n._pt && (n = Hc(n, r)), n && n.modifier && n.modifier(e[r], t, a[i], r)) }(t, n) } } } } var Ce = Pe.registerPlugin({ name: "attr", init: function init(t, e, r, i, n) { var a, s, o; for (a in this.tween = r, e) o = t.getAttribute(a) || "", (s = this.add(t, "setAttribute", (o || 0) + "", e[a], i, n, 0, 0, a)).op = a, s.b = o, this._props.push(a) }, render: function render(t, e) { for (var r = e._pt; r;)B ? r.set(r.t, r.p, r.b, r) : r.r(t, r.d), r = r._next } }, { name: "endArray", init: function init(t, e) { for (var r = e.length; r--;)this.add(t, r, t[r] || 0, e[r], 0, 0, 0, 0, 0, 1) } }, Jc("roundProps", fb), Jc("modifiers"), Jc("snap", gb)) || Pe; Gt.version = Ut.version = Ce.version = "3.11.3", o = 1, x() && zt(); function td(t, e) { return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e) } function ud(t, e) { return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e) } function vd(t, e) { return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e) } function wd(t, e) { var r = e.s + e.c * t; e.set(e.t, e.p, ~~(r + (r < 0 ? -.5 : .5)) + e.u, e) } function xd(t, e) { return e.set(e.t, e.p, t ? e.e : e.b, e) } function yd(t, e) { return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e) } function zd(t, e, r) { return t.style[e] = r } function Ad(t, e, r) { return t.style.setProperty(e, r) } function Bd(t, e, r) { return t._gsap[e] = r } function Cd(t, e, r) { return t._gsap.scaleX = t._gsap.scaleY = r } function Dd(t, e, r, i, n) { var a = t._gsap; a.scaleX = a.scaleY = r, a.renderTransform(n, a) } function Ed(t, e, r, i, n) { var a = t._gsap; a[e] = r, a.renderTransform(n, a) } function Hd(t, e) { var r = this, i = this.target, n = i.style; if (t in rr) { if (this.tfm = this.tfm || {}, "transform" !== t && (~(t = hr[t] || t).indexOf(",") ? t.split(",").forEach(function (t) { return r.tfm[t] = mr(i, t) }) : this.tfm[t] = i._gsap.x ? i._gsap[t] : mr(i, t)), 0 <= this.props.indexOf(lr)) return; i._gsap.svg && (this.svgo = i.getAttribute("data-svg-origin"), this.props.push(fr, e, "")), t = lr } (n || e) && this.props.push(t, e, n[t]) } function Id(t) { t.translate && (t.removeProperty("translate"), t.removeProperty("scale"), t.removeProperty("rotate")) } function Jd() { var t, e, r = this.props, i = this.target, n = i.style, a = i._gsap; for (t = 0; t < r.length; t += 3)r[t + 1] ? i[r[t]] = r[t + 2] : r[t + 2] ? n[r[t]] = r[t + 2] : n.removeProperty(r[t].replace(sr, "-$1").toLowerCase()); if (this.tfm) { for (e in this.tfm) a[e] = this.tfm[e]; a.svg && (a.renderTransform(), i.setAttribute("data-svg-origin", this.svgo || "")), !(t = Fe()) || t.isStart || n[lr] || (Id(n), a.uncache = 1) } } function Kd(t, e) { var r = { target: t, props: [], revert: Jd, save: Hd }; return e && e.split(",").forEach(function (t) { return r.save(t) }), r } function Md(t, e) { var r = Se.createElementNS ? Se.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : Se.createElement(t); return r.style ? r : Se.createElement(t) } function Nd(t, e, r) { var i = getComputedStyle(t); return i[e] || i.getPropertyValue(e.replace(sr, "-$1").toLowerCase()) || i.getPropertyValue(e) || !r && Nd(t, dr(e) || e, 1) || "" } function Qd() { (function _windowExists() { return "undefined" != typeof window })() && window.document && (Ae = window, Se = Ae.document, Re = Se.documentElement, Ee = Md("div") || { style: {} }, Md("div"), lr = dr(lr), fr = lr + "Origin", Ee.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Ie = !!dr("perspective"), Fe = Ce.core.reverting, De = 1) } function Rd(t) { var e, r = Md("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = this.parentNode, n = this.nextSibling, a = this.style.cssText; if (Re.appendChild(r), r.appendChild(this), this.style.display = "block", t) try { e = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = Rd } catch (t) { } else this._gsapBBox && (e = this._gsapBBox()); return i && (n ? i.insertBefore(this, n) : i.appendChild(this)), Re.removeChild(r), this.style.cssText = a, e } function Sd(t, e) { for (var r = e.length; r--;)if (t.hasAttribute(e[r])) return t.getAttribute(e[r]) } function Td(e) { var r; try { r = e.getBBox() } catch (t) { r = Rd.call(e, !0) } return r && (r.width || r.height) || e.getBBox === Rd || (r = Rd.call(e, !0)), !r || r.width || r.x || r.y ? r : { x: +Sd(e, ["x", "cx", "x1"]) || 0, y: +Sd(e, ["y", "cy", "y1"]) || 0, width: 0, height: 0 } } function Ud(t) { return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !Td(t)) } function Vd(t, e) { if (e) { var r = t.style; e in rr && e !== fr && (e = lr), r.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), r.removeProperty(e.replace(sr, "-$1").toLowerCase())) : r.removeAttribute(e) } } function Wd(t, e, r, i, n, a) { var s = new pe(t._pt, e, r, 0, 1, a ? yd : xd); return (t._pt = s).b = i, s.e = n, t._props.push(r), s } function Zd(t, e, r, i) { var n, a, s, o, u = parseFloat(r) || 0, h = (r + "").trim().substr((u + "").length) || "px", l = Ee.style, f = or.test(e), c = "svg" === t.tagName.toLowerCase(), d = (c ? "client" : "offset") + (f ? "Width" : "Height"), p = "px" === i, _ = "%" === i; return i === h || !u || pr[i] || pr[h] ? u : ("px" === h || p || (u = Zd(t, e, r, "px")), o = t.getCTM && Ud(t), !_ && "%" !== h || !rr[e] && !~e.indexOf("adius") ? (l[f ? "width" : "height"] = 100 + (p ? h : i), a = ~e.indexOf("adius") || "em" === i && t.appendChild && !c ? t : t.parentNode, o && (a = (t.ownerSVGElement || {}).parentNode), a && a !== Se && a.appendChild || (a = Se.body), (s = a._gsap) && _ && s.width && f && s.time === Et.time && !s.uncache ? ia(u / s.width * 100) : (!_ && "%" !== h || _r[Nd(a, "display")] || (l.position = Nd(t, "position")), a === t && (l.position = "static"), a.appendChild(Ee), n = Ee[d], a.removeChild(Ee), l.position = "absolute", f && _ && ((s = fa(a)).time = Et.time, s.width = a[d]), ia(p ? n * u / 100 : n && u ? 100 / n * u : 0))) : (n = o ? t.getBBox()[f ? "width" : "height"] : t[d], ia(_ ? u / n * 100 : u / 100 * n))) } function _d(t, e, r, i) { if (!r || "none" === r) { var n = dr(e, t, 1), a = n && Nd(t, n, 1); a && a !== r ? (e = n, r = a) : "borderColor" === e && (r = Nd(t, "borderTopColor")) } var s, o, u, h, l, f, c, d, p, _, m, g = new pe(this._pt, t.style, e, 0, 1, se), v = 0, y = 0; if (g.b = r, g.e = i, r += "", "auto" === (i += "") && (t.style[e] = i, i = Nd(t, e) || i, t.style[e] = r), Eb(s = [r, i]), i = s[1], u = (r = s[0]).match(rt) || [], (i.match(rt) || []).length) { for (; o = rt.exec(i);)c = o[0], p = i.substring(v, o.index), l ? l = (l + 1) % 5 : "rgba(" !== p.substr(-5) && "hsla(" !== p.substr(-5) || (l = 1), c !== (f = u[y++] || "") && (h = parseFloat(f) || 0, m = f.substr((h + "").length), "=" === c.charAt(1) && (c = ka(h, c) + m), d = parseFloat(c), _ = c.substr((d + "").length), v = rt.lastIndex - _.length, _ || (_ = _ || j.units[e] || m, v === i.length && (i += _, g.e += _)), m !== _ && (h = Zd(t, e, f, _) || 0), g._pt = { _next: g._pt, p: p || 1 === y ? p : ",", s: h, c: d - h, m: l && l < 4 || "zIndex" === e ? Math.round : 0 }); g.c = v < i.length ? i.substring(v, i.length) : "" } else g.r = "display" === e && "none" === i ? yd : xd; return nt.test(i) && (g.e = 0), this._pt = g } function be(t) { var e = t.split(" "), r = e[0], i = e[1] || "50%"; return "top" !== r && "bottom" !== r && "left" !== i && "right" !== i || (t = r, r = i, i = t), e[0] = gr[r] || r, e[1] = gr[i] || i, e.join(" ") } function ce(t, e) { if (e.tween && e.tween._time === e.tween._dur) { var r, i, n, a = e.t, s = a.style, o = e.u, u = a._gsap; if ("all" === o || !0 === o) s.cssText = "", i = 1; else for (n = (o = o.split(",")).length; -1 < --n;)r = o[n], rr[r] && (i = 1, r = "transformOrigin" === r ? fr : lr), Vd(a, r); i && (Vd(a, lr), u && (u.svg && a.removeAttribute("transform"), br(a, 1), u.uncache = 1, Id(s))) } } function ge(t) { return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t } function he(t) { var e = Nd(t, lr); return ge(e) ? yr : e.substr(7).match(et).map(ia) } function ie(t, e) { var r, i, n, a, s = t._gsap || fa(t), o = t.style, u = he(t); return s.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (u = [(n = t.transform.baseVal.consolidate().matrix).a, n.b, n.c, n.d, n.e, n.f]).join(",") ? yr : u : (u !== yr || t.offsetParent || t === Re || s.svg || (n = o.display, o.display = "block", (r = t.parentNode) && t.offsetParent || (a = 1, i = t.nextElementSibling, Re.appendChild(t)), u = he(t), n ? o.display = n : Vd(t, "display"), a && (i ? r.insertBefore(t, i) : r ? r.appendChild(t) : Re.removeChild(t))), e && 6 < u.length ? [u[0], u[1], u[4], u[5], u[12], u[13]] : u) } function je(t, e, r, i, n, a) { var s, o, u, h = t._gsap, l = n || ie(t, !0), f = h.xOrigin || 0, c = h.yOrigin || 0, d = h.xOffset || 0, p = h.yOffset || 0, _ = l[0], m = l[1], g = l[2], v = l[3], y = l[4], T = l[5], b = e.split(" "), w = parseFloat(b[0]) || 0, x = parseFloat(b[1]) || 0; r ? l !== yr && (o = _ * v - m * g) && (u = w * (-m / o) + x * (_ / o) - (_ * T - m * y) / o, w = w * (v / o) + x * (-g / o) + (g * T - v * y) / o, x = u) : (w = (s = Td(t)).x + (~b[0].indexOf("%") ? w / 100 * s.width : w), x = s.y + (~(b[1] || b[0]).indexOf("%") ? x / 100 * s.height : x)), i || !1 !== i && h.smooth ? (y = w - f, T = x - c, h.xOffset = d + (y * _ + T * g) - y, h.yOffset = p + (y * m + T * v) - T) : h.xOffset = h.yOffset = 0, h.xOrigin = w, h.yOrigin = x, h.smooth = !!i, h.origin = e, h.originIsAbsolute = !!r, t.style[fr] = "0px 0px", a && (Wd(a, h, "xOrigin", f, w), Wd(a, h, "yOrigin", c, x), Wd(a, h, "xOffset", d, h.xOffset), Wd(a, h, "yOffset", p, h.yOffset)), t.setAttribute("data-svg-origin", w + " " + x) } function me(t, e, r) { var i = Ya(e); return ia(parseFloat(e) + parseFloat(Zd(t, "x", r + "px", i))) + i } function te(t, e, i, n, a) { var s, o, u = 360, h = r(a), l = parseFloat(a) * (h && ~a.indexOf("rad") ? ir : 1) - n, f = n + l + "deg"; return h && ("short" === (s = a.split("_")[1]) && (l %= u) !== l % 180 && (l += l < 0 ? u : -u), "cw" === s && l < 0 ? l = (l + 36e9) % u - ~~(l / u) * u : "ccw" === s && 0 < l && (l = (l - 36e9) % u - ~~(l / u) * u)), t._pt = o = new pe(t._pt, e, i, n, l, ud), o.e = f, o.u = "deg", t._props.push(i), o } function ue(t, e) { for (var r in e) t[r] = e[r]; return t } function ve(t, e, r) { var i, n, a, s, o, u, h, l = ue({}, r._gsap), f = r.style; for (n in l.svg ? (a = r.getAttribute("transform"), r.setAttribute("transform", ""), f[lr] = e, i = br(r, 1), Vd(r, lr), r.setAttribute("transform", a)) : (a = getComputedStyle(r)[lr], f[lr] = e, i = br(r, 1), f[lr] = a), rr) (a = l[n]) !== (s = i[n]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(n) < 0 && (o = Ya(a) !== (h = Ya(s)) ? Zd(r, n, a, h) : parseFloat(a), u = parseFloat(s), t._pt = new pe(t._pt, i, n, o, u - o, td), t._pt.u = h || 0, t._props.push(n)); ue(i, l) } var Ae, Se, Re, De, Ee, ze, Fe, Ie, Be = Ft.Power0, Le = Ft.Power1, Ye = Ft.Power2, Ne = Ft.Power3, qe = Ft.Power4, Ue = Ft.Linear, Ve = Ft.Quad, We = Ft.Cubic, Xe = Ft.Quart, He = Ft.Quint, Qe = Ft.Strong, Ke = Ft.Elastic, Ze = Ft.Back, Ge = Ft.SteppedEase, Je = Ft.Bounce, $e = Ft.Sine, tr = Ft.Expo, er = Ft.Circ, rr = {}, ir = 180 / Math.PI, nr = Math.PI / 180, ar = Math.atan2, sr = /([A-Z])/g, or = /(left|right|width|margin|padding|x)/i, ur = /[\s,\(]\S/, hr = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, lr = "transform", fr = lr + "Origin", cr = "O,Moz,ms,Ms,Webkit".split(","), dr = function _checkPropPrefix(t, e, r) { var i = (e || Ee).style, n = 5; if (t in i && !r) return t; for (t = t.charAt(0).toUpperCase() + t.substr(1); n-- && !(cr[n] + t in i);); return n < 0 ? null : (3 === n ? "ms" : 0 <= n ? cr[n] : "") + t }, pr = { deg: 1, rad: 1, turn: 1 }, _r = { grid: 1, flex: 1 }, mr = function _get(t, e, r, i) { var n; return De || Qd(), e in hr && "transform" !== e && ~(e = hr[e]).indexOf(",") && (e = e.split(",")[0]), rr[e] && "transform" !== e ? (n = br(t, i), n = "transformOrigin" !== e ? n[e] : n.svg ? n.origin : wr(Nd(t, fr)) + " " + n.zOrigin + "px") : (n = t.style[e]) && "auto" !== n && !i && !~(n + "").indexOf("calc(") || (n = vr[e] && vr[e](t, e, r) || Nd(t, e) || ga(t, e) || ("opacity" === e ? 1 : 0)), r && !~(n + "").trim().indexOf(" ") ? Zd(t, e, n, r) + r : n }, gr = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, vr = { clearProps: function clearProps(t, e, r, i, n) { if ("isFromStart" !== n.data) { var a = t._pt = new pe(t._pt, e, r, 0, 0, ce); return a.u = i, a.pr = -10, a.tween = n, t._props.push(r), 1 } } }, yr = [1, 0, 0, 1, 0, 0], Tr = {}, br = function _parseTransform(t, e) { var r = t._gsap || new jt(t); if ("x" in r && !e && !r.uncache) return r; var i, n, a, s, o, u, h, l, f, c, d, p, _, m, g, v, y, T, b, w, x, k, M, O, P, C, A, S, R, D, E, z, F = t.style, I = r.scaleX < 0, B = "deg", L = getComputedStyle(t), Y = Nd(t, fr) || "0"; return i = n = a = u = h = l = f = c = d = 0, s = o = 1, r.svg = !(!t.getCTM || !Ud(t)), L.translate && ("none" === L.translate && "none" === L.scale && "none" === L.rotate || (F[lr] = ("none" !== L.translate ? "translate3d(" + (L.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== L.rotate ? "rotate(" + L.rotate + ") " : "") + ("none" !== L.scale ? "scale(" + L.scale.split(" ").join(",") + ") " : "") + ("none" !== L[lr] ? L[lr] : "")), F.scale = F.rotate = F.translate = "none"), m = ie(t, r.svg), r.svg && (O = r.uncache ? (P = t.getBBox(), Y = r.xOrigin - P.x + "px " + (r.yOrigin - P.y) + "px", "") : !e && t.getAttribute("data-svg-origin"), je(t, O || Y, !!O || r.originIsAbsolute, !1 !== r.smooth, m)), p = r.xOrigin || 0, _ = r.yOrigin || 0, m !== yr && (T = m[0], b = m[1], w = m[2], x = m[3], i = k = m[4], n = M = m[5], 6 === m.length ? (s = Math.sqrt(T * T + b * b), o = Math.sqrt(x * x + w * w), u = T || b ? ar(b, T) * ir : 0, (f = w || x ? ar(w, x) * ir + u : 0) && (o *= Math.abs(Math.cos(f * nr))), r.svg && (i -= p - (p * T + _ * w), n -= _ - (p * b + _ * x))) : (z = m[6], D = m[7], A = m[8], S = m[9], R = m[10], E = m[11], i = m[12], n = m[13], a = m[14], h = (g = ar(z, R)) * ir, g && (O = k * (v = Math.cos(-g)) + A * (y = Math.sin(-g)), P = M * v + S * y, C = z * v + R * y, A = k * -y + A * v, S = M * -y + S * v, R = z * -y + R * v, E = D * -y + E * v, k = O, M = P, z = C), l = (g = ar(-w, R)) * ir, g && (v = Math.cos(-g), E = x * (y = Math.sin(-g)) + E * v, T = O = T * v - A * y, b = P = b * v - S * y, w = C = w * v - R * y), u = (g = ar(b, T)) * ir, g && (O = T * (v = Math.cos(g)) + b * (y = Math.sin(g)), P = k * v + M * y, b = b * v - T * y, M = M * v - k * y, T = O, k = P), h && 359.9 < Math.abs(h) + Math.abs(u) && (h = u = 0, l = 180 - l), s = ia(Math.sqrt(T * T + b * b + w * w)), o = ia(Math.sqrt(M * M + z * z)), g = ar(k, M), f = 2e-4 < Math.abs(g) ? g * ir : 0, d = E ? 1 / (E < 0 ? -E : E) : 0), r.svg && (O = t.getAttribute("transform"), r.forceCSS = t.setAttribute("transform", "") || !ge(Nd(t, lr)), O && t.setAttribute("transform", O))), 90 < Math.abs(f) && Math.abs(f) < 270 && (I ? (s *= -1, f += u <= 0 ? 180 : -180, u += u <= 0 ? 180 : -180) : (o *= -1, f += f <= 0 ? 180 : -180)), e = e || r.uncache, r.x = i - ((r.xPercent = i && (!e && r.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? t.offsetWidth * r.xPercent / 100 : 0) + "px", r.y = n - ((r.yPercent = n && (!e && r.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-n) ? -50 : 0))) ? t.offsetHeight * r.yPercent / 100 : 0) + "px", r.z = a + "px", r.scaleX = ia(s), r.scaleY = ia(o), r.rotation = ia(u) + B, r.rotationX = ia(h) + B, r.rotationY = ia(l) + B, r.skewX = f + B, r.skewY = c + B, r.transformPerspective = d + "px", (r.zOrigin = parseFloat(Y.split(" ")[2]) || 0) && (F[fr] = wr(Y)), r.xOffset = r.yOffset = 0, r.force3D = j.force3D, r.renderTransform = r.svg ? Cr : Ie ? Pr : xr, r.uncache = 0, r }, wr = function _firstTwoOnly(t) { return (t = t.split(" "))[0] + " " + t[1] }, xr = function _renderNon3DTransforms(t, e) { e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, Pr(t, e) }, kr = "0deg", Mr = "0px", Or = ") ", Pr = function _renderCSSTransforms(t, e) { var r = e || this, i = r.xPercent, n = r.yPercent, a = r.x, s = r.y, o = r.z, u = r.rotation, h = r.rotationY, l = r.rotationX, f = r.skewX, c = r.skewY, d = r.scaleX, p = r.scaleY, _ = r.transformPerspective, m = r.force3D, g = r.target, v = r.zOrigin, y = "", T = "auto" === m && t && 1 !== t || !0 === m; if (v && (l !== kr || h !== kr)) { var b, w = parseFloat(h) * nr, x = Math.sin(w), k = Math.cos(w); w = parseFloat(l) * nr, b = Math.cos(w), a = me(g, a, x * b * -v), s = me(g, s, -Math.sin(w) * -v), o = me(g, o, k * b * -v + v) } _ !== Mr && (y += "perspective(" + _ + Or), (i || n) && (y += "translate(" + i + "%, " + n + "%) "), !T && a === Mr && s === Mr && o === Mr || (y += o !== Mr || T ? "translate3d(" + a + ", " + s + ", " + o + ") " : "translate(" + a + ", " + s + Or), u !== kr && (y += "rotate(" + u + Or), h !== kr && (y += "rotateY(" + h + Or), l !== kr && (y += "rotateX(" + l + Or), f === kr && c === kr || (y += "skew(" + f + ", " + c + Or), 1 === d && 1 === p || (y += "scale(" + d + ", " + p + Or), g.style[lr] = y || "translate(0, 0)" }, Cr = function _renderSVGTransforms(t, e) { var r, i, n, a, s, o = e || this, u = o.xPercent, h = o.yPercent, l = o.x, f = o.y, c = o.rotation, d = o.skewX, p = o.skewY, _ = o.scaleX, m = o.scaleY, g = o.target, v = o.xOrigin, y = o.yOrigin, T = o.xOffset, b = o.yOffset, w = o.forceCSS, x = parseFloat(l), k = parseFloat(f); c = parseFloat(c), d = parseFloat(d), (p = parseFloat(p)) && (d += p = parseFloat(p), c += p), c || d ? (c *= nr, d *= nr, r = Math.cos(c) * _, i = Math.sin(c) * _, n = Math.sin(c - d) * -m, a = Math.cos(c - d) * m, d && (p *= nr, s = Math.tan(d - p), n *= s = Math.sqrt(1 + s * s), a *= s, p && (s = Math.tan(p), r *= s = Math.sqrt(1 + s * s), i *= s)), r = ia(r), i = ia(i), n = ia(n), a = ia(a)) : (r = _, a = m, i = n = 0), (x && !~(l + "").indexOf("px") || k && !~(f + "").indexOf("px")) && (x = Zd(g, "x", l, "px"), k = Zd(g, "y", f, "px")), (v || y || T || b) && (x = ia(x + v - (v * r + y * n) + T), k = ia(k + y - (v * i + y * a) + b)), (u || h) && (s = g.getBBox(), x = ia(x + u / 100 * s.width), k = ia(k + h / 100 * s.height)), s = "matrix(" + r + "," + i + "," + n + "," + a + "," + x + "," + k + ")", g.setAttribute("transform", s), w && (g.style[lr] = s) }; ha("padding,margin,Width,Radius", function (e, r) { var t = "Right", i = "Bottom", n = "Left", o = (r < 3 ? ["Top", t, i, n] : ["Top" + n, "Top" + t, i + t, i + n]).map(function (t) { return r < 2 ? e + t : "border" + t + e }); vr[1 < r ? "border" + e : e] = function (e, t, r, i, n) { var a, s; if (arguments.length < 4) return a = o.map(function (t) { return mr(e, t, r) }), 5 === (s = a.join(" ")).split(a[0]).length ? a[0] : s; a = (i + "").split(" "), s = {}, o.forEach(function (t, e) { return s[t] = a[e] = a[e] || a[(e - 1) / 2 | 0] }), e.init(t, s, n) } }); var Ar, Sr, Rr, Dr = { name: "css", register: Qd, targetTest: function targetTest(t) { return t.style && t.nodeType }, init: function init(t, e, i, n, a) { var s, o, u, h, l, f, c, d, p, _, m, g, v, y, T, b, w = this._props, x = t.style, k = i.vars.startAt; for (c in De || Qd(), this.styles = this.styles || Kd(t), b = this.styles.props, this.tween = i, e) if ("autoRound" !== c && (o = e[c], !pt[c] || !_b(c, e, i, n, t, a))) if (l = typeof o, f = vr[c], "function" === l && (l = typeof (o = o.call(i, n, t, a))), "string" === l && ~o.indexOf("random(") && (o = ob(o)), f) f(this, t, c, o, i) && (T = 1); else if ("--" === c.substr(0, 2)) s = (getComputedStyle(t).getPropertyValue(c) + "").trim(), o += "", Rt.lastIndex = 0, Rt.test(s) || (d = Ya(s), p = Ya(o)), p ? d !== p && (s = Zd(t, c, s, p) + p) : d && (o += d), this.add(x, "setProperty", s, o, n, a, 0, 0, c), w.push(c), b.push(c, 0, x[c]); else if ("undefined" !== l) { if (k && c in k ? (s = "function" == typeof k[c] ? k[c].call(i, n, t, a) : k[c], r(s) && ~s.indexOf("random(") && (s = ob(s)), Ya(s + "") || (s += j.units[c] || Ya(mr(t, c)) || ""), "=" === (s + "").charAt(1) && (s = mr(t, c))) : s = mr(t, c), h = parseFloat(s), (_ = "string" === l && "=" === o.charAt(1) && o.substr(0, 2)) && (o = o.substr(2)), u = parseFloat(o), c in hr && ("autoAlpha" === c && (1 === h && "hidden" === mr(t, "visibility") && u && (h = 0), b.push("visibility", 0, x.visibility), Wd(this, x, "visibility", h ? "inherit" : "hidden", u ? "inherit" : "hidden", !u)), "scale" !== c && "transform" !== c && ~(c = hr[c]).indexOf(",") && (c = c.split(",")[0])), m = c in rr) if (this.styles.save(c), g || ((v = t._gsap).renderTransform && !e.parseTransform || br(t, e.parseTransform), y = !1 !== e.smoothOrigin && v.smooth, (g = this._pt = new pe(this._pt, x, lr, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), "scale" === c) this._pt = new pe(this._pt, v, "scaleY", h, (_ ? ka(h, _ + u) : u) - h || 0, td), this._pt.u = 0, w.push("scaleY", c), c += "X"; else { if ("transformOrigin" === c) { b.push(fr, 0, x[fr]), o = be(o), v.svg ? je(t, o, 0, y, 0, this) : ((p = parseFloat(o.split(" ")[2]) || 0) !== v.zOrigin && Wd(this, v, "zOrigin", v.zOrigin, p), Wd(this, x, c, wr(s), wr(o))); continue } if ("svgOrigin" === c) { je(t, o, 1, y, 0, this); continue } if (c in Tr) { te(this, v, c, h, _ ? ka(h, _ + o) : o); continue } if ("smoothOrigin" === c) { Wd(this, v, "smooth", v.smooth, o); continue } if ("force3D" === c) { v[c] = o; continue } if ("transform" === c) { ve(this, o, t); continue } } else c in x || (c = dr(c) || c); if (m || (u || 0 === u) && (h || 0 === h) && !ur.test(o) && c in x) u = u || 0, (d = (s + "").substr((h + "").length)) !== (p = Ya(o) || (c in j.units ? j.units[c] : d)) && (h = Zd(t, c, s, p)), this._pt = new pe(this._pt, m ? v : x, c, h, (_ ? ka(h, _ + u) : u) - h, m || "px" !== p && "zIndex" !== c || !1 === e.autoRound ? td : wd), this._pt.u = p || 0, d !== p && "%" !== p && (this._pt.b = s, this._pt.r = vd); else if (c in x) _d.call(this, t, c, s, _ ? _ + o : o); else { if (!(c in t)) { Q(c, o); continue } this.add(t, c, s || t[c], _ ? _ + o : o, n, a) } m || (c in x ? b.push(c, 0, x[c]) : b.push(c, 1, s || t[c])), w.push(c) } T && de(this) }, render: function render(t, e) { if (e.tween._time || !Fe()) for (var r = e._pt; r;)r.r(t, r.d), r = r._next; else e.styles.revert() }, get: mr, aliases: hr, getSetter: function getSetter(t, e, r) { var i = hr[e]; return i && i.indexOf(",") < 0 && (e = i), e in rr && e !== fr && (t._gsap.x || mr(t, "x")) ? r && ze === r ? "scale" === e ? Cd : Bd : (ze = r || {}) && ("scale" === e ? Dd : Ed) : t.style && !u(t.style[e]) ? zd : ~e.indexOf("-") ? Ad : re(t, e) }, core: { _removeProperty: Vd, _getMatrix: ie } }; Ce.utils.checkPrefix = dr, Ce.core.getStyleSaver = Kd, Rr = ha((Ar = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (Sr = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", function (t) { rr[t] = 1 }), ha(Sr, function (t) { j.units[t] = "deg", Tr[t] = 1 }), hr[Rr[13]] = Ar + "," + Sr, ha("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", function (t) { var e = t.split(":"); hr[e[1]] = Rr[e[0]] }), ha("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (t) { j.units[t] = "px" }), Ce.registerPlugin(Dr); var Er = Ce.registerPlugin(Dr) || Ce, zr = Er.core.Tween; e.Back = Ze, e.Bounce = Je, e.CSSPlugin = Dr, e.Circ = er, e.Cubic = We, e.Elastic = Ke, e.Expo = tr, e.Linear = Ue, e.Power0 = Be, e.Power1 = Le, e.Power2 = Ye, e.Power3 = Ne, e.Power4 = qe, e.Quad = Ve, e.Quart = Xe, e.Quint = He, e.Sine = $e, e.SteppedEase = Ge, e.Strong = Qe, e.TimelineLite = Ut, e.TimelineMax = Ut, e.TweenLite = Gt, e.TweenMax = zr, e.default = Er, e.gsap = Er; if (typeof (window) === "undefined" || window !== e) { Object.defineProperty(e, "__esModule", { value: !0 }) } else { delete e.default } });





/*!
 * ScrollTrigger 3.11.3
 * https://greensock.com
 * 
 * @license Copyright 2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */

!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).window = e.window || {}) }(this, function (e) { "use strict"; function _defineProperties(e, t) { for (var r = 0; r < t.length; r++) { var n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } function q() { return we || "undefined" != typeof window && (we = window.gsap) && we.registerPlugin && we } function y(e, t) { return ~Fe.indexOf(e) && Fe[Fe.indexOf(e) + 1][t] } function z(e) { return !!~t.indexOf(e) } function A(e, t, r, n, o) { return e.addEventListener(t, r, { passive: !n, capture: !!o }) } function B(e, t, r, n) { return e.removeEventListener(t, r, !!n) } function E() { return ze && ze.isPressed || Le.cache++ } function F(r, n) { function Sc(e) { if (e || 0 === e) { o && (Ae.history.scrollRestoration = "manual"); var t = ze && ze.isPressed; e = Sc.v = Math.round(e) || (ze && ze.iOS ? 1 : 0), r(e), Sc.cacheID = Le.cache, t && i("ss", e) } else (n || Le.cache !== Sc.cacheID || i("ref")) && (Sc.cacheID = Le.cache, Sc.v = r()); return Sc.v + Sc.offset } return Sc.offset = 0, r && Sc } function I(e) { return we.utils.toArray(e)[0] || ("string" == typeof e && !1 !== we.config().nullTargetWarn ? console.warn("Element not found:", e) : null) } function J(t, e) { var r = e.s, n = e.sc; z(t) && (t = Ee.scrollingElement || Me); var o = Le.indexOf(t), i = n === Ne.sc ? 1 : 2; ~o || (o = Le.push(t) - 1), Le[o + i] || t.addEventListener("scroll", E); var a = Le[o + i], s = a || (Le[o + i] = F(y(t, r), !0) || (z(t) ? n : F(function (e) { return arguments.length ? t[r] = e : t[r] }))); return s.target = t, a || (s.smooth = "smooth" === we.getProperty(t, "scrollBehavior")), s } function K(e, t, o) { function od(e, t) { var r = He(); t || n < r - s ? (a = i, i = e, l = s, s = r) : o ? i += e : i = a + (e - a) / (r - l) * (s - l) } var i = e, a = e, s = He(), l = s, n = t || 50, c = Math.max(500, 3 * n); return { update: od, reset: function reset() { a = i = o ? 0 : i, l = s = 0 }, getVelocity: function getVelocity(e) { var t = l, r = a, n = He(); return !e && 0 !== e || e === i || od(e), s === l || c < n - l ? 0 : (i + (o ? r : -r)) / ((o ? n : s) - t) * 1e3 } } } function L(e, t) { return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e } function M(e) { var t = Math.max.apply(Math, e), r = Math.min.apply(Math, e); return Math.abs(t) >= Math.abs(r) ? t : r } function N() { (Ie = we.core.globals().ScrollTrigger) && Ie.core && function _integrate() { var e = Ie.core, r = e.bridge || {}, t = e._scrollers, n = e._proxies; t.push.apply(t, Le), n.push.apply(n, Fe), Le = t, Fe = n, i = function _bridge(e, t) { return r[e](t) } }() } function O(e) { return (we = e || q()) && "undefined" != typeof document && document.body && (Ae = window, Me = (Ee = document).documentElement, Ce = Ee.body, t = [Ae, Ee, Me, Ce], we.utils.clamp, De = "onpointerenter" in Ce ? "pointer" : "mouse", Oe = k.isTouch = Ae.matchMedia && Ae.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in Ae || 0 < navigator.maxTouchPoints || 0 < navigator.msMaxTouchPoints ? 2 : 0, Be = k.eventTypes = ("ontouchstart" in Me ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in Me ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function () { return o = 0 }, 500), N(), ke = 1), ke } var we, ke, Ae, Ee, Me, Ce, Oe, De, Ie, t, ze, Be, o = 1, Re = [], Le = [], Fe = [], He = Date.now, i = function _bridge(e, t) { return t }, r = "scrollLeft", n = "scrollTop", Je = { s: r, p: "left", p2: "Left", os: "right", os2: "Right", d: "width", d2: "Width", a: "x", sc: F(function (e) { return arguments.length ? Ae.scrollTo(e, Ne.sc()) : Ae.pageXOffset || Ee[r] || Me[r] || Ce[r] || 0 }) }, Ne = { s: n, p: "top", p2: "Top", os: "bottom", os2: "Bottom", d: "height", d2: "Height", a: "y", op: Je, sc: F(function (e) { return arguments.length ? Ae.scrollTo(Je.sc(), e) : Ae.pageYOffset || Ee[n] || Me[n] || Ce[n] || 0 }) }; Je.op = Ne, Le.cache = 0; var k = (Observer.prototype.init = function init(e) { ke || O(we) || console.warn("Please gsap.registerPlugin(Observer)"), Ie || N(); var o = e.tolerance, a = e.dragMinimum, t = e.type, n = e.target, r = e.lineHeight, i = e.debounce, s = e.preventDefault, l = e.onStop, c = e.onStopDelay, u = e.ignore, f = e.wheelSpeed, d = e.event, p = e.onDragStart, g = e.onDragEnd, h = e.onDrag, v = e.onPress, b = e.onRelease, m = e.onRight, y = e.onLeft, x = e.onUp, S = e.onDown, w = e.onChangeX, _ = e.onChangeY, T = e.onChange, k = e.onToggleX, P = e.onToggleY, C = e.onHover, D = e.onHoverEnd, R = e.onMove, X = e.ignoreCheck, F = e.isNormalizer, Y = e.onGestureStart, H = e.onGestureEnd, V = e.onWheel, W = e.onEnable, j = e.onDisable, q = e.onClick, U = e.scrollSpeed, G = e.capture, $ = e.allowClicks, Q = e.lockAxis, Z = e.onLockAxis; function Pe() { return ye = He() } function Qe(e, t) { return (se.event = e) && u && ~u.indexOf(e.target) || t && ge && "touch" !== e.pointerType || X && X(e, t) } function Se() { var e = se.deltaX = M(be), t = se.deltaY = M(me), r = Math.abs(e) >= o, n = Math.abs(t) >= o; T && (r || n) && T(se, e, t, be, me), r && (m && 0 < se.deltaX && m(se), y && se.deltaX < 0 && y(se), w && w(se), k && se.deltaX < 0 != le < 0 && k(se), le = se.deltaX, be[0] = be[1] = be[2] = 0), n && (S && 0 < se.deltaY && S(se), x && se.deltaY < 0 && x(se), _ && _(se), P && se.deltaY < 0 != ce < 0 && P(se), ce = se.deltaY, me[0] = me[1] = me[2] = 0), (ne || re) && (R && R(se), re && (h(se), re = !1), ne = !1), ie && !(ie = !1) && Z && Z(se), oe && (V(se), oe = !1), ee = 0 } function Te(e, t, r) { be[r] += e, me[r] += t, se._vx.update(e), se._vy.update(t), i ? ee = ee || requestAnimationFrame(Se) : Se() } function Ue(e, t) { Q && !ae && (se.axis = ae = Math.abs(e) > Math.abs(t) ? "x" : "y", ie = !0), "y" !== ae && (be[2] += e, se._vx.update(e, !0)), "x" !== ae && (me[2] += t, se._vy.update(t, !0)), i ? ee = ee || requestAnimationFrame(Se) : Se() } function Ve(e) { if (!Qe(e, 1)) { var t = (e = L(e, s)).clientX, r = e.clientY, n = t - se.x, o = r - se.y, i = se.isDragging; se.x = t, se.y = r, (i || Math.abs(se.startX - t) >= a || Math.abs(se.startY - r) >= a) && (h && (re = !0), i || (se.isDragging = !0), Ue(n, o), i || p && p(se)) } } function Xe(t) { if (!Qe(t, 1)) { B(F ? n : ve, Be[1], Ve, !0); var e = se.isDragging && (3 < Math.abs(se.x - se.startX) || 3 < Math.abs(se.y - se.startY)), r = L(t); e || (se._vx.reset(), se._vy.reset(), s && $ && we.delayedCall(.08, function () { if (300 < He() - ye && !t.defaultPrevented) if (t.target.click) t.target.click(); else if (ve.createEvent) { var e = ve.createEvent("MouseEvents"); e.initMouseEvent("click", !0, !0, Ae, 1, r.screenX, r.screenY, r.clientX, r.clientY, !1, !1, !1, !1, 0, null), t.target.dispatchEvent(e) } })), se.isDragging = se.isGesturing = se.isPressed = !1, l && !F && te.restart(!0), g && e && g(se), b && b(se, e) } } function Ye(e) { return e.touches && 1 < e.touches.length && (se.isGesturing = !0) && Y(e, se.isDragging) } function Ze() { return (se.isGesturing = !1) || H(se) } function $e(e) { if (!Qe(e)) { var t = ue(), r = fe(); Te((t - de) * U, (r - pe) * U, 1), de = t, pe = r, l && te.restart(!0) } } function _e(e) { if (!Qe(e)) { e = L(e, s), V && (oe = !0); var t = (1 === e.deltaMode ? r : 2 === e.deltaMode ? Ae.innerHeight : 1) * f; Te(e.deltaX * t, e.deltaY * t, 0), l && !F && te.restart(!0) } } function af(e) { if (!Qe(e)) { var t = e.clientX, r = e.clientY, n = t - se.x, o = r - se.y; se.x = t, se.y = r, ne = !0, (n || o) && Ue(n, o) } } function bf(e) { se.event = e, C(se) } function cf(e) { se.event = e, D(se) } function df(e) { return Qe(e) || L(e, s) && q(se) } this.target = n = I(n) || Me, this.vars = e, u = u && we.utils.toArray(u), o = o || 1e-9, a = a || 0, f = f || 1, U = U || 1, t = t || "wheel,touch,pointer", i = !1 !== i, r = r || parseFloat(Ae.getComputedStyle(Ce).lineHeight) || 22; var ee, te, re, ne, oe, ie, ae, se = this, le = 0, ce = 0, ue = J(n, Je), fe = J(n, Ne), de = ue(), pe = fe(), ge = ~t.indexOf("touch") && !~t.indexOf("pointer") && "pointerdown" === Be[0], he = z(n), ve = n.ownerDocument || Ee, be = [0, 0, 0], me = [0, 0, 0], ye = 0, xe = se.onPress = function (e) { Qe(e, 1) || (se.axis = ae = null, te.pause(), se.isPressed = !0, e = L(e), le = ce = 0, se.startX = se.x = e.clientX, se.startY = se.y = e.clientY, se._vx.reset(), se._vy.reset(), A(F ? n : ve, Be[1], Ve, s, !0), se.deltaX = se.deltaY = 0, v && v(se)) }; te = se._dc = we.delayedCall(c || .25, function onStopFunc() { se._vx.reset(), se._vy.reset(), te.pause(), l && l(se) }).pause(), se.deltaX = se.deltaY = 0, se._vx = K(0, 50, !0), se._vy = K(0, 50, !0), se.scrollX = ue, se.scrollY = fe, se.isDragging = se.isGesturing = se.isPressed = !1, se.enable = function (e) { return se.isEnabled || (A(he ? ve : n, "scroll", E), 0 <= t.indexOf("scroll") && A(he ? ve : n, "scroll", $e, s, G), 0 <= t.indexOf("wheel") && A(n, "wheel", _e, s, G), (0 <= t.indexOf("touch") && Oe || 0 <= t.indexOf("pointer")) && (A(n, Be[0], xe, s, G), A(ve, Be[2], Xe), A(ve, Be[3], Xe), $ && A(n, "click", Pe, !1, !0), q && A(n, "click", df), Y && A(ve, "gesturestart", Ye), H && A(ve, "gestureend", Ze), C && A(n, De + "enter", bf), D && A(n, De + "leave", cf), R && A(n, De + "move", af)), se.isEnabled = !0, e && e.type && xe(e), W && W(se)), se }, se.disable = function () { se.isEnabled && (Re.filter(function (e) { return e !== se && z(e.target) }).length || B(he ? ve : n, "scroll", E), se.isPressed && (se._vx.reset(), se._vy.reset(), B(F ? n : ve, Be[1], Ve, !0)), B(he ? ve : n, "scroll", $e, G), B(n, "wheel", _e, G), B(n, Be[0], xe, G), B(ve, Be[2], Xe), B(ve, Be[3], Xe), B(n, "click", Pe, !0), B(n, "click", df), B(ve, "gesturestart", Ye), B(ve, "gestureend", Ze), B(n, De + "enter", bf), B(n, De + "leave", cf), B(n, De + "move", af), se.isEnabled = se.isPressed = se.isDragging = !1, j && j(se)) }, se.kill = function () { se.disable(); var e = Re.indexOf(se); 0 <= e && Re.splice(e, 1), ze === se && (ze = 0) }, Re.push(se), F && z(n) && (ze = se), se.enable(d) }, function _createClass(e, t, r) { return t && _defineProperties(e.prototype, t), r && _defineProperties(e, r), e }(Observer, [{ key: "velocityX", get: function get() { return this._vx.getVelocity() } }, { key: "velocityY", get: function get() { return this._vy.getVelocity() } }]), Observer); function Observer(e) { this.init(e) } k.version = "3.11.3", k.create = function (e) { return new k(e) }, k.register = O, k.getAll = function () { return Re.slice() }, k.getById = function (t) { return Re.filter(function (e) { return e.vars.id === t })[0] }, q() && we.registerPlugin(k); function xa() { return ot = 1 } function ya() { return ot = 0 } function za(e) { return e } function Aa(e) { return Math.round(1e5 * e) / 1e5 || 0 } function Ba() { return "undefined" != typeof window } function Ca() { return Ke || Ba() && (Ke = window.gsap) && Ke.registerPlugin && Ke } function Da(e) { return !!~s.indexOf(e) } function Ea(e) { return y(e, "getBoundingClientRect") || (Da(e) ? function () { return Xt.width = We.innerWidth, Xt.height = We.innerHeight, Xt } : function () { return Mt(e) }) } function Ha(e, t) { var r = t.s, n = t.d2, o = t.d, i = t.a; return (r = "scroll" + n) && (i = y(e, r)) ? i() - Ea(e)()[o] : Da(e) ? (qe[r] || Ge[r]) - (We["inner" + n] || qe["client" + n] || Ge["client" + n]) : e[r] - e["offset" + n] } function Ia(e, t) { for (var r = 0; r < p.length; r += 3)t && !~t.indexOf(p[r + 1]) || e(p[r], p[r + 1], p[r + 2]) } function Ja(e) { return "string" == typeof e } function Ka(e) { return "function" == typeof e } function La(e) { return "number" == typeof e } function Ma(e) { return "object" == typeof e } function Na(e, t, r) { return e && e.progress(t ? 0 : 1) && r && e.pause() } function Oa(e, t) { if (e.enabled) { var r = t(e); r && r.totalTime && (e.callbackAnimation = r) } } function db(e) { return We.getComputedStyle(e) } function fb(e, t) { for (var r in t) r in e || (e[r] = t[r]); return e } function hb(e, t) { var r = t.d2; return e["offset" + r] || e["client" + r] || 0 } function ib(e) { var t, r = [], n = e.labels, o = e.duration(); for (t in n) r.push(n[t] / o); return r } function kb(o) { var i = Ke.utils.snap(o), a = Array.isArray(o) && o.slice(0).sort(function (e, t) { return e - t }); return a ? function (e, t, r) { var n; if (void 0 === r && (r = .001), !t) return i(e); if (0 < t) { for (e -= r, n = 0; n < a.length; n++)if (a[n] >= e) return a[n]; return a[n - 1] } for (n = a.length, e += r; n--;)if (a[n] <= e) return a[n]; return a[0] } : function (e, t, r) { void 0 === r && (r = .001); var n = i(e); return !t || Math.abs(n - e) < r || n - e < 0 == t < 0 ? n : i(t < 0 ? e - o : e + o) } } function mb(t, r, e, n) { return e.split(",").forEach(function (e) { return t(r, e, n) }) } function nb(e, t, r, n, o) { return e.addEventListener(t, r, { passive: !n, capture: !!o }) } function ob(e, t, r, n) { return e.removeEventListener(t, r, !!n) } function pb(e, t, r) { return r && r.wheelHandler && e(t, "wheel", r) } function tb(e, t) { if (Ja(e)) { var r = e.indexOf("="), n = ~r ? (e.charAt(r - 1) + 1) * parseFloat(e.substr(r + 1)) : 0; ~r && (e.indexOf("%") > r && (n *= t / 100), e = e.substr(0, r - 1)), e = n + (e in D ? D[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0) } return e } function ub(e, t, r, n, o, i, a, s) { var l = o.startColor, c = o.endColor, u = o.fontSize, f = o.indent, d = o.fontWeight, p = je.createElement("div"), g = Da(r) || "fixed" === y(r, "pinType"), h = -1 !== e.indexOf("scroller"), v = g ? Ge : r, b = -1 !== e.indexOf("start"), m = b ? l : c, x = "border-color:" + m + ";font-size:" + u + ";color:" + m + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;"; return x += "position:" + ((h || s) && g ? "fixed;" : "absolute;"), !h && !s && g || (x += (n === Ne ? _ : T) + ":" + (i + parseFloat(f)) + "px;"), a && (x += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"), p._isStart = b, p.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), p.style.cssText = x, p.innerText = t || 0 === t ? e + "-" + t : e, v.children[0] ? v.insertBefore(p, v.children[0]) : v.appendChild(p), p._offset = p["offset" + n.op.d2], R(p, 0, n, b), p } function zb() { return 34 < gt() - ht && (S = S || requestAnimationFrame(j)) } function Ab() { h && h.isPressed && !(h.startX > Ge.clientWidth) || (Le.cache++, h ? S = S || requestAnimationFrame(j) : j(), ht || H("scrollStart"), ht = gt()) } function Bb() { m = We.innerWidth, b = We.innerHeight } function Cb() { Le.cache++, nt || g || je.fullscreenElement || je.webkitFullscreenElement || v && m === We.innerWidth && !(Math.abs(We.innerHeight - b) > .25 * We.innerHeight) || l.restart(!0) } function Fb() { return ob(Z, "scrollEnd", Fb) || zt(!0) } function Ib(e) { for (var t = 0; t < V.length; t += 5)(!e || V[t + 4] && V[t + 4].query === e) && (V[t].style.cssText = V[t + 1], V[t].getBBox && V[t].setAttribute("transform", V[t + 2] || ""), V[t + 3].uncache = 1) } function Jb(e, t) { var r; for (it = 0; it < Ot.length; it++)!(r = Ot[it]) || t && r._ctx !== t || (e ? r.kill(1) : r.revert(!0, !0)); t && Ib(t), t || H("revert") } function Kb(e, t) { Le.cache++, !t && ut || Le.forEach(function (e) { return Ka(e) && e.cacheID++ && (e.rec = 0) }), Ja(e) && (We.history.scrollRestoration = x = e) } function Xb(e, t, r, n) { if (!e._gsap.swappedIn) { for (var o, i = U.length, a = t.style, s = e.style; i--;)a[o = U[i]] = r[o]; a.position = "absolute" === r.position ? "absolute" : "relative", "inline" === r.display && (a.display = "inline-block"), s[T] = s[_] = "auto", a.flexBasis = r.flexBasis || "auto", a.overflow = "visible", a.boxSizing = "border-box", a[mt] = hb(e, Je) + Et, a[yt] = hb(e, Ne) + Et, a[Tt] = s[kt] = s.top = s.left = "0", Rt(n), s[mt] = s.maxWidth = r[mt], s[yt] = s.maxHeight = r[yt], s[Tt] = r[Tt], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0 } } function $b(e) { for (var t = G.length, r = e.style, n = [], o = 0; o < t; o++)n.push(G[o], r[G[o]]); return n.t = e, n } function bc(e, t, r, n, o, i, a, s, l, c, u, f, d) { Ka(e) && (e = e(s)), Ja(e) && "max" === e.substr(0, 3) && (e = f + ("=" === e.charAt(4) ? tb("0" + e.substr(3), r) : 0)); var p, g, h, v = d ? d.time() : 0; if (d && d.seek(0), La(e)) a && R(a, r, n, !0); else { Ka(t) && (t = t(s)); var b, m, y, x, S = (e || "0").split(" "); h = I(t) || Ge, (b = Mt(h) || {}) && (b.left || b.top) || "none" !== db(h).display || (x = h.style.display, h.style.display = "block", b = Mt(h), x ? h.style.display = x : h.style.removeProperty("display")), m = tb(S[0], b[n.d]), y = tb(S[1] || "0", r), e = b[n.p] - l[n.p] - c + m + o - y, a && R(a, y, n, r - y < 20 || a._isStart && 20 < y), r -= r - y } if (i) { var w = e + r, _ = i._isStart; p = "scroll" + n.d2, R(i, w, n, _ && 20 < w || !_ && (u ? Math.max(Ge[p], qe[p]) : i.parentNode[p]) <= w + 1), u && (l = Mt(a), u && (i.style[n.op.p] = l[n.op.p] - n.op.m - i._offset + Et)) } return d && h && (p = Mt(h), d.seek(f), g = Mt(h), d._caScrollDist = p[n.p] - g[n.p], e = e / d._caScrollDist * f), d && d.seek(v), d ? e : Math.round(e) } function dc(e, t, r, n) { if (e.parentNode !== t) { var o, i, a = e.style; if (t === Ge) { for (o in e._stOrig = a.cssText, i = db(e)) +o || Q.test(o) || !i[o] || "string" != typeof a[o] || "0" === o || (a[o] = i[o]); a.top = r, a.left = n } else a.cssText = e._stOrig; Ke.core.getCache(e).uncache = 1, t.appendChild(e) } } function ec(l, e) { function Sj(e, t, r, n, o) { var i = Sj.tween, a = t.onComplete, s = {}; return r = r || f(), o = n && o || 0, n = n || e - r, i && i.kill(), c = Math.round(r), t[d] = e, (t.modifiers = s)[d] = function (e) { return (e = Math.round(f())) !== c && e !== u && 3 < Math.abs(e - c) && 3 < Math.abs(e - u) ? (i.kill(), Sj.tween = 0) : e = r + n * i.ratio + o * i.ratio * i.ratio, u = c, c = Math.round(e) }, t.onComplete = function () { Sj.tween = 0, a && a.call(i) }, i = Sj.tween = Ke.to(l, t) } var c, u, f = J(l, e), d = "_scroll" + e.p2; return (l[d] = f).wheelHandler = function () { return Sj.tween && Sj.tween.kill() && (Sj.tween = 0) }, nb(l, "wheel", f.wheelHandler), Sj } var Ke, a, We, je, qe, Ge, s, l, et, tt, rt, c, nt, ot, u, it, f, d, p, at, st, g, h, v, b, m, P, lt, x, ct, S, ut, ft, dt, pt = 1, gt = Date.now, w = gt(), ht = 0, vt = 0, bt = Math.abs, _ = "right", T = "bottom", mt = "width", yt = "height", xt = "Right", St = "Left", wt = "Top", _t = "Bottom", Tt = "padding", kt = "margin", At = "Width", C = "Height", Et = "px", Mt = function _getBounds(e, t) { var r = t && "matrix(1, 0, 0, 1, 0, 0)" !== db(e)[u] && Ke.to(e, { x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0 }).progress(1), n = e.getBoundingClientRect(); return r && r.progress(0).kill(), n }, Pt = { startColor: "green", endColor: "red", indent: 0, fontSize: "16px", fontWeight: "normal" }, Ct = { toggleActions: "play", anticipatePin: 0 }, D = { top: 0, left: 0, center: .5, bottom: 1, right: 1 }, R = function _positionMarker(e, t, r, n) { var o = { display: "block" }, i = r[n ? "os2" : "p2"], a = r[n ? "p2" : "os2"]; e._isFlipped = n, o[r.a + "Percent"] = n ? -100 : 0, o[r.a] = n ? "1px" : 0, o["border" + i + At] = 1, o["border" + a + At] = 0, o[r.p] = t + "px", Ke.set(e, o) }, Ot = [], Dt = {}, X = {}, Y = [], H = function _dispatch(e) { return X[e] && X[e].map(function (e) { return e() }) || Y }, V = [], It = 0, zt = function _refreshAll(e, t) { if (!ht || e) { ut = Z.isRefreshing = !0, Le.forEach(function (e) { return Ka(e) && e.cacheID++ && (e.rec = e()) }); var r = H("refreshInit"); at && Z.sort(), t || Jb(), Le.forEach(function (e) { Ka(e) && (e.smooth && (e.target.style.scrollBehavior = "auto"), e(0)) }), Ot.slice(0).forEach(function (e) { return e.refresh() }), Ot.forEach(function (e, t) { if (e._subPinOffset && e.pin) { var r = e.vars.horizontal ? "offsetWidth" : "offsetHeight", n = e.pin[r]; e.revert(!0, 1), e.adjustPinSpacing(e.pin[r] - n), e.revert(!1, 1) } }), Ot.forEach(function (e) { return "max" === e.vars.end && e.setPositions(e.start, Math.max(e.start + 1, Ha(e.scroller, e._dir))) }), r.forEach(function (e) { return e && e.render && e.render(-1) }), Le.forEach(function (e) { Ka(e) && (e.smooth && requestAnimationFrame(function () { return e.target.style.scrollBehavior = "smooth" }), e.rec && e(e.rec)) }), Kb(x, 1), l.pause(), It++, j(2), Ot.forEach(function (e) { return Ka(e.vars.onRefresh) && e.vars.onRefresh(e) }), ut = Z.isRefreshing = !1, H("refresh") } else nb(Z, "scrollEnd", Fb) }, W = 0, Bt = 1, j = function _updateAll(e) { if (!ut || 2 === e) { Z.isUpdating = !0, dt && dt.update(0); var t = Ot.length, r = gt(), n = 50 <= r - w, o = t && Ot[0].scroll(); if (Bt = o < W ? -1 : 1, W = o, n && (ht && !ot && 200 < r - ht && (ht = 0, H("scrollEnd")), rt = w, w = r), Bt < 0) { for (it = t; 0 < it--;)Ot[it] && Ot[it].update(0, n); Bt = 1 } else for (it = 0; it < t; it++)Ot[it] && Ot[it].update(0, n); Z.isUpdating = !1 } S = 0 }, U = ["left", "top", T, _, kt + _t, kt + xt, kt + wt, kt + St, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], G = U.concat([mt, yt, "boxSizing", "max" + At, "max" + C, "position", kt, Tt, Tt + wt, Tt + xt, Tt + _t, Tt + St]), $ = /([A-Z])/g, Rt = function _setState(e) { if (e) { var t, r, n = e.t.style, o = e.length, i = 0; for ((e.t._gsap || Ke.core.getCache(e.t)).uncache = 1; i < o; i += 2)r = e[i + 1], t = e[i], r ? n[t] = r : n[t] && n.removeProperty(t.replace($, "-$1").toLowerCase()) } }, Xt = { left: 0, top: 0 }, Q = /(webkit|moz|length|cssText|inset)/i, Z = (ScrollTrigger.prototype.init = function init(_, T) { if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), vt) { var k, n, p, A, E, M, P, C, O, D, z, e, B, R, X, L, F, t, Y, b, H, N, m, K, x, S, r, w, V, W, o, g, j, q, U, G, $, i, Q = (_ = fb(Ja(_) || La(_) || _.nodeType ? { trigger: _ } : _, Ct)).onUpdate, Z = _.toggleClass, a = _.id, ee = _.onToggle, te = _.onRefresh, re = _.scrub, ne = _.trigger, oe = _.pin, ie = _.pinSpacing, ae = _.invalidateOnRefresh, se = _.anticipatePin, s = _.onScrubComplete, h = _.onSnapComplete, le = _.once, ce = _.snap, ue = _.pinReparent, l = _.pinSpacer, fe = _.containerAnimation, de = _.fastScrollEnd, pe = _.preventOverlaps, ge = _.horizontal || _.containerAnimation && !1 !== _.horizontal ? Je : Ne, he = !re && 0 !== re, ve = I(_.scroller || We), c = Ke.core.getCache(ve), be = Da(ve), me = "fixed" === ("pinType" in _ ? _.pinType : y(ve, "pinType") || be && "fixed"), ye = [_.onEnter, _.onLeave, _.onEnterBack, _.onLeaveBack], xe = he && _.toggleActions.split(" "), u = "markers" in _ ? _.markers : Ct.markers, Se = be ? 0 : parseFloat(db(ve)["border" + ge.p2 + At]) || 0, we = this, _e = _.onRefreshInit && function () { return _.onRefreshInit(we) }, Te = function _getSizeFunc(e, t, r) { var n = r.d, o = r.d2, i = r.a; return (i = y(e, "getBoundingClientRect")) ? function () { return i()[n] } : function () { return (t ? We["inner" + o] : e["client" + o]) || 0 } }(ve, be, ge), ke = function _getOffsetsFunc(e, t) { return !t || ~Fe.indexOf(e) ? Ea(e) : function () { return Xt } }(ve, be), Ae = 0, Ee = 0, Me = J(ve, ge); if (lt(we), we._dir = ge, se *= 45, we.scroller = ve, we.scroll = fe ? fe.time.bind(fe) : Me, A = Me(), we.vars = _, T = T || _.animation, "refreshPriority" in _ && (at = 1, -9999 === _.refreshPriority && (dt = we)), c.tweenScroll = c.tweenScroll || { top: ec(ve, Ne), left: ec(ve, Je) }, we.tweenTo = k = c.tweenScroll[ge.p], we.scrubDuration = function (e) { (o = La(e) && e) ? W ? W.duration(e) : W = Ke.to(T, { ease: "expo", totalProgress: "+=0.001", duration: o, paused: !0, onComplete: function onComplete() { return s && s(we) } }) : (W && W.progress(1).kill(), W = 0) }, T && (T.vars.lazy = !1, T._initted || !1 !== T.vars.immediateRender && !1 !== _.immediateRender && T.duration() && T.render(0, !0, !0), we.animation = T.pause(), (T.scrollTrigger = we).scrubDuration(re), w = 0, a = a || T.vars.id), Ot.push(we), ce && (Ma(ce) && !ce.push || (ce = { snapTo: ce }), "scrollBehavior" in Ge.style && Ke.set(be ? [Ge, qe] : ve, { scrollBehavior: "auto" }), Le.forEach(function (e) { return Ka(e) && e.target === (be ? je.scrollingElement || qe : ve) && (e.smooth = !1) }), p = Ka(ce.snapTo) ? ce.snapTo : "labels" === ce.snapTo ? function _getClosestLabel(t) { return function (e) { return Ke.utils.snap(ib(t), e) } }(T) : "labelsDirectional" === ce.snapTo ? function _getLabelAtDirection(r) { return function (e, t) { return kb(ib(r))(e, t.direction) } }(T) : !1 !== ce.directional ? function (e, t) { return kb(ce.snapTo)(e, gt() - Ee < 500 ? 0 : t.direction) } : Ke.utils.snap(ce.snapTo), g = ce.duration || { min: .1, max: 2 }, g = Ma(g) ? tt(g.min, g.max) : tt(g, g), j = Ke.delayedCall(ce.delay || o / 2 || .1, function () { var e = Me(), t = gt() - Ee < 500, r = k.tween; if (!(t || Math.abs(we.getVelocity()) < 10) || r || ot || Ae === e) we.isActive && Ae !== e && j.restart(!0); else { var n = (e - M) / B, o = T && !he ? T.totalProgress() : n, i = t ? 0 : (o - V) / (gt() - rt) * 1e3 || 0, a = Ke.utils.clamp(-n, 1 - n, bt(i / 2) * i / .185), s = n + (!1 === ce.inertia ? 0 : a), l = tt(0, 1, p(s, we)), c = Math.round(M + l * B), u = ce.onStart, f = ce.onInterrupt, d = ce.onComplete; if (e <= P && M <= e && c !== e) { if (r && !r._initted && r.data <= bt(c - e)) return; !1 === ce.inertia && (a = l - n), k(c, { duration: g(bt(.185 * Math.max(bt(s - o), bt(l - o)) / i / .05 || 0)), ease: ce.ease || "power3", data: bt(c - e), onInterrupt: function onInterrupt() { return j.restart(!0) && f && f(we) }, onComplete: function onComplete() { we.update(), Ae = Me(), w = V = T && !he ? T.totalProgress() : we.progress, h && h(we), d && d(we) } }, e, a * B, c - e - a * B), u && u(we, k.tween) } } }).pause()), a && (Dt[a] = we), i = (i = (ne = we.trigger = I(ne || oe)) && ne._gsap && ne._gsap.stRevert) && i(we), oe = !0 === oe ? ne : I(oe), Ja(Z) && (Z = { targets: ne, className: Z }), oe && (!1 === ie || ie === kt || (ie = !(!ie && oe.parentNode && oe.parentNode.style && "flex" === db(oe.parentNode).display) && Tt), we.pin = oe, (n = Ke.core.getCache(oe)).spacer ? R = n.pinState : (l && ((l = I(l)) && !l.nodeType && (l = l.current || l.nativeElement), n.spacerIsNative = !!l, l && (n.spacerState = $b(l))), n.spacer = F = l || je.createElement("div"), F.classList.add("pin-spacer"), a && F.classList.add("pin-spacer-" + a), n.pinState = R = $b(oe)), !1 !== _.force3D && Ke.set(oe, { force3D: !0 }), we.spacer = F = n.spacer, r = db(oe), m = r[ie + ge.os2], Y = Ke.getProperty(oe), b = Ke.quickSetter(oe, ge.a, Et), Xb(oe, F, r), L = $b(oe)), u) { e = Ma(u) ? fb(u, Pt) : Pt, D = ub("scroller-start", a, ve, ge, e, 0), z = ub("scroller-end", a, ve, ge, e, 0, D), t = D["offset" + ge.op.d2]; var f = I(y(ve, "content") || ve); C = this.markerStart = ub("start", a, f, ge, e, t, 0, fe), O = this.markerEnd = ub("end", a, f, ge, e, t, 0, fe), fe && ($ = Ke.quickSetter([C, O], ge.a, Et)), me || Fe.length && !0 === y(ve, "fixedMarkers") || (function _makePositionable(e) { var t = db(e).position; e.style.position = "absolute" === t || "fixed" === t ? t : "relative" }(be ? Ge : ve), Ke.set([D, z], { force3D: !0 }), x = Ke.quickSetter(D, ge.a, Et), S = Ke.quickSetter(z, ge.a, Et)) } if (fe) { var d = fe.vars.onUpdate, v = fe.vars.onUpdateParams; fe.eventCallback("onUpdate", function () { we.update(0, 0, 1), d && d.apply(v || []) }) } we.previous = function () { return Ot[Ot.indexOf(we) - 1] }, we.next = function () { return Ot[Ot.indexOf(we) + 1] }, we.revert = function (e, t) { if (!t) return we.kill(!0); var r = !1 !== e || !we.enabled, n = nt; r !== we.isReverted && (r && (U = Math.max(Me(), we.scroll.rec || 0), q = we.progress, G = T && T.progress()), C && [C, O, D, z].forEach(function (e) { return e.style.display = r ? "none" : "block" }), r && (nt = 1, we.update(r)), oe && (r ? function _swapPinOut(e, t, r) { Rt(r); var n = e._gsap; if (n.spacerIsNative) Rt(n.spacerState); else if (e._gsap.swappedIn) { var o = t.parentNode; o && (o.insertBefore(e, t), o.removeChild(t)) } e._gsap.swappedIn = !1 }(oe, F, R) : ue && we.isActive || Xb(oe, F, db(oe), K)), r || we.update(r), nt = n, we.isReverted = r) }, we.refresh = function (e, t) { if (!nt && we.enabled || t) if (oe && e && ht) nb(ScrollTrigger, "scrollEnd", Fb); else { !ut && _e && _e(we), nt = 1, Ee = gt(), k.tween && (k.tween.kill(), k.tween = 0), W && W.pause(), ae && T && T.revert({ kill: !1 }).invalidate(), we.isReverted || we.revert(!0, !0), we._subPinOffset = !1; for (var r, n, o, i, a, s, l, c, u, f, d = Te(), p = ke(), g = fe ? fe.duration() : Ha(ve, ge), h = 0, v = 0, b = _.end, m = _.endTrigger || ne, y = _.start || (0 !== _.start && ne ? oe ? "0 0" : "0 100%" : 0), x = we.pinnedContainer = _.pinnedContainer && I(_.pinnedContainer), S = ne && Math.max(0, Ot.indexOf(we)) || 0, w = S; w--;)(s = Ot[w]).end || s.refresh(0, 1) || (nt = 1), !(l = s.pin) || l !== ne && l !== oe || s.isReverted || ((f = f || []).unshift(s), s.revert(!0, !0)), s !== Ot[w] && (S--, w--); for (Ka(y) && (y = y(we)), M = bc(y, ne, d, ge, Me(), C, D, we, p, Se, me, g, fe) || (oe ? -.001 : 0), Ka(b) && (b = b(we)), Ja(b) && !b.indexOf("+=") && (~b.indexOf(" ") ? b = (Ja(y) ? y.split(" ")[0] : "") + b : (h = tb(b.substr(2), d), b = Ja(y) ? y : M + h, m = ne)), P = Math.max(M, bc(b || (m ? "100% 0" : g), m, d, ge, Me() + h, O, z, we, p, Se, me, g, fe)) || -.001, B = P - M || (M -= .01) && .001, h = 0, w = S; w--;)(l = (s = Ot[w]).pin) && s.start - s._pinPush <= M && !fe && 0 < s.end && (r = s.end - s.start, (l === ne && s.start - s._pinPush < M || l === x) && !La(y) && (h += r * (1 - s.progress)), l === oe && (v += r)); if (M += h, P += h, we._pinPush = v, C && h && ((r = {})[ge.a] = "+=" + h, x && (r[ge.p] = "-=" + Me()), Ke.set([C, O], r)), oe) r = db(oe), i = ge === Ne, o = Me(), H = parseFloat(Y(ge.a)) + v, !g && 1 < P && ((be ? Ge : ve).style["overflow-" + ge.a] = "scroll"), Xb(oe, F, r), L = $b(oe), n = Mt(oe, !0), c = me && J(ve, i ? Je : Ne)(), ie && ((K = [ie + ge.os2, B + v + Et]).t = F, (w = ie === Tt ? hb(oe, ge) + B + v : 0) && K.push(ge.d, w + Et), Rt(K), x && Ot.forEach(function (e) { e.pin === x && !1 !== e.vars.pinSpacing && (e._subPinOffset = !0) }), me && Me(U)), me && ((a = { top: n.top + (i ? o - M : c) + Et, left: n.left + (i ? c : o - M) + Et, boxSizing: "border-box", position: "fixed" })[mt] = a.maxWidth = Math.ceil(n.width) + Et, a[yt] = a.maxHeight = Math.ceil(n.height) + Et, a[kt] = a[kt + wt] = a[kt + xt] = a[kt + _t] = a[kt + St] = "0", a[Tt] = r[Tt], a[Tt + wt] = r[Tt + wt], a[Tt + xt] = r[Tt + xt], a[Tt + _t] = r[Tt + _t], a[Tt + St] = r[Tt + St], X = function _copyState(e, t, r) { for (var n, o = [], i = e.length, a = r ? 8 : 0; a < i; a += 2)n = e[a], o.push(n, n in t ? t[n] : e[a + 1]); return o.t = e.t, o }(R, a, ue), ut && Me(0)), T ? (u = T._initted, st(1), T.render(T.duration(), !0, !0), N = Y(ge.a) - H + B + v, B !== N && me && X.splice(X.length - 2, 2), T.render(0, !0, !0), u || T.invalidate(!0), T.parent || T.totalTime(T.totalTime()), st(0)) : N = B; else if (ne && Me() && !fe) for (n = ne.parentNode; n && n !== Ge;)n._pinOffset && (M -= n._pinOffset, P -= n._pinOffset), n = n.parentNode; f && f.forEach(function (e) { return e.revert(!1, !0) }), we.start = M, we.end = P, A = E = ut ? U : Me(), fe || ut || (A < U && Me(U), we.scroll.rec = 0), we.revert(!1, !0), j && (Ae = -1, we.isActive && Me(M + B * q), j.restart(!0)), nt = 0, T && he && (T._initted || G) && T.progress() !== G && T.progress(G, !0).render(T.time(), !0, !0), q === we.progress && !fe || (T && !he && T.totalProgress(q, !0), we.progress = (A - M) / B === q ? 0 : q), oe && ie && (F._pinOffset = Math.round(we.progress * N)), te && !ut && te(we) } }, we.getVelocity = function () { return (Me() - E) / (gt() - rt) * 1e3 || 0 }, we.endAnimation = function () { Na(we.callbackAnimation), T && (W ? W.progress(1) : T.paused() ? he || Na(T, we.direction < 0, 1) : Na(T, T.reversed())) }, we.labelToScroll = function (e) { return T && T.labels && (M || we.refresh() || M) + T.labels[e] / T.duration() * B || 0 }, we.getTrailing = function (t) { var e = Ot.indexOf(we), r = 0 < we.direction ? Ot.slice(0, e).reverse() : Ot.slice(e + 1); return (Ja(t) ? r.filter(function (e) { return e.vars.preventOverlaps === t }) : r).filter(function (e) { return 0 < we.direction ? e.end <= M : e.start >= P }) }, we.update = function (e, t, r) { if (!fe || r || e) { var n, o, i, a, s, l, c, u = ut ? U : we.scroll(), f = e ? 0 : (u - M) / B, d = f < 0 ? 0 : 1 < f ? 1 : f || 0, p = we.progress; if (t && (E = A, A = fe ? Me() : u, ce && (V = w, w = T && !he ? T.totalProgress() : d)), se && !d && oe && !nt && !pt && ht && M < u + (u - E) / (gt() - rt) * se && (d = 1e-4), d !== p && we.enabled) { if (a = (s = (n = we.isActive = !!d && d < 1) != (!!p && p < 1)) || !!d != !!p, we.direction = p < d ? 1 : -1, we.progress = d, a && !nt && (o = d && !p ? 0 : 1 === d ? 1 : 1 === p ? 2 : 3, he && (i = !s && "none" !== xe[o + 1] && xe[o + 1] || xe[o], c = T && ("complete" === i || "reset" === i || i in T))), pe && (s || c) && (c || re || !T) && (Ka(pe) ? pe(we) : we.getTrailing(pe).forEach(function (e) { return e.endAnimation() })), he || (!W || nt || pt ? T && T.totalProgress(d, !!nt) : ((fe || dt && dt !== we) && W.render(W._dp._time - W._start), W.resetTo ? W.resetTo("totalProgress", d, T._tTime / T._tDur) : (W.vars.totalProgress = d, W.invalidate().restart()))), oe) if (e && ie && (F.style[ie + ge.os2] = m), me) { if (a) { if (l = !e && p < d && u < P + 1 && u + 1 >= Ha(ve, ge), ue) if (e || !n && !l) dc(oe, F); else { var g = Mt(oe, !0), h = u - M; dc(oe, Ge, g.top + (ge === Ne ? h : 0) + Et, g.left + (ge === Ne ? 0 : h) + Et) } Rt(n || l ? X : L), N !== B && d < 1 && n || b(H + (1 !== d || l ? 0 : N)) } } else b(Aa(H + N * d)); !ce || k.tween || nt || pt || j.restart(!0), Z && (s || le && d && (d < 1 || !ct)) && et(Z.targets).forEach(function (e) { return e.classList[n || le ? "add" : "remove"](Z.className) }), !Q || he || e || Q(we), a && !nt ? (he && (c && ("complete" === i ? T.pause().totalProgress(1) : "reset" === i ? T.restart(!0).pause() : "restart" === i ? T.restart(!0) : T[i]()), Q && Q(we)), !s && ct || (ee && s && Oa(we, ee), ye[o] && Oa(we, ye[o]), le && (1 === d ? we.kill(!1, 1) : ye[o] = 0), s || ye[o = 1 === d ? 1 : 3] && Oa(we, ye[o])), de && !n && Math.abs(we.getVelocity()) > (La(de) ? de : 2500) && (Na(we.callbackAnimation), W ? W.progress(1) : Na(T, "reverse" === i ? 1 : !d, 1))) : he && Q && !nt && Q(we) } if (S) { var v = fe ? u / fe.duration() * (fe._caScrollDist || 0) : u; x(v + (D._isFlipped ? 1 : 0)), S(v) } $ && $(-u / fe.duration() * (fe._caScrollDist || 0)) } }, we.enable = function (e, t) { we.enabled || (we.enabled = !0, nb(ve, "resize", Cb), nb(be ? je : ve, "scroll", Ab), _e && nb(ScrollTrigger, "refreshInit", _e), !1 !== e && (we.progress = q = 0, A = E = Ae = Me()), !1 !== t && we.refresh()) }, we.getTween = function (e) { return e && k ? k.tween : W }, we.setPositions = function (e, t) { oe && (H += e - M, N += t - e - B, ie === Tt && we.adjustPinSpacing(t - e - B)), we.start = M = e, we.end = P = t, B = t - e, we.update() }, we.adjustPinSpacing = function (e) { if (K) { var t = K.indexOf(ge.d) + 1; K[t] = parseFloat(K[t]) + e + Et, K[1] = parseFloat(K[1]) + e + Et, Rt(K) } }, we.disable = function (e, t) { if (we.enabled && (!1 !== e && we.revert(!0, !0), we.enabled = we.isActive = !1, t || W && W.pause(), U = 0, n && (n.uncache = 1), _e && ob(ScrollTrigger, "refreshInit", _e), j && (j.pause(), k.tween && k.tween.kill() && (k.tween = 0)), !be)) { for (var r = Ot.length; r--;)if (Ot[r].scroller === ve && Ot[r] !== we) return; ob(ve, "resize", Cb), ob(ve, "scroll", Ab) } }, we.kill = function (e, t) { we.disable(e, t), W && !t && W.kill(), a && delete Dt[a]; var r = Ot.indexOf(we); 0 <= r && Ot.splice(r, 1), r === it && 0 < Bt && it--, r = 0, Ot.forEach(function (e) { return e.scroller === we.scroller && (r = 1) }), r || ut || (we.scroll.rec = 0), T && (T.scrollTrigger = null, e && T.revert({ kill: !1 }), t || T.kill()), C && [C, O, D, z].forEach(function (e) { return e.parentNode && e.parentNode.removeChild(e) }), dt === we && (dt = 0), oe && (n && (n.uncache = 1), r = 0, Ot.forEach(function (e) { return e.pin === oe && r++ }), r || (n.spacer = 0)), _.onKill && _.onKill(we) }, we.enable(!1, !1), i && i(we), T && T.add && !B ? Ke.delayedCall(.01, function () { return M || P || we.refresh() }) && (B = .01) && (M = P = 0) : we.refresh(), oe && function _queueRefreshAll() { if (ft !== It) { var e = ft = It; requestAnimationFrame(function () { return e === It && zt(!0) }) } }() } else this.update = this.refresh = this.kill = za }, ScrollTrigger.register = function register(e) { return a || (Ke = e || Ca(), Ba() && window.document && ScrollTrigger.enable(), a = vt), a }, ScrollTrigger.defaults = function defaults(e) { if (e) for (var t in e) Ct[t] = e[t]; return Ct }, ScrollTrigger.disable = function disable(t, r) { vt = 0, Ot.forEach(function (e) { return e[r ? "kill" : "disable"](t) }), ob(We, "wheel", Ab), ob(je, "scroll", Ab), clearInterval(c), ob(je, "touchcancel", za), ob(Ge, "touchstart", za), mb(ob, je, "pointerdown,touchstart,mousedown", xa), mb(ob, je, "pointerup,touchend,mouseup", ya), l.kill(), Ia(ob); for (var e = 0; e < Le.length; e += 3)pb(ob, Le[e], Le[e + 1]), pb(ob, Le[e], Le[e + 2]) }, ScrollTrigger.enable = function enable() { if (We = window, je = document, qe = je.documentElement, Ge = je.body, Ke && (et = Ke.utils.toArray, tt = Ke.utils.clamp, lt = Ke.core.context || za, st = Ke.core.suppressOverwrites || za, x = We.history.scrollRestoration || "auto", Ke.core.globals("ScrollTrigger", ScrollTrigger), Ge)) { vt = 1, k.register(Ke), ScrollTrigger.isTouch = k.isTouch, P = k.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), nb(We, "wheel", Ab), s = [We, je, qe, Ge], Ke.matchMedia ? (ScrollTrigger.matchMedia = function (e) { var t, r = Ke.matchMedia(); for (t in e) r.add(t, e[t]); return r }, Ke.addEventListener("matchMediaInit", function () { return Jb() }), Ke.addEventListener("matchMediaRevert", function () { return Ib() }), Ke.addEventListener("matchMedia", function () { zt(0, 1), H("matchMedia") }), Ke.matchMedia("(orientation: portrait)", function () { return Bb(), Bb })) : console.warn("Requires GSAP 3.11.0 or later"), Bb(), nb(je, "scroll", Ab); var e, t, r = Ge.style, n = r.borderTopStyle, o = Ke.core.Animation.prototype; for (o.revert || Object.defineProperty(o, "revert", { value: function value() { return this.time(-.01, !0) } }), r.borderTopStyle = "solid", e = Mt(Ge), Ne.m = Math.round(e.top + Ne.sc()) || 0, Je.m = Math.round(e.left + Je.sc()) || 0, n ? r.borderTopStyle = n : r.removeProperty("border-top-style"), c = setInterval(zb, 250), Ke.delayedCall(.5, function () { return pt = 0 }), nb(je, "touchcancel", za), nb(Ge, "touchstart", za), mb(nb, je, "pointerdown,touchstart,mousedown", xa), mb(nb, je, "pointerup,touchend,mouseup", ya), u = Ke.utils.checkPrefix("transform"), G.push(u), a = gt(), l = Ke.delayedCall(.2, zt).pause(), p = [je, "visibilitychange", function () { var e = We.innerWidth, t = We.innerHeight; je.hidden ? (f = e, d = t) : f === e && d === t || Cb() }, je, "DOMContentLoaded", zt, We, "load", zt, We, "resize", Cb], Ia(nb), Ot.forEach(function (e) { return e.enable(0, 1) }), t = 0; t < Le.length; t += 3)pb(ob, Le[t], Le[t + 1]), pb(ob, Le[t], Le[t + 2]) } }, ScrollTrigger.config = function config(e) { "limitCallbacks" in e && (ct = !!e.limitCallbacks); var t = e.syncInterval; t && clearInterval(c) || (c = t) && setInterval(zb, t), "ignoreMobileResize" in e && (v = 1 === ScrollTrigger.isTouch && e.ignoreMobileResize), "autoRefreshEvents" in e && (Ia(ob) || Ia(nb, e.autoRefreshEvents || "none"), g = -1 === (e.autoRefreshEvents + "").indexOf("resize")) }, ScrollTrigger.scrollerProxy = function scrollerProxy(e, t) { var r = I(e), n = Le.indexOf(r), o = Da(r); ~n && Le.splice(n, o ? 6 : 2), t && (o ? Fe.unshift(We, t, Ge, t, qe, t) : Fe.unshift(r, t)) }, ScrollTrigger.clearMatchMedia = function clearMatchMedia(t) { Ot.forEach(function (e) { return e._ctx && e._ctx.query === t && e._ctx.kill(!0, !0) }) }, ScrollTrigger.isInViewport = function isInViewport(e, t, r) { var n = (Ja(e) ? I(e) : e).getBoundingClientRect(), o = n[r ? mt : yt] * t || 0; return r ? 0 < n.right - o && n.left + o < We.innerWidth : 0 < n.bottom - o && n.top + o < We.innerHeight }, ScrollTrigger.positionInViewport = function positionInViewport(e, t, r) { Ja(e) && (e = I(e)); var n = e.getBoundingClientRect(), o = n[r ? mt : yt], i = null == t ? o / 2 : t in D ? D[t] * o : ~t.indexOf("%") ? parseFloat(t) * o / 100 : parseFloat(t) || 0; return r ? (n.left + i) / We.innerWidth : (n.top + i) / We.innerHeight }, ScrollTrigger.killAll = function killAll(e) { if (Ot.forEach(function (e) { return "ScrollSmoother" !== e.vars.id && e.kill() }), !0 !== e) { var t = X.killAll || []; X = {}, t.forEach(function (e) { return e() }) } }, ScrollTrigger); function ScrollTrigger(e, t) { a || ScrollTrigger.register(Ke) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), this.init(e, t) } Z.version = "3.11.3", Z.saveStyles = function (e) { return e ? et(e).forEach(function (e) { if (e && e.style) { var t = V.indexOf(e); 0 <= t && V.splice(t, 5), V.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), Ke.core.getCache(e), lt()) } }) : V }, Z.revert = function (e, t) { return Jb(!e, t) }, Z.create = function (e, t) { return new Z(e, t) }, Z.refresh = function (e) { return e ? Cb() : (a || Z.register()) && zt(!0) }, Z.update = j, Z.clearScrollMemory = Kb, Z.maxScroll = function (e, t) { return Ha(e, t ? Je : Ne) }, Z.getScrollFunc = function (e, t) { return J(I(e), t ? Je : Ne) }, Z.getById = function (e) { return Dt[e] }, Z.getAll = function () { return Ot.filter(function (e) { return "ScrollSmoother" !== e.vars.id }) }, Z.isScrolling = function () { return !!ht }, Z.snapDirectional = kb, Z.addEventListener = function (e, t) { var r = X[e] || (X[e] = []); ~r.indexOf(t) || r.push(t) }, Z.removeEventListener = function (e, t) { var r = X[e], n = r && r.indexOf(t); 0 <= n && r.splice(n, 1) }, Z.batch = function (e, t) { function Do(e, t) { var r = [], n = [], o = Ke.delayedCall(i, function () { t(r, n), r = [], n = [] }).pause(); return function (e) { r.length || o.restart(!0), r.push(e.trigger), n.push(e), a <= r.length && o.progress(1) } } var r, n = [], o = {}, i = t.interval || .016, a = t.batchMax || 1e9; for (r in t) o[r] = "on" === r.substr(0, 2) && Ka(t[r]) && "onRefreshInit" !== r ? Do(0, t[r]) : t[r]; return Ka(a) && (a = a(), nb(Z, "refresh", function () { return a = t.batchMax() })), et(e).forEach(function (e) { var t = {}; for (r in o) t[r] = o[r]; t.trigger = e, n.push(Z.create(t)) }), n }; function gc(e, t, r, n) { return n < t ? e(n) : t < 0 && e(0), n < r ? (n - t) / (r - t) : r < 0 ? t / (t - r) : 1 } function hc(e, t) { !0 === t ? e.style.removeProperty("touch-action") : e.style.touchAction = !0 === t ? "auto" : t ? "pan-" + t + (k.isTouch ? " pinch-zoom" : "") : "none", e === qe && hc(Ge, t) } function jc(e) { var t, r = e.event, n = e.target, o = e.axis, i = (r.changedTouches ? r.changedTouches[0] : r).target, a = i._gsap || Ke.core.getCache(i), s = gt(); if (!a._isScrollT || 2e3 < s - a._isScrollT) { for (; i && i.scrollHeight <= i.clientHeight;)i = i.parentNode; a._isScroll = i && !Da(i) && i !== n && (te[(t = db(i)).overflowY] || te[t.overflowX]), a._isScrollT = s } !a._isScroll && "x" !== o || (r.stopPropagation(), r._gsapAllow = !0) } function kc(e, t, r, n) { return k.create({ target: e, capture: !0, debounce: !1, lockAxis: !0, type: t, onWheel: n = n && jc, onPress: n, onDrag: n, onScroll: n, onEnable: function onEnable() { return r && nb(je, k.eventTypes[0], ne, !1, !0) }, onDisable: function onDisable() { return ob(je, k.eventTypes[0], ne, !0) } }) } function oc(e) { function zp() { return o = !1 } function Cp() { i = Ha(d, Ne), T = tt(P ? 1 : 0, i), f && (_ = tt(0, Ha(d, Je))), l = It } function Dp() { h._gsap.y = Aa(parseFloat(h._gsap.y) + v.offset) + "px", h.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(h._gsap.y) + ", 0, 1)", v.offset = v.cacheID = 0 } function Jp() { Cp(), a.isActive() && a.vars.scrollY > i && (v() > i ? a.progress(1) && v(i) : a.resetTo("scrollY", i)) } Ma(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer"; var n, i, l, o, a, c, u, s, f = e.normalizeScrollX, t = e.momentum, r = e.allowNestedScroll, d = I(e.target) || qe, p = Ke.core.globals().ScrollSmoother, g = p && p.get(), h = P && (e.content && I(e.content) || g && !1 !== e.content && !g.smooth() && g.content()), v = J(d, Ne), b = J(d, Je), m = 1, y = (k.isTouch && We.visualViewport ? We.visualViewport.scale * We.visualViewport.width : We.outerWidth) / We.innerWidth, x = 0, S = Ka(t) ? function () { return t(n) } : function () { return t || 2.8 }, w = kc(d, e.type, !0, r), _ = za, T = za; return h && Ke.set(h, { y: "+=0" }), e.ignoreCheck = function (e) { return P && "touchmove" === e.type && function ignoreDrag() { if (o) { requestAnimationFrame(zp); var e = Aa(n.deltaY / 2), t = T(v.v - e); if (h && t !== v.v + v.offset) { v.offset = t - v.v; var r = Aa((parseFloat(h && h._gsap.y) || 0) - v.offset); h.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + r + ", 0, 1)", h._gsap.y = r + "px", v.cacheID = Le.cache, j() } return !0 } v.offset && Dp(), o = !0 }() || 1.05 < m && "touchstart" !== e.type || n.isGesturing || e.touches && 1 < e.touches.length }, e.onPress = function () { var e = m; m = Aa((We.visualViewport && We.visualViewport.scale || 1) / y), a.pause(), e !== m && hc(d, 1.01 < m || !f && "x"), c = b(), u = v(), Cp(), l = It }, e.onRelease = e.onGestureStart = function (e, t) { if (v.offset && Dp(), t) { Le.cache++; var r, n, o = S(); f && (n = (r = b()) + .05 * o * -e.velocityX / .227, o *= gc(b, r, n, Ha(d, Je)), a.vars.scrollX = _(n)), n = (r = v()) + .05 * o * -e.velocityY / .227, o *= gc(v, r, n, Ha(d, Ne)), a.vars.scrollY = T(n), a.invalidate().duration(o).play(.01), (P && a.vars.scrollY >= i || i - 1 <= r) && Ke.to({}, { onUpdate: Jp, duration: o }) } else s.restart(!0) }, e.onWheel = function () { a._ts && a.pause(), 1e3 < gt() - x && (l = 0, x = gt()) }, e.onChange = function (e, t, r, n, o) { if (It !== l && Cp(), t && f && b(_(n[2] === t ? c + (e.startX - e.x) : b() + t - n[1])), r) { v.offset && Dp(); var i = o[2] === r, a = i ? u + e.startY - e.y : v() + r - o[1], s = T(a); i && a !== s && (u += s - a), v(s) } (r || t) && j() }, e.onEnable = function () { hc(d, !f && "x"), Z.addEventListener("refresh", Jp), nb(We, "resize", Jp), v.smooth && (v.target.style.scrollBehavior = "auto", v.smooth = b.smooth = !1), w.enable() }, e.onDisable = function () { hc(d, !0), ob(We, "resize", Jp), Z.removeEventListener("refresh", Jp), w.kill() }, e.lockAxis = !1 !== e.lockAxis, ((n = new k(e)).iOS = P) && !v() && v(1), P && Ke.ticker.add(za), s = n._dc, a = Ke.to(n, { ease: "power4", paused: !0, scrollX: f ? "+=0.1" : "+=0", scrollY: "+=0.1", onComplete: s.vars.onComplete }), n } var ee, te = { auto: 1, scroll: 1 }, re = /(input|label|select|textarea)/i, ne = function _captureInputs(e) { var t = re.test(e.target.tagName); (t || ee) && (e._gsapAllow = !0, ee = t) }; Z.sort = function (e) { return Ot.sort(e || function (e, t) { return -1e6 * (e.vars.refreshPriority || 0) + e.start - (t.start + -1e6 * (t.vars.refreshPriority || 0)) }) }, Z.observe = function (e) { return new k(e) }, Z.normalizeScroll = function (e) { if (void 0 === e) return h; if (!0 === e && h) return h.enable(); if (!1 === e) return h && h.kill(); var t = e instanceof k ? e : oc(e); return h && h.target === t.target && h.kill(), Da(t.target) && (h = t), t }, Z.core = { _getVelocityProp: K, _inputObserver: kc, _scrollers: Le, _proxies: Fe, bridge: { ss: function ss() { ht || H("scrollStart"), ht = gt() }, ref: function ref() { return nt } } }, Ca() && Ke.registerPlugin(Z), e.ScrollTrigger = Z, e.default = Z; if (typeof (window) === "undefined" || window !== e) { Object.defineProperty(e, "__esModule", { value: !0 }) } else { delete e.default } });





/*!
 * Draggable 3.11.3
 * https://greensock.com
 * 
 * @license Copyright 2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */

!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).window = e.window || {}) }(this, function (e) { "use strict"; function w(e, t) { if (e.parentNode && (h || T(e))) { var n = L(e), o = n ? n.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", r = n ? t ? "rect" : "g" : "div", i = 2 !== t ? 0 : 100, a = 3 === t ? 100 : 0, l = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;", s = h.createElementNS ? h.createElementNS(o.replace(/^https/, "http"), r) : h.createElement(r); return t && (n ? (g = g || w(e), s.setAttribute("width", .01), s.setAttribute("height", .01), s.setAttribute("transform", "translate(" + i + "," + a + ")"), g.appendChild(s)) : (f || ((f = w(e)).style.cssText = l), s.style.cssText = l + "width:0.1px;height:0.1px;top:" + a + "px;left:" + i + "px", f.appendChild(s))), s } throw "Need document and parent." } function A(e, t, n, o, r, i, a) { return e.a = t, e.b = n, e.c = o, e.d = r, e.e = i, e.f = a, e } var h, u, r, i, f, g, x, m, y, t, v = "transform", b = v + "Origin", T = function _setDoc(e) { var t = e.ownerDocument || e; !(v in e.style) && "msTransform" in e.style && (b = (v = "msTransform") + "Origin"); for (; t.parentNode && (t = t.parentNode);); if (u = window, x = new ge, t) { r = (h = t).documentElement, i = t.body, (m = h.createElementNS("http://www.w3.org/2000/svg", "g")).style.transform = "none"; var n = t.createElement("div"), o = t.createElement("div"); i.appendChild(n), n.appendChild(o), n.style.position = "static", n.style[v] = "translate3d(0,0,1px)", y = o.offsetParent !== n, i.removeChild(n) } return t }, D = function _forceNonZeroScale(e) { for (var t, n; e && e !== i;)(n = e._gsap) && n.uncache && n.get(e, "x"), n && !n.scaleX && !n.scaleY && n.renderTransform && (n.scaleX = n.scaleY = 1e-4, n.renderTransform(1, n), t ? t.push(n) : t = [n]), e = e.parentNode; return t }, E = [], M = [], S = function _getDocScrollTop() { return u.pageYOffset || h.scrollTop || r.scrollTop || i.scrollTop || 0 }, N = function _getDocScrollLeft() { return u.pageXOffset || h.scrollLeft || r.scrollLeft || i.scrollLeft || 0 }, L = function _svgOwner(e) { return e.ownerSVGElement || ("svg" === (e.tagName + "").toLowerCase() ? e : null) }, C = function _isFixed(e) { return "fixed" === u.getComputedStyle(e).position || ((e = e.parentNode) && 1 === e.nodeType ? _isFixed(e) : void 0) }, P = function _placeSiblings(e, t) { var n, o, r, i, a, l, s = L(e), c = e === s, d = s ? E : M, p = e.parentNode; if (e === u) return e; if (d.length || d.push(w(e, 1), w(e, 2), w(e, 3)), n = s ? g : f, s) c ? (i = -(r = function _getCTM(e) { var t, n = e.getCTM(); return n || (t = e.style[v], e.style[v] = "none", e.appendChild(m), n = m.getCTM(), e.removeChild(m), t ? e.style[v] = t : e.style.removeProperty(v.replace(/([A-Z])/g, "-$1").toLowerCase())), n || x.clone() }(e)).e / r.a, a = -r.f / r.d, o = x) : e.getBBox ? (r = e.getBBox(), i = (o = (o = e.transform ? e.transform.baseVal : {}).numberOfItems ? 1 < o.numberOfItems ? function _consolidate(e) { for (var t = new ge, n = 0; n < e.numberOfItems; n++)t.multiply(e.getItem(n).matrix); return t }(o) : o.getItem(0).matrix : x).a * r.x + o.c * r.y, a = o.b * r.x + o.d * r.y) : (o = new ge, i = a = 0), t && "g" === e.tagName.toLowerCase() && (i = a = 0), (c ? s : p).appendChild(n), n.setAttribute("transform", "matrix(" + o.a + "," + o.b + "," + o.c + "," + o.d + "," + (o.e + i) + "," + (o.f + a) + ")"); else { if (i = a = 0, y) for (o = e.offsetParent, r = e; (r = r && r.parentNode) && r !== o && r.parentNode;)4 < (u.getComputedStyle(r)[v] + "").length && (i = r.offsetLeft, a = r.offsetTop, r = 0); if ("absolute" !== (l = u.getComputedStyle(e)).position && "fixed" !== l.position) for (o = e.offsetParent; p && p !== o;)i += p.scrollLeft || 0, a += p.scrollTop || 0, p = p.parentNode; (r = n.style).top = e.offsetTop - a + "px", r.left = e.offsetLeft - i + "px", r[v] = l[v], r[b] = l[b], r.position = "fixed" === l.position ? "fixed" : "absolute", e.parentNode.appendChild(n) } return n }, ge = ((t = Matrix2D.prototype).inverse = function inverse() { var e = this.a, t = this.b, n = this.c, o = this.d, r = this.e, i = this.f, a = e * o - t * n || 1e-10; return A(this, o / a, -t / a, -n / a, e / a, (n * i - o * r) / a, -(e * i - t * r) / a) }, t.multiply = function multiply(e) { var t = this.a, n = this.b, o = this.c, r = this.d, i = this.e, a = this.f, l = e.a, s = e.c, c = e.b, d = e.d, p = e.e, u = e.f; return A(this, l * t + c * o, l * n + c * r, s * t + d * o, s * n + d * r, i + p * t + u * o, a + p * n + u * r) }, t.clone = function clone() { return new Matrix2D(this.a, this.b, this.c, this.d, this.e, this.f) }, t.equals = function equals(e) { var t = this.a, n = this.b, o = this.c, r = this.d, i = this.e, a = this.f; return t === e.a && n === e.b && o === e.c && r === e.d && i === e.e && a === e.f }, t.apply = function apply(e, t) { void 0 === t && (t = {}); var n = e.x, o = e.y, r = this.a, i = this.b, a = this.c, l = this.d, s = this.e, c = this.f; return t.x = n * r + o * a + s || 0, t.y = n * i + o * l + c || 0, t }, Matrix2D); function Matrix2D(e, t, n, o, r, i) { void 0 === e && (e = 1), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === o && (o = 1), void 0 === r && (r = 0), void 0 === i && (i = 0), A(this, e, t, n, o, r, i) } function getGlobalMatrix(e, t, n, o) { if (!e || !e.parentNode || (h || T(e)).documentElement === e) return new ge; var r = D(e), i = L(e) ? E : M, a = P(e, n), l = i[0].getBoundingClientRect(), s = i[1].getBoundingClientRect(), c = i[2].getBoundingClientRect(), d = a.parentNode, p = !o && C(e), u = new ge((s.left - l.left) / 100, (s.top - l.top) / 100, (c.left - l.left) / 100, (c.top - l.top) / 100, l.left + (p ? 0 : N()), l.top + (p ? 0 : S())); if (d.removeChild(a), r) for (l = r.length; l--;)(s = r[l]).scaleX = s.scaleY = 0, s.renderTransform(1, s); return t ? u.inverse() : u } function V() { return "undefined" != typeof window } function W() { return xe || V() && (xe = window.gsap) && xe.registerPlugin && xe } function X(e) { return "function" == typeof e } function Y(e) { return "object" == typeof e } function Z(e) { return void 0 === e } function $() { return !1 } function ba(e) { return Math.round(1e4 * e) / 1e4 } function da(e, t) { var n = ye.createElementNS ? ye.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : ye.createElement(e); return n.style ? n : ye.createElement(e) } function pa(e, t) { var n, o = {}; for (n in e) o[n] = t ? e[n] * t : e[n]; return o } function ra(e, t) { for (var n, o = e.length; o--;)t ? e[o].style.touchAction = t : e[o].style.removeProperty("touch-action"), (n = e[o].children) && n.length && ra(n, t) } function sa() { return Re.forEach(function (e) { return e() }) } function ua() { return !Re.length && xe.ticker.remove(sa) } function va(e) { for (var t = Re.length; t--;)Re[t] === e && Re.splice(t, 1); xe.to(ua, { overwrite: !0, delay: 15, duration: 0, onComplete: ua, data: "_draggable" }) } function xa(e, t, n, o) { if (e.addEventListener) { var r = Ee[t]; o = o || (d ? { passive: !1 } : null), e.addEventListener(r || t, n, o), r && t !== r && e.addEventListener(t, n, o) } } function ya(e, t, n) { if (e.removeEventListener) { var o = Ee[t]; e.removeEventListener(o || t, n), o && t !== o && e.removeEventListener(t, n) } } function za(e) { e.preventDefault && e.preventDefault(), e.preventManipulation && e.preventManipulation() } function Ba(e) { Me = e.touches && Ye < e.touches.length, ya(e.target, "touchend", Ba) } function Ca(e) { Me = e.touches && Ye < e.touches.length, xa(e.target, "touchend", Ba) } function Da(e) { return me.pageYOffset || e.scrollTop || e.documentElement.scrollTop || e.body.scrollTop || 0 } function Ea(e) { return me.pageXOffset || e.scrollLeft || e.documentElement.scrollLeft || e.body.scrollLeft || 0 } function Fa(e, t) { xa(e, "scroll", t), ze(e.parentNode) || Fa(e.parentNode, t) } function Ga(e, t) { ya(e, "scroll", t), ze(e.parentNode) || Ga(e.parentNode, t) } function Ia(e, t) { var n = "x" === t ? "Width" : "Height", o = "scroll" + n, r = "client" + n; return Math.max(0, ze(e) ? Math.max(ve[o], l[o]) - (me["inner" + n] || ve[r] || l[r]) : e[o] - e[r]) } function Ja(e, t) { var n = Ia(e, "x"), o = Ia(e, "y"); ze(e) ? e = He : Ja(e.parentNode, t), e._gsMaxScrollX = n, e._gsMaxScrollY = o, t || (e._gsScrollX = e.scrollLeft || 0, e._gsScrollY = e.scrollTop || 0) } function Ka(e, t, n) { var o = e.style; o && (Z(o[t]) && (t = c(t, e) || t), null == n ? o.removeProperty && o.removeProperty(t.replace(/([A-Z])/g, "-$1").toLowerCase()) : o[t] = n) } function La(e) { return me.getComputedStyle(e instanceof Element ? e : e.host || (e.parentNode || {}).host || e) } function Na(e) { if (e === me) return p.left = p.top = 0, p.width = p.right = ve.clientWidth || e.innerWidth || l.clientWidth || 0, p.height = p.bottom = (e.innerHeight || 0) - 20 < ve.clientHeight ? ve.clientHeight : e.innerHeight || l.clientHeight || 0, p; var t = e.ownerDocument || ye, n = Z(e.pageX) ? e.nodeType || Z(e.left) || Z(e.top) ? Te(e)[0].getBoundingClientRect() : e : { left: e.pageX - Ea(t), top: e.pageY - Da(t), right: e.pageX - Ea(t) + 1, bottom: e.pageY - Da(t) + 1 }; return Z(n.right) && !Z(n.width) ? (n.right = n.left + n.width, n.bottom = n.top + n.height) : Z(n.width) && (n = { width: n.right - n.left, height: n.bottom - n.top, right: n.right, left: n.left, bottom: n.bottom, top: n.top }), n } function Oa(e, t, n) { var o, r = e.vars, i = r[n], a = e._listeners[t]; return X(i) && (o = i.apply(r.callbackScope || e, r[n + "Params"] || [e.pointerEvent])), a && !1 === e.dispatchEvent(t) && (o = !1), o } function Pa(e, t) { var n, o, r, i = Te(e)[0]; return i.nodeType || i === me ? R(i, t) : Z(e.left) ? { left: o = e.min || e.minX || e.minRotation || 0, top: n = e.min || e.minY || 0, width: (e.max || e.maxX || e.maxRotation || 0) - o, height: (e.max || e.maxY || 0) - n } : (r = { x: 0, y: 0 }, { left: e.left - r.x, top: e.top - r.y, width: e.width, height: e.height }) } function Sa(r, i, e, t, a, n) { var o, l, s, c = {}; if (i) if (1 !== a && i instanceof Array) { if (c.end = o = [], s = i.length, Y(i[0])) for (l = 0; l < s; l++)o[l] = pa(i[l], a); else for (l = 0; l < s; l++)o[l] = i[l] * a; e += 1.1, t -= 1.1 } else X(i) ? c.end = function (e) { var t, n, o = i.call(r, e); if (1 !== a) if (Y(o)) { for (n in t = {}, o) t[n] = o[n] * a; o = t } else o *= a; return o } : c.end = i; return !e && 0 !== e || (c.max = e), !t && 0 !== t || (c.min = t), n && (c.velocity = 0), c } function Ta(e) { var t; return !(!e || !e.getAttribute || e === l) && (!("true" !== (t = e.getAttribute("data-clickable")) && ("false" === t || !e.onclick && !o.test(e.nodeName + "") && "true" !== e.getAttribute("contentEditable"))) || Ta(e.parentNode)) } function Ua(e, t) { for (var n, o = e.length; o--;)(n = e[o]).ondragstart = n.onselectstart = t ? null : $, xe.set(n, { lazy: !0, userSelect: t ? "text" : "none" }) } function Ya(i, r) { i = xe.utils.toArray(i)[0], r = r || {}; var a, l, s, e, c, d, p = document.createElement("div"), u = p.style, t = i.firstChild, h = 0, f = 0, g = i.scrollTop, x = i.scrollLeft, m = i.scrollWidth, y = i.scrollHeight, v = 0, w = 0, b = 0; O && !1 !== r.force3D ? (c = "translate3d(", d = "px,0px)") : _ && (c = "translate(", d = "px)"), this.scrollTop = function (e, t) { if (!arguments.length) return -this.top(); this.top(-e, t) }, this.scrollLeft = function (e, t) { if (!arguments.length) return -this.left(); this.left(-e, t) }, this.left = function (e, t) { if (!arguments.length) return -(i.scrollLeft + f); var n = i.scrollLeft - x, o = f; if ((2 < n || n < -2) && !t) return x = i.scrollLeft, xe.killTweensOf(this, { left: 1, scrollLeft: 1 }), this.left(-x), void (r.onKill && r.onKill()); (e = -e) < 0 ? (f = e - .5 | 0, e = 0) : w < e ? (f = e - w | 0, e = w) : f = 0, (f || o) && (this._skip || (u[_] = c + -f + "px," + -h + d), 0 <= f + v && (u.paddingRight = f + v + "px")), i.scrollLeft = 0 | e, x = i.scrollLeft }, this.top = function (e, t) { if (!arguments.length) return -(i.scrollTop + h); var n = i.scrollTop - g, o = h; if ((2 < n || n < -2) && !t) return g = i.scrollTop, xe.killTweensOf(this, { top: 1, scrollTop: 1 }), this.top(-g), void (r.onKill && r.onKill()); (e = -e) < 0 ? (h = e - .5 | 0, e = 0) : b < e ? (h = e - b | 0, e = b) : h = 0, (h || o) && (this._skip || (u[_] = c + -f + "px," + -h + d)), i.scrollTop = 0 | e, g = i.scrollTop }, this.maxScrollTop = function () { return b }, this.maxScrollLeft = function () { return w }, this.disable = function () { for (t = p.firstChild; t;)e = t.nextSibling, i.appendChild(t), t = e; i === p.parentNode && i.removeChild(p) }, this.enable = function () { if ((t = i.firstChild) !== p) { for (; t;)e = t.nextSibling, p.appendChild(t), t = e; i.appendChild(p), this.calibrate() } }, this.calibrate = function (e) { var t, n, o, r = i.clientWidth === a; g = i.scrollTop, x = i.scrollLeft, r && i.clientHeight === l && p.offsetHeight === s && m === i.scrollWidth && y === i.scrollHeight && !e || ((h || f) && (n = this.left(), o = this.top(), this.left(-i.scrollLeft), this.top(-i.scrollTop)), t = La(i), r && !e || (u.display = "block", u.width = "auto", u.paddingRight = "0px", (v = Math.max(0, i.scrollWidth - i.clientWidth)) && (v += parseFloat(t.paddingLeft) + (k ? parseFloat(t.paddingRight) : 0))), u.display = "inline-block", u.position = "relative", u.overflow = "visible", u.verticalAlign = "top", u.boxSizing = "content-box", u.width = "100%", u.paddingRight = v + "px", k && (u.paddingBottom = t.paddingBottom), a = i.clientWidth, l = i.clientHeight, m = i.scrollWidth, y = i.scrollHeight, w = i.scrollWidth - a, b = i.scrollHeight - l, s = p.offsetHeight, u.display = "block", (n || o) && (this.left(n), this.top(o))) }, this.content = p, this.element = i, this._skip = !1, this.enable() } function Za(e) { if (V() && document.body) { var t = window && window.navigator; me = window, ye = document, ve = ye.documentElement, l = ye.body, s = da("div"), Le = !!window.PointerEvent, (we = da("div")).style.cssText = "visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;cursor:grab", Ne = "grab" === we.style.cursor ? "grab" : "move", Xe = t && -1 !== t.userAgent.toLowerCase().indexOf("android"), De = "ontouchstart" in ve && "orientation" in me || t && (0 < t.MaxTouchPoints || 0 < t.msMaxTouchPoints), o = da("div"), r = da("div"), i = r.style, a = l, i.display = "inline-block", i.position = "relative", o.style.cssText = "width:90px;height:40px;padding:10px;overflow:auto;visibility:hidden", o.appendChild(r), a.appendChild(o), n = r.offsetHeight + 18 > o.scrollHeight, a.removeChild(o), k = n, Ee = function (e) { for (var t = e.split(","), n = (("onpointerdown" in s ? "pointerdown,pointermove,pointerup,pointercancel" : "onmspointerdown" in s ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : e).split(",")), o = {}, r = 4; -1 < --r;)o[t[r]] = n[r], o[n[r]] = t[r]; try { ve.addEventListener("test", null, Object.defineProperty({}, "passive", { get: function get() { d = 1 } })) } catch (e) { } return o }("touchstart,touchmove,touchend,touchcancel"), xa(ye, "touchcancel", $), xa(me, "touchmove", $), l && l.addEventListener("touchstart", $), xa(ye, "contextmenu", function () { for (var e in Ae) Ae[e].isPressed && Ae[e].endDrag() }), xe = be = W() } var n, o, r, i, a; xe ? (Se = xe.plugins.inertia, c = xe.utils.checkPrefix, _ = c(_), Ce = c(Ce), Te = xe.utils.toArray, O = !!c("perspective")) : e && console.warn("Please gsap.registerPlugin(Draggable)") } var xe, me, ye, ve, l, s, we, be, c, Te, d, De, Ee, Me, Xe, Se, Ne, Le, O, k, n, Ye = 0, _ = "transform", Ce = "transformOrigin", Pe = Array.isArray, Oe = 180 / Math.PI, ke = 1e20, a = new ge, _e = Date.now || function () { return (new Date).getTime() }, Re = [], Ae = {}, Be = 0, o = /^(?:a|input|textarea|button|select)$/i, Ie = 0, Fe = {}, He = {}, ze = function _isRoot(e) { return !(e && e !== ve && 9 !== e.nodeType && e !== ye.body && e !== me && e.nodeType && e.parentNode) }, p = {}, We = {}, R = function _getElementBounds(e, t) { t = Te(t)[0]; var n, o, r, i, a, l, s, c, d, p, u, h, f, g = e.getBBox && e.ownerSVGElement, x = e.ownerDocument || ye; if (e === me) r = Da(x), o = (n = Ea(x)) + (x.documentElement.clientWidth || e.innerWidth || x.body.clientWidth || 0), i = r + ((e.innerHeight || 0) - 20 < x.documentElement.clientHeight ? x.documentElement.clientHeight : e.innerHeight || x.body.clientHeight || 0); else { if (t === me || Z(t)) return e.getBoundingClientRect(); n = r = 0, g ? (u = (p = e.getBBox()).width, h = p.height) : (e.viewBox && (p = e.viewBox.baseVal) && (n = p.x || 0, r = p.y || 0, u = p.width, h = p.height), u || (p = "border-box" === (f = La(e)).boxSizing, u = (parseFloat(f.width) || e.clientWidth || 0) + (p ? 0 : parseFloat(f.borderLeftWidth) + parseFloat(f.borderRightWidth)), h = (parseFloat(f.height) || e.clientHeight || 0) + (p ? 0 : parseFloat(f.borderTopWidth) + parseFloat(f.borderBottomWidth)))), o = u, i = h } return e === t ? { left: n, top: r, width: o - n, height: i - r } : (l = (a = getGlobalMatrix(t, !0).multiply(getGlobalMatrix(e))).apply({ x: n, y: r }), s = a.apply({ x: o, y: r }), c = a.apply({ x: o, y: i }), d = a.apply({ x: n, y: i }), { left: n = Math.min(l.x, s.x, c.x, d.x), top: r = Math.min(l.y, s.y, c.y, d.y), width: Math.max(l.x, s.x, c.x, d.x) - n, height: Math.max(l.y, s.y, c.y, d.y) - r }) }, B = ((n = EventDispatcher.prototype).addEventListener = function addEventListener(e, t) { var n = this._listeners[e] || (this._listeners[e] = []); ~n.indexOf(t) || n.push(t) }, n.removeEventListener = function removeEventListener(e, t) { var n = this._listeners[e], o = n && n.indexOf(t); 0 <= o && n.splice(o, 1) }, n.dispatchEvent = function dispatchEvent(t) { var n, o = this; return (this._listeners[t] || []).forEach(function (e) { return !1 === e.call(o, { type: t, target: o.target }) && (n = !1) }), n }, EventDispatcher); function EventDispatcher(e) { this._listeners = {}, this.target = e || this } var Ge, I = (function _inheritsLoose(e, t) { e.prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t }(Draggable, Ge = B), Draggable.register = function register(e) { xe = e, Za() }, Draggable.create = function create(e, t) { return be || Za(!0), Te(e).map(function (e) { return new Draggable(e, t) }) }, Draggable.get = function get(e) { return Ae[(Te(e)[0] || {})._gsDragID] }, Draggable.timeSinceDrag = function timeSinceDrag() { return (_e() - Ie) / 1e3 }, Draggable.hitTest = function hitTest(e, t, n) { if (e === t) return !1; var o, r, i, a = Na(e), l = Na(t), s = a.top, c = a.left, d = a.right, p = a.bottom, u = a.width, h = a.height, f = l.left > d || l.right < c || l.top > p || l.bottom < s; return f || !n ? !f : (i = -1 !== (n + "").indexOf("%"), n = parseFloat(n) || 0, (o = { left: Math.max(c, l.left), top: Math.max(s, l.top) }).width = Math.min(d, l.right) - o.left, o.height = Math.min(p, l.bottom) - o.top, !(o.width < 0 || o.height < 0) && (i ? u * h * (n *= .01) <= (r = o.width * o.height) || r >= l.width * l.height * n : o.width > n && o.height > n)) }, Draggable); function Draggable(h, p) { var e; e = Ge.call(this) || this, be || Za(1), h = Te(h)[0], Se = Se || xe.plugins.inertia, e.vars = p = pa(p || {}), e.target = h, e.x = e.y = e.rotation = 0, e.dragResistance = parseFloat(p.dragResistance) || 0, e.edgeResistance = isNaN(p.edgeResistance) ? 1 : parseFloat(p.edgeResistance) || 0, e.lockAxis = p.lockAxis, e.autoScroll = p.autoScroll || 0, e.lockedAxis = null, e.allowEventDefault = !!p.allowEventDefault, xe.getProperty(h, "x"); function Ng(e, t) { return parseFloat(se.get(h, e, t)) } function uh(e) { return za(e), e.stopImmediatePropagation && e.stopImmediatePropagation(), !1 } function vh(e) { if (q.autoScroll && q.isDragging && (te || P)) { var t, n, o, r, i, a, l, s, c = h, d = 15 * q.autoScroll; for (te = !1, He.scrollTop = null != me.pageYOffset ? me.pageYOffset : null != de.documentElement.scrollTop ? de.documentElement.scrollTop : de.body.scrollTop, He.scrollLeft = null != me.pageXOffset ? me.pageXOffset : null != de.documentElement.scrollLeft ? de.documentElement.scrollLeft : de.body.scrollLeft, r = q.pointerX - He.scrollLeft, i = q.pointerY - He.scrollTop; c && !n;)t = (n = ze(c.parentNode)) ? He : c.parentNode, o = n ? { bottom: Math.max(ve.clientHeight, me.innerHeight || 0), right: Math.max(ve.clientWidth, me.innerWidth || 0), left: 0, top: 0 } : t.getBoundingClientRect(), a = l = 0, j && ((s = t._gsMaxScrollY - t.scrollTop) < 0 ? l = s : i > o.bottom - re && s ? (te = !0, l = Math.min(s, d * (1 - Math.max(0, o.bottom - i) / re) | 0)) : i < o.top + ne && t.scrollTop && (te = !0, l = -Math.min(t.scrollTop, d * (1 - Math.max(0, i - o.top) / ne) | 0)), l && (t.scrollTop += l)), $ && ((s = t._gsMaxScrollX - t.scrollLeft) < 0 ? a = s : r > o.right - oe && s ? (te = !0, a = Math.min(s, d * (1 - Math.max(0, o.right - r) / oe) | 0)) : r < o.left + ie && t.scrollLeft && (te = !0, a = -Math.min(t.scrollLeft, d * (1 - Math.max(0, r - o.left) / ie) | 0)), a && (t.scrollLeft += a)), n && (a || l) && (me.scrollTo(t.scrollLeft, t.scrollTop), he(q.pointerX + a, q.pointerY + l)), c = t } if (P) { var p = q.x, u = q.y; K ? (q.deltaX = p - parseFloat(se.rotation), q.rotation = p, se.rotation = p + "deg", se.renderTransform(1, se)) : f ? (j && (q.deltaY = u - f.top(), f.top(u)), $ && (q.deltaX = p - f.left(), f.left(p))) : G ? (j && (q.deltaY = u - parseFloat(se.y), se.y = u + "px"), $ && (q.deltaX = p - parseFloat(se.x), se.x = p + "px"), se.renderTransform(1, se)) : (j && (q.deltaY = u - parseFloat(h.style.top || 0), h.style.top = u + "px"), $ && (q.deltaX = p - parseFloat(h.style.left || 0), h.style.left = p + "px")), !g || e || F || (!(F = !0) === Oa(q, "drag", "onDrag") && ($ && (q.x -= q.deltaX), j && (q.y -= q.deltaY), vh(!0)), F = !1) } P = !1 } function wh(e, t) { var n, o, r = q.x, i = q.y; h._gsap || (se = xe.core.getCache(h)), se.uncache && xe.getProperty(h, "x"), G ? (q.x = parseFloat(se.x), q.y = parseFloat(se.y)) : K ? q.x = q.rotation = parseFloat(se.rotation) : f ? (q.y = f.top(), q.x = f.left()) : (q.y = parseFloat(h.style.top || (o = La(h)) && o.top) || 0, q.x = parseFloat(h.style.left || (o || {}).left) || 0), (O || k || _) && !t && (q.isDragging || q.isThrowing) && (_ && (Fe.x = q.x, Fe.y = q.y, (n = _(Fe)).x !== q.x && (q.x = n.x, P = !0), n.y !== q.y && (q.y = n.y, P = !0)), O && (n = O(q.x)) !== q.x && (q.x = n, K && (q.rotation = n), P = !0), k && ((n = k(q.y)) !== q.y && (q.y = n), P = !0)), P && vh(!0), e || (q.deltaX = q.x - r, q.deltaY = q.y - i, Oa(q, "throwupdate", "onThrowUpdate")) } function xh(a, l, s, n) { return null == l && (l = -ke), null == s && (s = ke), X(a) ? function (e) { var t = q.isPressed ? 1 - q.edgeResistance : 1; return a.call(q, (s < e ? s + (e - s) * t : e < l ? l + (e - l) * t : e) * n) * n } : Pe(a) ? function (e) { for (var t, n, o = a.length, r = 0, i = ke; -1 < --o;)(n = (t = a[o]) - e) < 0 && (n = -n), n < i && l <= t && t <= s && (r = o, i = n); return a[r] } : isNaN(a) ? function (e) { return e } : function () { return a * n } } function zh() { var e, t, n, o; E = !1, f ? (f.calibrate(), q.minX = S = -f.maxScrollLeft(), q.minY = L = -f.maxScrollTop(), q.maxX = M = q.maxY = N = 0, E = !0) : p.bounds && (e = Pa(p.bounds, h.parentNode), K ? (q.minX = S = e.left, q.maxX = M = e.left + e.width, q.minY = L = q.maxY = N = 0) : Z(p.bounds.maxX) && Z(p.bounds.maxY) ? (t = Pa(h, h.parentNode), q.minX = S = Math.round(Ng(V, "px") + e.left - t.left), q.minY = L = Math.round(Ng(U, "px") + e.top - t.top), q.maxX = M = Math.round(S + (e.width - t.width)), q.maxY = N = Math.round(L + (e.height - t.height))) : (e = p.bounds, q.minX = S = e.minX, q.minY = L = e.minY, q.maxX = M = e.maxX, q.maxY = N = e.maxY), M < S && (q.minX = M, q.maxX = M = S, S = q.minX), N < L && (q.minY = N, q.maxY = N = L, L = q.minY), K && (q.minRotation = S, q.maxRotation = M), E = !0), p.liveSnap && (n = !0 === p.liveSnap ? p.snap || {} : p.liveSnap, o = Pe(n) || X(n), K ? (O = xh(o ? n : n.rotation, S, M, 1), k = null) : n.points ? _ = function buildPointSnapFunc(s, l, c, d, p, u, h) { return u = u && u < ke ? u * u : ke, X(s) ? function (e) { var t, n, o, r = q.isPressed ? 1 - q.edgeResistance : 1, i = e.x, a = e.y; return e.x = i = c < i ? c + (i - c) * r : i < l ? l + (i - l) * r : i, e.y = a = p < a ? p + (a - p) * r : a < d ? d + (a - d) * r : a, (t = s.call(q, e)) !== e && (e.x = t.x, e.y = t.y), 1 !== h && (e.x *= h, e.y *= h), u < ke && (n = e.x - i, o = e.y - a, u < n * n + o * o && (e.x = i, e.y = a)), e } : Pe(s) ? function (e) { for (var t, n, o, r, i = s.length, a = 0, l = ke; -1 < --i;)(r = (t = (o = s[i]).x - e.x) * t + (n = o.y - e.y) * n) < l && (a = i, l = r); return l <= u ? s[a] : e } : function (e) { return e } }(o ? n : n.points, S, M, L, N, n.radius, f ? -1 : 1) : ($ && (O = xh(o ? n : n.x || n.left || n.scrollLeft, S, M, f ? -1 : 1)), j && (k = xh(o ? n : n.y || n.top || n.scrollTop, L, N, f ? -1 : 1)))) } function Ah() { q.isThrowing = !1, Oa(q, "throwcomplete", "onThrowComplete") } function Bh() { q.isThrowing = !1 } function Ch(e, t) { var n, o, r, i; e && Se ? (!0 === e && (n = p.snap || p.liveSnap || {}, o = Pe(n) || X(n), e = { resistance: (p.throwResistance || p.resistance || 1e3) / (K ? 10 : 1) }, K ? e.rotation = Sa(q, o ? n : n.rotation, M, S, 1, t) : ($ && (e[V] = Sa(q, o ? n : n.points || n.x || n.left, M, S, f ? -1 : 1, t || "x" === q.lockedAxis)), j && (e[U] = Sa(q, o ? n : n.points || n.y || n.top, N, L, f ? -1 : 1, t || "y" === q.lockedAxis)), (n.points || Pe(n) && Y(n[0])) && (e.linkedProps = V + "," + U, e.radius = n.radius))), q.isThrowing = !0, i = isNaN(p.overshootTolerance) ? 1 === p.edgeResistance ? 0 : 1 - q.edgeResistance + .2 : p.overshootTolerance, e.duration || (e.duration = { max: Math.max(p.minDuration || 0, "maxDuration" in p ? p.maxDuration : 2), min: isNaN(p.minDuration) ? 0 === i || Y(e) && 1e3 < e.resistance ? 0 : .5 : p.minDuration, overshoot: i }), q.tween = r = xe.to(f || h, { inertia: e, data: "_draggable", onComplete: Ah, onInterrupt: Bh, onUpdate: p.fastMode ? Oa : wh, onUpdateParams: p.fastMode ? [q, "onthrowupdate", "onThrowUpdate"] : n && n.radius ? [!1, !0] : [] }), p.fastMode || (f && (f._skip = !0), r.render(1e9, !0, !0), wh(!0, !0), q.endX = q.x, q.endY = q.y, K && (q.endRotation = q.x), r.play(0), wh(!0, !0), f && (f._skip = !1))) : E && q.applyBounds() } function Dh(e) { var t, n = R; R = getGlobalMatrix(h.parentNode, !0), e && q.isPressed && !R.equals(n || new ge) && (t = n.inverse().apply({ x: w, y: b }), R.apply(t, t), w = t.x, b = t.y), R.equals(a) && (R = null) } function Eh() { var e, t, n, o = 1 - q.edgeResistance, r = ce ? Ea(de) : 0, i = ce ? Da(de) : 0; G && (se.x = Ng(V, "px") + "px", se.y = Ng(U, "px") + "px", se.renderTransform()), Dh(!1), We.x = q.pointerX - r, We.y = q.pointerY - i, R && R.apply(We, We), w = We.x, b = We.y, P && (he(q.pointerX, q.pointerY), vh(!0)), d = getGlobalMatrix(h), f ? (zh(), D = f.top(), T = f.left()) : (pe() ? (wh(!0, !0), zh()) : q.applyBounds(), K ? (e = h.ownerSVGElement ? [se.xOrigin - h.getBBox().x, se.yOrigin - h.getBBox().y] : (La(h)[Ce] || "0 0").split(" "), C = q.rotationOrigin = getGlobalMatrix(h).apply({ x: parseFloat(e[0]) || 0, y: parseFloat(e[1]) || 0 }), wh(!0, !0), t = q.pointerX - C.x - r, n = C.y - q.pointerY + i, T = q.x, D = q.y = Math.atan2(n, t) * Oe) : (D = Ng(U, "px"), T = Ng(V, "px"))), E && o && (M < T ? T = M + (T - M) / o : T < S && (T = S - (S - T) / o), K || (N < D ? D = N + (D - N) / o : D < L && (D = L - (L - D) / o))), q.startX = T = ba(T), q.startY = D = ba(D) } function Gh() { !we.parentNode || pe() || q.isDragging || we.parentNode.removeChild(we) } function Hh(e, t) { var n; if (!u || q.isPressed || !e || !("mousedown" !== e.type && "pointerdown" !== e.type || t) && _e() - le < 30 && Ee[q.pointerEvent.type]) z && e && u && za(e); else { if (A = pe(), W = !1, q.pointerEvent = e, Ee[e.type] ? (v = ~e.type.indexOf("touch") ? e.currentTarget || e.target : de, xa(v, "touchend", fe), xa(v, "touchmove", ue), xa(v, "touchcancel", fe), xa(de, "touchstart", Ca)) : (v = null, xa(de, "mousemove", ue)), I = null, Le && v || (xa(de, "mouseup", fe), e && e.target && xa(e.target, "mouseup", fe)), y = ae.call(q, e.target) && !1 === p.dragClickables && !t) return xa(e.target, "change", fe), Oa(q, "pressInit", "onPressInit"), Oa(q, "press", "onPress"), Ua(Q, !0), void (z = !1); if (B = !(!v || $ == j || !1 === q.vars.allowNativeTouchScrolling || q.vars.allowContextMenu && e && (e.ctrlKey || 2 < e.which)) && ($ ? "y" : "x"), (z = !B && !q.allowEventDefault) && (za(e), xa(me, "touchforcechange", za)), e.changedTouches ? (e = x = e.changedTouches[0], m = e.identifier) : e.pointerId ? m = e.pointerId : x = m = null, Ye++, function _addToRenderQueue(e) { Re.push(e), 1 === Re.length && xe.ticker.add(sa) }(vh), b = q.pointerY = e.pageY, w = q.pointerX = e.pageX, Oa(q, "pressInit", "onPressInit"), (B || q.autoScroll) && Ja(h.parentNode), !h.parentNode || !q.autoScroll || f || K || !h.parentNode._gsMaxScrollX || we.parentNode || h.getBBox || (we.style.width = h.parentNode.scrollWidth + "px", h.parentNode.appendChild(we)), Eh(), q.tween && q.tween.kill(), q.isThrowing = !1, xe.killTweensOf(f || h, o, !0), f && xe.killTweensOf(h, { scrollTo: 1 }, !0), q.tween = q.lockedAxis = null, !p.zIndexBoost && (K || f || !1 === p.zIndexBoost) || (h.style.zIndex = Draggable.zIndex++), q.isPressed = !0, g = !(!p.onDrag && !q._listeners.drag), s = !(!p.onMove && !q._listeners.move), !1 !== p.cursor || p.activeCursor) for (n = Q.length; -1 < --n;)xe.set(Q[n], { cursor: p.activeCursor || p.cursor || ("grab" === Ne ? "grabbing" : Ne) }); Oa(q, "press", "onPress") } } function Lh(e) { if (e && q.isDragging && !f) { var t = e.target || h.parentNode, n = t.scrollLeft - t._gsScrollX, o = t.scrollTop - t._gsScrollY; (n || o) && (R ? (w -= n * R.a + o * R.c, b -= o * R.d + n * R.b) : (w -= n, b -= o), t._gsScrollX += n, t._gsScrollY += o, he(q.pointerX, q.pointerY)) } } function Mh(e) { var t = _e(), n = t - le < 100, o = t - ee < 50, r = n && H === le, i = q.pointerEvent && q.pointerEvent.defaultPrevented, a = n && c === le, l = e.isTrusted || null == e.isTrusted && n && r; if ((r || o && !1 !== q.vars.suppressClickOnDrag) && e.stopImmediatePropagation && e.stopImmediatePropagation(), n && (!q.pointerEvent || !q.pointerEvent.defaultPrevented) && (!r || l && !a)) return l && r && (c = le), void (H = le); (q.isPressed || o || n) && (l && e.detail && n && !i || za(e)), n || o || W || (e && e.target && (q.pointerEvent = e), Oa(q, "click", "onClick")) } function Nh(e) { return R ? { x: e.x * R.a + e.y * R.c + R.e, y: e.x * R.b + e.y * R.d + R.f } : { x: e.x, y: e.y } } var u, f, w, b, T, D, E, g, s, M, S, N, L, x, m, C, P, t, O, k, _, y, v, R, A, B, I, F, H, c, z, d, W, n = (p.type || "x,y").toLowerCase(), G = ~n.indexOf("x") || ~n.indexOf("y"), K = -1 !== n.indexOf("rotation"), V = K ? "rotation" : G ? "x" : "left", U = G ? "y" : "top", $ = !(!~n.indexOf("x") && !~n.indexOf("left") && "scroll" !== n), j = !(!~n.indexOf("y") && !~n.indexOf("top") && "scroll" !== n), J = p.minimumMovement || 2, q = function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(e), Q = Te(p.trigger || p.handle || h), o = {}, ee = 0, te = !1, ne = p.autoScrollMarginTop || 40, oe = p.autoScrollMarginRight || 40, re = p.autoScrollMarginBottom || 40, ie = p.autoScrollMarginLeft || 40, ae = p.clickableTest || Ta, le = 0, se = h._gsap || xe.core.getCache(h), ce = function _isFixed(e) { return "fixed" === La(e).position || ((e = e.parentNode) && 1 === e.nodeType ? _isFixed(e) : void 0) }(h), de = h.ownerDocument || ye, pe = function isTweening() { return q.tween && q.tween.isActive() }, ue = function onMove(e) { var t, n, o, r, i, a, l = e; if (u && !Me && q.isPressed && e) { if (t = (q.pointerEvent = e).changedTouches) { if ((e = t[0]) !== x && e.identifier !== m) { for (r = t.length; -1 < --r && (e = t[r]).identifier !== m && e.target !== h;); if (r < 0) return } } else if (e.pointerId && m && e.pointerId !== m) return; v && B && !I && (We.x = e.pageX - (ce ? Ea(de) : 0), We.y = e.pageY - (ce ? Da(de) : 0), R && R.apply(We, We), n = We.x, o = We.y, ((i = Math.abs(n - w)) !== (a = Math.abs(o - b)) && (J < i || J < a) || Xe && B === I) && (I = a < i && $ ? "x" : "y", B && I !== B && xa(me, "touchforcechange", za), !1 !== q.vars.lockAxisOnTouchScroll && $ && j && (q.lockedAxis = "x" === I ? "y" : "x", X(q.vars.onLockAxis) && q.vars.onLockAxis.call(q, l)), Xe && B === I)) ? fe(l) : (z = q.allowEventDefault || B && (!I || B === I) || !1 === l.cancelable ? z && !1 : (za(l), !0), q.autoScroll && (te = !0), he(e.pageX, e.pageY, s)) } else z && e && u && za(e) }, he = function setPointerPosition(e, t, n) { var o, r, i, a, l, s, c = 1 - q.dragResistance, d = 1 - q.edgeResistance, p = q.pointerX, u = q.pointerY, h = D, f = q.x, g = q.y, x = q.endX, m = q.endY, y = q.endRotation, v = P; q.pointerX = e, q.pointerY = t, ce && (e -= Ea(de), t -= Da(de)), K ? (a = Math.atan2(C.y - t, e - C.x) * Oe, 180 < (l = q.y - a) ? (D -= 360, q.y = a) : l < -180 && (D += 360, q.y = a), i = q.x !== T || Math.abs(D - a) > J ? (q.y = a, T + (D - a) * c) : T) : (R && (s = e * R.a + t * R.c + R.e, t = e * R.b + t * R.d + R.f, e = s), (r = t - b) < J && -J < r && (r = 0), (o = e - w) < J && -J < o && (o = 0), (q.lockAxis || q.lockedAxis) && (o || r) && ((s = q.lockedAxis) || (q.lockedAxis = s = $ && Math.abs(o) > Math.abs(r) ? "y" : j ? "x" : null, s && X(q.vars.onLockAxis) && q.vars.onLockAxis.call(q, q.pointerEvent)), "y" === s ? r = 0 : "x" === s && (o = 0)), i = ba(T + o * c), a = ba(D + r * c)), (O || k || _) && (q.x !== i || q.y !== a && !K) && (_ && (Fe.x = i, Fe.y = a, s = _(Fe), i = ba(s.x), a = ba(s.y)), O && (i = ba(O(i))), k && (a = ba(k(a)))), E && (M < i ? i = M + Math.round((i - M) * d) : i < S && (i = S + Math.round((i - S) * d)), K || (N < a ? a = Math.round(N + (a - N) * d) : a < L && (a = Math.round(L + (a - L) * d)))), q.x === i && (q.y === a || K) || (K ? (q.endRotation = q.x = q.endX = i, P = !0) : (j && (q.y = q.endY = a, P = !0), $ && (q.x = q.endX = i, P = !0)), n && !1 === Oa(q, "move", "onMove") ? (q.pointerX = p, q.pointerY = u, D = h, q.x = f, q.y = g, q.endX = x, q.endY = m, q.endRotation = y, P = v) : !q.isDragging && q.isPressed && (q.isDragging = W = !0, Oa(q, "dragstart", "onDragStart"))) }, fe = function onRelease(e, t) { if (u && q.isPressed && (!e || null == m || t || !(e.pointerId && e.pointerId !== m && e.target !== h || e.changedTouches && !function _hasTouchID(e, t) { for (var n = e.length; n--;)if (e[n].identifier === t) return !0 }(e.changedTouches, m)))) { q.isPressed = !1; var n, o, r, i, a, l = e, s = q.isDragging, c = q.vars.allowContextMenu && e && (e.ctrlKey || 2 < e.which), d = xe.delayedCall(.001, Gh); if (v ? (ya(v, "touchend", onRelease), ya(v, "touchmove", ue), ya(v, "touchcancel", onRelease), ya(de, "touchstart", Ca)) : ya(de, "mousemove", ue), ya(me, "touchforcechange", za), Le && v || (ya(de, "mouseup", onRelease), e && e.target && ya(e.target, "mouseup", onRelease)), P = !1, s && (ee = Ie = _e(), q.isDragging = !1), va(vh), y && !c) return e && (ya(e.target, "change", onRelease), q.pointerEvent = l), Ua(Q, !1), Oa(q, "release", "onRelease"), Oa(q, "click", "onClick"), void (y = !1); for (o = Q.length; -1 < --o;)Ka(Q[o], "cursor", p.cursor || (!1 !== p.cursor ? Ne : null)); if (Ye--, e) { if ((n = e.changedTouches) && (e = n[0]) !== x && e.identifier !== m) { for (o = n.length; -1 < --o && (e = n[o]).identifier !== m && e.target !== h;); if (o < 0 && !t) return } q.pointerEvent = l, q.pointerX = e.pageX, q.pointerY = e.pageY } return c && l ? (za(l), z = !0, Oa(q, "release", "onRelease")) : l && !s ? (z = !1, A && (p.snap || p.bounds) && Ch(p.inertia || p.throwProps), Oa(q, "release", "onRelease"), Xe && "touchmove" === l.type || -1 !== l.type.indexOf("cancel") || (Oa(q, "click", "onClick"), _e() - le < 300 && Oa(q, "doubleclick", "onDoubleClick"), i = l.target || h, le = _e(), a = function syntheticClick() { le === H || !q.enabled() || q.isPressed || l.defaultPrevented || (i.click ? i.click() : de.createEvent && ((r = de.createEvent("MouseEvents")).initMouseEvent("click", !0, !0, me, 1, q.pointerEvent.screenX, q.pointerEvent.screenY, q.pointerX, q.pointerY, !1, !1, !1, !1, 0, null), i.dispatchEvent(r))) }, Xe || l.defaultPrevented || xe.delayedCall(.05, a))) : (Ch(p.inertia || p.throwProps), q.allowEventDefault || !l || !1 === p.dragClickables && ae.call(q, l.target) || !s || B && (!I || B !== I) || !1 === l.cancelable ? z = !1 : (z = !0, za(l)), Oa(q, "release", "onRelease")), pe() && d.duration(q.tween.duration()), s && Oa(q, "dragend", "onDragEnd"), !0 } z && e && u && za(e) }; return (t = Draggable.get(h)) && t.kill(), e.startDrag = function (e, t) { var n, o, r, i; Hh(e || q.pointerEvent, !0), t && !q.hitTest(e || q.pointerEvent) && (n = Na(e || q.pointerEvent), o = Na(h), r = Nh({ x: n.left + n.width / 2, y: n.top + n.height / 2 }), i = Nh({ x: o.left + o.width / 2, y: o.top + o.height / 2 }), w -= r.x - i.x, b -= r.y - i.y), q.isDragging || (q.isDragging = W = !0, Oa(q, "dragstart", "onDragStart")) }, e.drag = ue, e.endDrag = function (e) { return fe(e || q.pointerEvent, !0) }, e.timeSinceDrag = function () { return q.isDragging ? 0 : (_e() - ee) / 1e3 }, e.timeSinceClick = function () { return (_e() - le) / 1e3 }, e.hitTest = function (e, t) { return Draggable.hitTest(q.target, e, t) }, e.getDirection = function (e, t) { var n, o, r, i, a, l, s = "velocity" === e && Se ? e : Y(e) && !K ? "element" : "start"; return "element" === s && (a = Na(q.target), l = Na(e)), n = "start" === s ? q.x - T : "velocity" === s ? Se.getVelocity(h, V) : a.left + a.width / 2 - (l.left + l.width / 2), K ? n < 0 ? "counter-clockwise" : "clockwise" : (t = t || 2, o = "start" === s ? q.y - D : "velocity" === s ? Se.getVelocity(h, U) : a.top + a.height / 2 - (l.top + l.height / 2), i = (r = Math.abs(n / o)) < 1 / t ? "" : n < 0 ? "left" : "right", r < t && ("" !== i && (i += "-"), i += o < 0 ? "up" : "down"), i) }, e.applyBounds = function (e, t) { var n, o, r, i, a, l; if (e && p.bounds !== e) return p.bounds = e, q.update(!0, t); if (wh(!0), zh(), E && !pe()) { if (n = q.x, o = q.y, M < n ? n = M : n < S && (n = S), N < o ? o = N : o < L && (o = L), (q.x !== n || q.y !== o) && (r = !0, q.x = q.endX = n, K ? q.endRotation = n : q.y = q.endY = o, vh(P = !0), q.autoScroll && !q.isDragging)) for (Ja(h.parentNode), i = h, He.scrollTop = null != me.pageYOffset ? me.pageYOffset : null != de.documentElement.scrollTop ? de.documentElement.scrollTop : de.body.scrollTop, He.scrollLeft = null != me.pageXOffset ? me.pageXOffset : null != de.documentElement.scrollLeft ? de.documentElement.scrollLeft : de.body.scrollLeft; i && !l;)a = (l = ze(i.parentNode)) ? He : i.parentNode, j && a.scrollTop > a._gsMaxScrollY && (a.scrollTop = a._gsMaxScrollY), $ && a.scrollLeft > a._gsMaxScrollX && (a.scrollLeft = a._gsMaxScrollX), i = a; q.isThrowing && (r || q.endX > M || q.endX < S || q.endY > N || q.endY < L) && Ch(p.inertia || p.throwProps, r) } return q }, e.update = function (e, t, n) { if (t && q.isPressed) { var o = getGlobalMatrix(h), r = d.apply({ x: q.x - T, y: q.y - D }), i = getGlobalMatrix(h.parentNode, !0); i.apply({ x: o.e - r.x, y: o.f - r.y }, r), q.x -= r.x - i.e, q.y -= r.y - i.f, vh(!0), Eh() } var a = q.x, l = q.y; return Dh(!t), e ? q.applyBounds() : (P && n && vh(!0), wh(!0)), t && (he(q.pointerX, q.pointerY), P && vh(!0)), q.isPressed && !t && ($ && .01 < Math.abs(a - q.x) || j && .01 < Math.abs(l - q.y) && !K) && Eh(), q.autoScroll && (Ja(h.parentNode, q.isDragging), te = q.isDragging, vh(!0), Ga(h, Lh), Fa(h, Lh)), q }, e.enable = function (e) { var t, n, o, r = { lazy: !0 }; if (!1 !== p.cursor && (r.cursor = p.cursor || Ne), xe.utils.checkPrefix("touchCallout") && (r.touchCallout = "none"), "soft" !== e) { for (ra(Q, $ == j ? "none" : p.allowNativeTouchScrolling && h.scrollHeight === h.clientHeight == (h.scrollWidth === h.clientHeight) || p.allowEventDefault ? "manipulation" : $ ? "pan-y" : "pan-x"), n = Q.length; -1 < --n;)o = Q[n], Le || xa(o, "mousedown", Hh), xa(o, "touchstart", Hh), xa(o, "click", Mh, !0), xe.set(o, r), o.getBBox && o.ownerSVGElement && $ != j && xe.set(o.ownerSVGElement, { touchAction: p.allowNativeTouchScrolling || p.allowEventDefault ? "manipulation" : $ ? "pan-y" : "pan-x" }), p.allowContextMenu || xa(o, "contextmenu", uh); Ua(Q, !1) } return Fa(h, Lh), u = !0, Se && "soft" !== e && Se.track(f || h, G ? "x,y" : K ? "rotation" : "top,left"), h._gsDragID = t = "d" + Be++, Ae[t] = q, f && (f.enable(), f.element._gsDragID = t), (p.bounds || K) && Eh(), p.bounds && q.applyBounds(), q }, e.disable = function (e) { for (var t, n = q.isDragging, o = Q.length; -1 < --o;)Ka(Q[o], "cursor", null); if ("soft" !== e) { for (ra(Q, null), o = Q.length; -1 < --o;)t = Q[o], Ka(t, "touchCallout", null), ya(t, "mousedown", Hh), ya(t, "touchstart", Hh), ya(t, "click", Mh), ya(t, "contextmenu", uh); Ua(Q, !0), v && (ya(v, "touchcancel", fe), ya(v, "touchend", fe), ya(v, "touchmove", ue)), ya(de, "mouseup", fe), ya(de, "mousemove", ue) } return Ga(h, Lh), u = !1, Se && "soft" !== e && Se.untrack(f || h, G ? "x,y" : K ? "rotation" : "top,left"), f && f.disable(), va(vh), q.isDragging = q.isPressed = y = !1, n && Oa(q, "dragend", "onDragEnd"), q }, e.enabled = function (e, t) { return arguments.length ? e ? q.enable(t) : q.disable(t) : u }, e.kill = function () { return q.isThrowing = !1, q.tween && q.tween.kill(), q.disable(), xe.set(Q, { clearProps: "userSelect" }), delete Ae[h._gsDragID], q }, ~n.indexOf("scroll") && (f = e.scrollProxy = new Ya(h, function _extend(e, t) { for (var n in t) n in e || (e[n] = t[n]); return e }({ onKill: function onKill() { q.isPressed && fe(null) } }, p)), h.style.overflowY = j && !De ? "auto" : "hidden", h.style.overflowX = $ && !De ? "auto" : "hidden", h = f.content), K ? o.rotation = 1 : ($ && (o[V] = 1), j && (o[U] = 1)), se.force3D = !("force3D" in p) || p.force3D, e.enable(), e } !function _setDefaults(e, t) { for (var n in t) n in e || (e[n] = t[n]) }(I.prototype, { pointerX: 0, pointerY: 0, startX: 0, startY: 0, deltaX: 0, deltaY: 0, isDragging: !1, isPressed: !1 }), I.zIndex = 1e3, I.version = "3.11.3", W() && xe.registerPlugin(I), e.Draggable = I, e.default = I; if (typeof (window) === "undefined" || window !== e) { Object.defineProperty(e, "__esModule", { value: !0 }) } else { delete e.default } });





/*!
 * MotionPathPlugin 3.12.2
 * https://greensock.com
 * 
 * @license Copyright 2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */

!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = t || self).window = t.window || {}) }(this, function (t) { "use strict"; function p(t) { return "string" == typeof t } function x(t) { return Math.round(1e10 * t) / 1e10 || 0 } function y(t, e, n, r) { var a = t[e], o = 1 === r ? 6 : subdivideSegment(a, n, r); if (o && o + n + 2 < a.length) return t.splice(e, 0, a.slice(0, n + o + 2)), a.splice(0, n + o), 1 } function C(t, e) { var n = t.length, r = t[n - 1] || [], a = r.length; n && e[0] === r[a - 2] && e[1] === r[a - 1] && (e = r.concat(e.slice(2)), n--), t[n] = e } var M = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, T = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, L = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi, r = /(^[#\.][a-z]|[a-y][a-z])/i, V = Math.PI / 180, s = 180 / Math.PI, F = Math.sin, U = Math.cos, H = Math.abs, $ = Math.sqrt, l = Math.atan2, A = 1e8, h = function _isNumber(t) { return "number" == typeof t }, S = {}, _ = {}, e = 1e5, d = function _wrapProgress(t) { return Math.round((t + A) % 1 * e) / e || (t < 0 ? 0 : 1) }, N = function _round(t) { return Math.round(t * e) / e || 0 }, m = function _getSampleIndex(t, e, n) { var r = t.length, a = ~~(n * r); if (t[a] > e) { for (; --a && t[a] > e;); a < 0 && (a = 0) } else for (; t[++a] < e && a < r;); return a < r ? a : r - 1 }, O = function _copyMetaData(t, e) { return e.totalLength = t.totalLength, t.samples ? (e.samples = t.samples.slice(0), e.lookup = t.lookup.slice(0), e.minLength = t.minLength, e.resolution = t.resolution) : t.totalPoints && (e.totalPoints = t.totalPoints), e }; function getRawPath(t) { var e, n = (t = p(t) && r.test(t) && document.querySelector(t) || t).getAttribute ? t : 0; return n && (t = t.getAttribute("d")) ? (n._gsPath || (n._gsPath = {}), (e = n._gsPath[t]) && !e._dirty ? e : n._gsPath[t] = stringToRawPath(t)) : t ? p(t) ? stringToRawPath(t) : h(t[0]) ? [t] : t : console.warn("Expecting a <path> element or an SVG path data string") } function reverseSegment(t) { var e, n = 0; for (t.reverse(); n < t.length; n += 2)e = t[n], t[n] = t[n + 1], t[n + 1] = e; t.reversed = !t.reversed } var B = { rect: "rx,ry,x,y,width,height", circle: "r,cx,cy", ellipse: "rx,ry,cx,cy", line: "x1,x2,y1,y2" }; function convertToPath(t, e) { var n, r, a, o, i, s, l, h, u, g, f, c, p, d, m, v, y, x, w, P, b, M, R = t.tagName.toLowerCase(), L = .552284749831; return "path" !== R && t.getBBox ? (s = function _createPath(t, e) { var n, r = document.createElementNS("http://www.w3.org/2000/svg", "path"), a = [].slice.call(t.attributes), o = a.length; for (e = "," + e + ","; -1 < --o;)n = a[o].nodeName.toLowerCase(), e.indexOf("," + n + ",") < 0 && r.setAttributeNS(null, n, a[o].nodeValue); return r }(t, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points"), M = function _attrToObj(t, e) { for (var n = e ? e.split(",") : [], r = {}, a = n.length; -1 < --a;)r[n[a]] = +t.getAttribute(n[a]) || 0; return r }(t, B[R]), "rect" === R ? (o = M.rx, i = M.ry || o, r = M.x, a = M.y, g = M.width - 2 * o, f = M.height - 2 * i, n = o || i ? "M" + (v = (d = (p = r + o) + g) + o) + "," + (x = a + i) + " V" + (w = x + f) + " C" + [v, P = w + i * L, m = d + o * L, b = w + i, d, b, d - (d - p) / 3, b, p + (d - p) / 3, b, p, b, c = r + o * (1 - L), b, r, P, r, w, r, w - (w - x) / 3, r, x + (w - x) / 3, r, x, r, y = a + i * (1 - L), c, a, p, a, p + (d - p) / 3, a, d - (d - p) / 3, a, d, a, m, a, v, y, v, x].join(",") + "z" : "M" + (r + g) + "," + a + " v" + f + " h" + -g + " v" + -f + " h" + g + "z") : "circle" === R || "ellipse" === R ? (h = "circle" === R ? (o = i = M.r) * L : (o = M.rx, (i = M.ry) * L), n = "M" + ((r = M.cx) + o) + "," + (a = M.cy) + " C" + [r + o, a + h, r + (l = o * L), a + i, r, a + i, r - l, a + i, r - o, a + h, r - o, a, r - o, a - h, r - l, a - i, r, a - i, r + l, a - i, r + o, a - h, r + o, a].join(",") + "z") : "line" === R ? n = "M" + M.x1 + "," + M.y1 + " L" + M.x2 + "," + M.y2 : "polyline" !== R && "polygon" !== R || (n = "M" + (r = (u = (t.getAttribute("points") + "").match(T) || []).shift()) + "," + (a = u.shift()) + " L" + u.join(","), "polygon" === R && (n += "," + r + "," + a + "z")), s.setAttribute("d", rawPathToString(s._gsRawPath = stringToRawPath(n))), e && t.parentNode && (t.parentNode.insertBefore(s, t), t.parentNode.removeChild(t)), s) : t } function getRotationAtBezierT(t, e, n) { var r, a = t[e], o = t[e + 2], i = t[e + 4]; return a += (o - a) * n, a += ((o += (i - o) * n) - a) * n, r = o + (i + (t[e + 6] - i) * n - o) * n - a, a = t[e + 1], a += ((o = t[e + 3]) - a) * n, a += ((o += ((i = t[e + 5]) - o) * n) - a) * n, N(l(o + (i + (t[e + 7] - i) * n - o) * n - a, r) * s) } function sliceRawPath(t, e, n) { n = function _isUndefined(t) { return void 0 === t }(n) ? 1 : x(n) || 0, e = x(e) || 0; var r = Math.max(0, ~~(H(n - e) - 1e-8)), a = function copyRawPath(t) { for (var e = [], n = 0; n < t.length; n++)e[n] = O(t[n], t[n].slice(0)); return O(t, e) }(t); if (n < e && (e = 1 - e, n = 1 - n, function _reverseRawPath(t, e) { var n = t.length; for (e || t.reverse(); n--;)t[n].reversed || reverseSegment(t[n]) }(a), a.totalLength = 0), e < 0 || n < 0) { var o = Math.abs(~~Math.min(e, n)) + 1; e += o, n += o } a.totalLength || cacheRawPathMeasurements(a); var i, s, l, h, u, g, f, c, p = 1 < n, d = getProgressData(a, e, S, !0), m = getProgressData(a, n, _), v = m.segment, w = d.segment, P = m.segIndex, b = d.segIndex, M = m.i, R = d.i, L = b === P, T = M === R && L; if (p || r) { for (i = P < b || L && M < R || T && m.t < d.t, y(a, b, R, d.t) && (b++, i || (P++, T ? (m.t = (m.t - d.t) / (1 - d.t), M = 0) : L && (M -= R))), Math.abs(1 - (n - e)) < 1e-5 ? P = b - 1 : !m.t && P ? P-- : y(a, P, M, m.t) && i && b++, 1 === d.t && (b = (b + 1) % a.length), u = [], f = 1 + (g = a.length) * r, f += (g - (c = b) + P) % g, h = 0; h < f; h++)C(u, a[c++ % g]); a = u } else if (l = 1 === m.t ? 6 : subdivideSegment(v, M, m.t), e !== n) for (s = subdivideSegment(w, R, T ? d.t / m.t : d.t), L && (l += s), v.splice(M + l + 2), (s || R) && w.splice(0, R + s), h = a.length; h--;)(h < b || P < h) && a.splice(h, 1); else v.angle = getRotationAtBezierT(v, M + l, 0), d = v[M += l], m = v[M + 1], v.length = v.totalLength = 0, v.totalPoints = a.totalPoints = 8, v.push(d, m, d, m, d, m, d, m); return a.totalLength = 0, a } function measureSegment(t, e, n) { e = e || 0, t.samples || (t.samples = [], t.lookup = []); var r, a, o, i, s, l, h, u, g, f, c, p, d, m, v, y, x, w = ~~t.resolution || 12, P = 1 / w, b = n ? e + 6 * n + 1 : t.length, M = t[e], R = t[e + 1], L = e ? e / 6 * w : 0, T = t.samples, S = t.lookup, C = (e ? t.minLength : A) || A, _ = T[L + n * w - 1], N = e ? T[L - 1] : 0; for (T.length = S.length = 0, a = e + 2; a < b; a += 6) { if (o = t[a + 4] - M, i = t[a + 2] - M, s = t[a] - M, u = t[a + 5] - R, g = t[a + 3] - R, f = t[a + 1] - R, l = h = c = p = 0, H(o) < .01 && H(u) < .01 && H(s) + H(f) < .01) 8 < t.length && (t.splice(a, 6), a -= 6, b -= 6); else for (r = 1; r <= w; r++)l = h - (h = ((m = P * r) * m * o + 3 * (d = 1 - m) * (m * i + d * s)) * m), c = p - (p = (m * m * u + 3 * d * (m * g + d * f)) * m), (y = $(c * c + l * l)) < C && (C = y), N += y, T[L++] = N; M += o, R += u } if (_) for (_ -= N; L < T.length; L++)T[L] += _; if (T.length && C) { if (t.totalLength = x = T[T.length - 1] || 0, x / (t.minLength = C) < 9999) for (y = v = 0, r = 0; r < x; r += C)S[y++] = T[v] < r ? ++v : v } else t.totalLength = T[0] = 0; return e ? N - T[e / 2 - 1] : N } function cacheRawPathMeasurements(t, e) { var n, r, a; for (a = n = r = 0; a < t.length; a++)t[a].resolution = ~~e || 12, r += t[a].length, n += measureSegment(t[a]); return t.totalPoints = r, t.totalLength = n, t } function subdivideSegment(t, e, n) { if (n <= 0 || 1 <= n) return 0; var r = t[e], a = t[e + 1], o = t[e + 2], i = t[e + 3], s = t[e + 4], l = t[e + 5], h = r + (o - r) * n, u = o + (s - o) * n, g = a + (i - a) * n, f = i + (l - i) * n, c = h + (u - h) * n, p = g + (f - g) * n, d = s + (t[e + 6] - s) * n, m = l + (t[e + 7] - l) * n; return u += (d - u) * n, f += (m - f) * n, t.splice(e + 2, 4, N(h), N(g), N(c), N(p), N(c + (u - c) * n), N(p + (f - p) * n), N(u), N(f), N(d), N(m)), t.samples && t.samples.splice(e / 6 * t.resolution | 0, 0, 0, 0, 0, 0, 0, 0), 6 } function getProgressData(t, e, n, r) { n = n || {}, t.totalLength || cacheRawPathMeasurements(t), (e < 0 || 1 < e) && (e = d(e)); var a, o, i, s, l, h, u, g = 0, f = t[0]; if (e) if (1 === e) u = 1, h = (f = t[g = t.length - 1]).length - 8; else { if (1 < t.length) { for (i = t.totalLength * e, l = h = 0; (l += t[h++].totalLength) < i;)g = h; e = (i - (s = l - (f = t[g]).totalLength)) / (l - s) || 0 } a = f.samples, o = f.resolution, i = f.totalLength * e, s = (h = f.lookup.length ? f.lookup[~~(i / f.minLength)] || 0 : m(a, i, e)) ? a[h - 1] : 0, (l = a[h]) < i && (s = l, l = a[++h]), u = 1 / o * ((i - s) / (l - s) + h % o), h = 6 * ~~(h / o), r && 1 === u && (h + 6 < f.length ? (h += 6, u = 0) : g + 1 < t.length && (h = u = 0, f = t[++g])) } else u = h = g = 0, f = t[0]; return n.t = u, n.i = h, n.path = t, n.segment = f, n.segIndex = g, n } function getPositionOnPath(t, e, n, r) { var a, o, i, s, l, h, u, g, f, c = t[0], p = r || {}; if ((e < 0 || 1 < e) && (e = d(e)), c.lookup || cacheRawPathMeasurements(t), 1 < t.length) { for (i = t.totalLength * e, l = h = 0; (l += t[h++].totalLength) < i;)c = t[h]; e = (i - (s = l - c.totalLength)) / (l - s) || 0 } return a = c.samples, o = c.resolution, i = c.totalLength * e, s = (h = c.lookup.length ? c.lookup[e < 1 ? ~~(i / c.minLength) : c.lookup.length - 1] || 0 : m(a, i, e)) ? a[h - 1] : 0, (l = a[h]) < i && (s = l, l = a[++h]), f = 1 - (u = 1 / o * ((i - s) / (l - s) + h % o) || 0), g = c[h = 6 * ~~(h / o)], p.x = N((u * u * (c[h + 6] - g) + 3 * f * (u * (c[h + 4] - g) + f * (c[h + 2] - g))) * u + g), p.y = N((u * u * (c[h + 7] - (g = c[h + 1])) + 3 * f * (u * (c[h + 5] - g) + f * (c[h + 3] - g))) * u + g), n && (p.angle = c.totalLength ? getRotationAtBezierT(c, h, 1 <= u ? 1 - 1e-9 : u || 1e-9) : c.angle || 0), p } function transformRawPath(t, e, n, r, a, o, i) { for (var s, l, h, u, g, f = t.length; -1 < --f;)for (l = (s = t[f]).length, h = 0; h < l; h += 2)u = s[h], g = s[h + 1], s[h] = u * e + g * r + o, s[h + 1] = u * n + g * a + i; return t._dirty = 1, t } function arcToSegment(t, e, n, r, a, o, i, s, l) { if (t !== s || e !== l) { n = H(n), r = H(r); var h = a % 360 * V, u = U(h), g = F(h), f = Math.PI, c = 2 * f, p = (t - s) / 2, d = (e - l) / 2, m = u * p + g * d, v = -g * p + u * d, y = m * m, x = v * v, w = y / (n * n) + x / (r * r); 1 < w && (n = $(w) * n, r = $(w) * r); var P = n * n, b = r * r, M = (P * b - P * x - b * y) / (P * x + b * y); M < 0 && (M = 0); var R = (o === i ? -1 : 1) * $(M), L = n * v / r * R, T = -r * m / n * R, S = u * L - g * T + (t + s) / 2, C = g * L + u * T + (e + l) / 2, _ = (m - L) / n, N = (v - T) / r, A = (-m - L) / n, O = (-v - T) / r, B = _ * _ + N * N, I = (N < 0 ? -1 : 1) * Math.acos(_ / $(B)), D = (_ * O - N * A < 0 ? -1 : 1) * Math.acos((_ * A + N * O) / $(B * (A * A + O * O))); isNaN(D) && (D = f), !i && 0 < D ? D -= c : i && D < 0 && (D += c), I %= c, D %= c; var E, X = Math.ceil(H(D) / (c / 4)), k = [], z = D / X, G = 4 / 3 * F(z / 2) / (1 + U(z / 2)), Z = u * n, q = g * n, Y = g * -r, j = u * r; for (E = 0; E < X; E++)m = U(a = I + E * z), v = F(a), _ = U(a += z), N = F(a), k.push(m - G * v, v + G * m, _ + G * N, N - G * _, _, N); for (E = 0; E < k.length; E += 2)m = k[E], v = k[E + 1], k[E] = m * Z + v * Y + S, k[E + 1] = m * q + v * j + C; return k[E - 2] = s, k[E - 1] = l, k } } function stringToRawPath(t) { function Cf(t, e, n, r) { u = (n - t) / 3, g = (r - e) / 3, s.push(t + u, e + g, n - u, r - g, n, r) } var e, n, r, a, o, i, s, l, h, u, g, f, c, p, d, m = (t + "").replace(L, function (t) { var e = +t; return e < 1e-4 && -1e-4 < e ? 0 : e }).match(M) || [], v = [], y = 0, x = 0, w = m.length, P = 0, b = "ERROR: malformed path: " + t; if (!t || !isNaN(m[0]) || isNaN(m[1])) return console.log(b), v; for (e = 0; e < w; e++)if (c = o, isNaN(m[e]) ? i = (o = m[e].toUpperCase()) !== m[e] : e--, r = +m[e + 1], a = +m[e + 2], i && (r += y, a += x), e || (l = r, h = a), "M" === o) s && (s.length < 8 ? --v.length : P += s.length), y = l = r, x = h = a, s = [r, a], v.push(s), e += 2, o = "L"; else if ("C" === o) i || (y = x = 0), (s = s || [0, 0]).push(r, a, y + 1 * m[e + 3], x + 1 * m[e + 4], y += 1 * m[e + 5], x += 1 * m[e + 6]), e += 6; else if ("S" === o) u = y, g = x, "C" !== c && "S" !== c || (u += y - s[s.length - 4], g += x - s[s.length - 3]), i || (y = x = 0), s.push(u, g, r, a, y += 1 * m[e + 3], x += 1 * m[e + 4]), e += 4; else if ("Q" === o) u = y + 2 / 3 * (r - y), g = x + 2 / 3 * (a - x), i || (y = x = 0), y += 1 * m[e + 3], x += 1 * m[e + 4], s.push(u, g, y + 2 / 3 * (r - y), x + 2 / 3 * (a - x), y, x), e += 4; else if ("T" === o) u = y - s[s.length - 4], g = x - s[s.length - 3], s.push(y + u, x + g, r + 2 / 3 * (y + 1.5 * u - r), a + 2 / 3 * (x + 1.5 * g - a), y = r, x = a), e += 2; else if ("H" === o) Cf(y, x, y = r, x), e += 1; else if ("V" === o) Cf(y, x, y, x = r + (i ? x - y : 0)), e += 1; else if ("L" === o || "Z" === o) "Z" === o && (r = l, a = h, s.closed = !0), ("L" === o || .5 < H(y - r) || .5 < H(x - a)) && (Cf(y, x, r, a), "L" === o && (e += 2)), y = r, x = a; else if ("A" === o) { if (p = m[e + 4], d = m[e + 5], u = m[e + 6], g = m[e + 7], n = 7, 1 < p.length && (p.length < 3 ? (g = u, u = d, n--) : (g = d, u = p.substr(2), n -= 2), d = p.charAt(1), p = p.charAt(0)), f = arcToSegment(y, x, +m[e + 1], +m[e + 2], +m[e + 3], +p, +d, (i ? y : 0) + 1 * u, (i ? x : 0) + 1 * g), e += n, f) for (n = 0; n < f.length; n++)s.push(f[n]); y = s[s.length - 2], x = s[s.length - 1] } else console.log(b); return (e = s.length) < 6 ? (v.pop(), e = 0) : s[0] === s[e - 2] && s[1] === s[e - 1] && (s.closed = !0), v.totalPoints = P + e, v } function flatPointsToSegment(t, e) { void 0 === e && (e = 1); for (var n = t[0], r = 0, a = [n, r], o = 2; o < t.length; o += 2)a.push(n, r, t[o], r = (t[o] - n) * e / 2, n = t[o], -r); return a } function pointsToSegment(t, e) { H(t[0] - t[2]) < 1e-4 && H(t[1] - t[3]) < 1e-4 && (t = t.slice(2)); var n, r, a, o, i, s, l, h, u, g, f, c, p, d, m = t.length - 2, v = +t[0], y = +t[1], x = +t[2], w = +t[3], P = [v, y, v, y], b = x - v, M = w - y, R = Math.abs(t[m] - v) < .001 && Math.abs(t[m + 1] - y) < .001; for (R && (t.push(x, w), x = v, w = y, v = t[m - 2], y = t[m - 1], t.unshift(v, y), m += 4), e = e || 0 === e ? +e : 1, a = 2; a < m; a += 2)n = v, r = y, v = x, y = w, x = +t[a + 2], w = +t[a + 3], v === x && y === w || (o = b, i = M, b = x - v, M = w - y, h = ((s = $(o * o + i * i)) + (l = $(b * b + M * M))) * e * .25 / $(Math.pow(b / l + o / s, 2) + Math.pow(M / l + i / s, 2)), f = v - ((u = v - (v - n) * (s ? h / s : 0)) + (((g = v + (x - v) * (l ? h / l : 0)) - u) * (3 * s / (s + l) + .5) / 4 || 0)), d = y - ((c = y - (y - r) * (s ? h / s : 0)) + (((p = y + (w - y) * (l ? h / l : 0)) - c) * (3 * s / (s + l) + .5) / 4 || 0)), v === n && y === r || P.push(N(u + f), N(c + d), N(v), N(y), N(g + f), N(p + d))); return v !== x || y !== w || P.length < 4 ? P.push(N(x), N(w), N(x), N(w)) : P.length -= 2, 2 === P.length ? P.push(v, y, v, y, v, y) : R && (P.splice(0, 6), P.length = P.length - 6), P } function rawPathToString(t) { h(t[0]) && (t = [t]); var e, n, r, a, o = "", i = t.length; for (n = 0; n < i; n++) { for (a = t[n], o += "M" + N(a[0]) + "," + N(a[1]) + " C", e = a.length, r = 2; r < e; r++)o += N(a[r++]) + "," + N(a[r++]) + " " + N(a[r++]) + "," + N(a[r++]) + " " + N(a[r++]) + "," + N(a[r]) + " "; a.closed && (o += "z") } return o } function R(t) { var e = t.ownerDocument || t; !(k in t.style) && "msTransform" in t.style && (z = (k = "msTransform") + "Origin"); for (; e.parentNode && (e = e.parentNode);); if (v = window, I = new Y, e) { w = (c = e).documentElement, P = e.body, (D = c.createElementNS("http://www.w3.org/2000/svg", "g")).style.transform = "none"; var n = e.createElement("div"), r = e.createElement("div"); P.appendChild(n), n.appendChild(r), n.style.position = "static", n.style[k] = "translate3d(0,0,1px)", E = r.offsetParent !== n, P.removeChild(n) } return e } function X(t) { return t.ownerSVGElement || ("svg" === (t.tagName + "").toLowerCase() ? t : null) } function Z(t, e) { if (t.parentNode && (c || R(t))) { var n = X(t), r = n ? n.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", a = n ? e ? "rect" : "g" : "div", o = 2 !== e ? 0 : 100, i = 3 === e ? 100 : 0, s = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;", l = c.createElementNS ? c.createElementNS(r.replace(/^https/, "http"), a) : c.createElement(a); return e && (n ? (b = b || Z(t), l.setAttribute("width", .01), l.setAttribute("height", .01), l.setAttribute("transform", "translate(" + o + "," + i + ")"), b.appendChild(l)) : (f || ((f = Z(t)).style.cssText = s), l.style.cssText = s + "width:0.1px;height:0.1px;top:" + i + "px;left:" + o + "px", f.appendChild(l))), l } throw "Need document and parent." } function aa(t, e) { var n, r, a, o, i, s, l = X(t), h = t === l, u = l ? G : q, g = t.parentNode; if (t === v) return t; if (u.length || u.push(Z(t, 1), Z(t, 2), Z(t, 3)), n = l ? b : f, l) h ? (o = -(a = function _getCTM(t) { var e, n = t.getCTM(); return n || (e = t.style[k], t.style[k] = "none", t.appendChild(D), n = D.getCTM(), t.removeChild(D), e ? t.style[k] = e : t.style.removeProperty(k.replace(/([A-Z])/g, "-$1").toLowerCase())), n || I.clone() }(t)).e / a.a, i = -a.f / a.d, r = I) : t.getBBox ? (a = t.getBBox(), o = (r = (r = t.transform ? t.transform.baseVal : {}).numberOfItems ? 1 < r.numberOfItems ? function _consolidate(t) { for (var e = new Y, n = 0; n < t.numberOfItems; n++)e.multiply(t.getItem(n).matrix); return e }(r) : r.getItem(0).matrix : I).a * a.x + r.c * a.y, i = r.b * a.x + r.d * a.y) : (r = new Y, o = i = 0), e && "g" === t.tagName.toLowerCase() && (o = i = 0), (h ? l : g).appendChild(n), n.setAttribute("transform", "matrix(" + r.a + "," + r.b + "," + r.c + "," + r.d + "," + (r.e + o) + "," + (r.f + i) + ")"); else { if (o = i = 0, E) for (r = t.offsetParent, a = t; (a = a && a.parentNode) && a !== r && a.parentNode;)4 < (v.getComputedStyle(a)[k] + "").length && (o = a.offsetLeft, i = a.offsetTop, a = 0); if ("absolute" !== (s = v.getComputedStyle(t)).position && "fixed" !== s.position) for (r = t.offsetParent; g && g !== r;)o += g.scrollLeft || 0, i += g.scrollTop || 0, g = g.parentNode; (a = n.style).top = t.offsetTop - i + "px", a.left = t.offsetLeft - o + "px", a[k] = s[k], a[z] = s[z], a.position = "fixed" === s.position ? "fixed" : "absolute", t.parentNode.appendChild(n) } return n } function ba(t, e, n, r, a, o, i) { return t.a = e, t.b = n, t.c = r, t.d = a, t.e = o, t.f = i, t } var c, v, w, P, f, b, I, D, E, n, k = "transform", z = k + "Origin", G = [], q = [], Y = ((n = Matrix2D.prototype).inverse = function inverse() { var t = this.a, e = this.b, n = this.c, r = this.d, a = this.e, o = this.f, i = t * r - e * n || 1e-10; return ba(this, r / i, -e / i, -n / i, t / i, (n * o - r * a) / i, -(t * o - e * a) / i) }, n.multiply = function multiply(t) { var e = this.a, n = this.b, r = this.c, a = this.d, o = this.e, i = this.f, s = t.a, l = t.c, h = t.b, u = t.d, g = t.e, f = t.f; return ba(this, s * e + h * r, s * n + h * a, l * e + u * r, l * n + u * a, o + g * e + f * r, i + g * n + f * a) }, n.clone = function clone() { return new Matrix2D(this.a, this.b, this.c, this.d, this.e, this.f) }, n.equals = function equals(t) { var e = this.a, n = this.b, r = this.c, a = this.d, o = this.e, i = this.f; return e === t.a && n === t.b && r === t.c && a === t.d && o === t.e && i === t.f }, n.apply = function apply(t, e) { void 0 === e && (e = {}); var n = t.x, r = t.y, a = this.a, o = this.b, i = this.c, s = this.d, l = this.e, h = this.f; return e.x = n * a + r * i + l || 0, e.y = n * o + r * s + h || 0, e }, Matrix2D); function Matrix2D(t, e, n, r, a, o) { void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 1), void 0 === a && (a = 0), void 0 === o && (o = 0), ba(this, t, e, n, r, a, o) } function getGlobalMatrix(t, e, n, r) { if (!t || !t.parentNode || (c || R(t)).documentElement === t) return new Y; var a = function _forceNonZeroScale(t) { for (var e, n; t && t !== P;)(n = t._gsap) && n.uncache && n.get(t, "x"), n && !n.scaleX && !n.scaleY && n.renderTransform && (n.scaleX = n.scaleY = 1e-4, n.renderTransform(1, n), e ? e.push(n) : e = [n]), t = t.parentNode; return e }(t), o = X(t) ? G : q, i = aa(t, n), s = o[0].getBoundingClientRect(), l = o[1].getBoundingClientRect(), h = o[2].getBoundingClientRect(), u = i.parentNode, g = !r && function _isFixed(t) { return "fixed" === v.getComputedStyle(t).position || ((t = t.parentNode) && 1 === t.nodeType ? _isFixed(t) : void 0) }(t), f = new Y((l.left - s.left) / 100, (l.top - s.top) / 100, (h.left - s.left) / 100, (h.top - s.top) / 100, s.left + (g ? 0 : function _getDocScrollLeft() { return v.pageXOffset || c.scrollLeft || w.scrollLeft || P.scrollLeft || 0 }()), s.top + (g ? 0 : function _getDocScrollTop() { return v.pageYOffset || c.scrollTop || w.scrollTop || P.scrollTop || 0 }())); if (u.removeChild(i), a) for (s = a.length; s--;)(l = a[s]).scaleX = l.scaleY = 0, l.renderTransform(1, l); return e ? f.inverse() : f } function na(t, e, n, r) { for (var a = e.length, o = 2 === r ? 0 : r, i = 0; i < a; i++)t[o] = parseFloat(e[i][n]), 2 === r && (t[o + 1] = 0), o += 2; return t } function oa(t, e, n) { return parseFloat(t._gsap.get(t, e, n || "px")) || 0 } function pa(t) { var e, n = t[0], r = t[1]; for (e = 2; e < t.length; e += 2)n = t[e] += n, r = t[e + 1] += r } function qa(t, e, n, r, a, o, i, s, l) { return e = "cubic" === i.type ? [e] : (!1 !== i.fromCurrent && e.unshift(oa(n, r, s), a ? oa(n, a, l) : 0), i.relative && pa(e), [(a ? pointsToSegment : flatPointsToSegment)(e, i.curviness)]), e = o(nt(e, n, i)), rt(t, n, r, e, "x", s), a && rt(t, n, a, e, "y", l), cacheRawPathMeasurements(e, i.resolution || (0 === i.curviness ? 20 : 12)) } function ra(t) { return t } function ta(t, e, n) { var r, a = getGlobalMatrix(t), o = 0, i = 0; return "svg" === (t.tagName + "").toLowerCase() ? (r = t.viewBox.baseVal).width || (r = { width: +t.getAttribute("width"), height: +t.getAttribute("height") }) : r = e && t.getBBox && t.getBBox(), e && "auto" !== e && (o = e.push ? e[0] * (r ? r.width : t.offsetWidth || 0) : e.x, i = e.push ? e[1] * (r ? r.height : t.offsetHeight || 0) : e.y), n.apply(o || i ? a.apply({ x: o, y: i }) : { x: a.e, y: a.f }) } function ua(t, e, n, r) { var a, o = getGlobalMatrix(t.parentNode, !0, !0), i = o.clone().multiply(getGlobalMatrix(e)), s = ta(t, n, o), l = ta(e, r, o), h = l.x, u = l.y; return i.e = i.f = 0, "auto" === r && e.getTotalLength && "path" === e.tagName.toLowerCase() && (a = e.getAttribute("d").match(et) || [], h += (a = i.apply({ x: +a[0], y: +a[1] })).x, u += a.y), a && (h -= (a = i.apply(e.getBBox())).x, u -= a.y), i.e = h - s.x, i.f = u - s.y, i } var j, g, Q, W, J, o, K = "x,translateX,left,marginLeft,xPercent".split(","), tt = "y,translateY,top,marginTop,yPercent".split(","), i = Math.PI / 180, et = /[-+\.]*\d+\.?(?:e-|e\+)?\d*/g, nt = function _align(t, e, n) { var r, a, o, i = n.align, s = n.matrix, l = n.offsetX, h = n.offsetY, u = n.alignOrigin, g = t[0][0], f = t[0][1], c = oa(e, "x"), p = oa(e, "y"); return t && t.length ? (i && ("self" === i || (r = W(i)[0] || e) === e ? transformRawPath(t, 1, 0, 0, 1, c - g, p - f) : (u && !1 !== u[2] ? j.set(e, { transformOrigin: 100 * u[0] + "% " + 100 * u[1] + "%" }) : u = [oa(e, "xPercent") / -100, oa(e, "yPercent") / -100], o = (a = ua(e, r, u, "auto")).apply({ x: g, y: f }), transformRawPath(t, a.a, a.b, a.c, a.d, c + a.e - (o.x - a.e), p + a.f - (o.y - a.f)))), s ? transformRawPath(t, s.a, s.b, s.c, s.d, s.e, s.f) : (l || h) && transformRawPath(t, 1, 0, 0, 1, l || 0, h || 0), t) : getRawPath("M0,0L0,0") }, rt = function _addDimensionalPropTween(t, e, n, r, a, o) { var i = e._gsap, s = i.harness, l = s && s.aliases && s.aliases[n], h = l && l.indexOf(",") < 0 ? l : n, u = t._pt = new g(t._pt, e, h, 0, 0, ra, 0, i.set(e, h, t)); u.u = Q(i.get(e, h, o)) || 0, u.path = r, u.pp = a, t._props.push(h) }, a = { version: "3.12.2", name: "motionPath", register: function register(t, e, n) { Q = (j = t).utils.getUnit, W = j.utils.toArray, J = j.core.getStyleSaver, o = j.core.reverting || function () { }, g = n }, init: function init(t, e, n) { if (!j) return console.warn("Please gsap.registerPlugin(MotionPathPlugin)"), !1; "object" == typeof e && !e.style && e.path || (e = { path: e }); var r, a, o = [], i = e.path, s = e.autoRotate, l = e.unitX, h = e.unitY, u = e.x, g = e.y, f = i[0], c = function _sliceModifier(e, n) { return function (t) { return e || 1 !== n ? sliceRawPath(t, e, n) : t } }(e.start, "end" in e ? e.end : 1); if (this.rawPaths = o, this.target = t, this.tween = n, this.styles = J && J(t, "transform"), (this.rotate = s || 0 === s) && (this.rOffset = parseFloat(s) || 0, this.radians = !!e.useRadians, this.rProp = e.rotation || "rotation", this.rSet = t._gsap.set(t, this.rProp, this), this.ru = Q(t._gsap.get(t, this.rProp)) || 0), !Array.isArray(i) || "closed" in i || "number" == typeof f) cacheRawPathMeasurements(r = c(nt(getRawPath(e.path), t, e)), e.resolution), o.push(r), rt(this, t, e.x || "x", r, "x", e.unitX || "px"), rt(this, t, e.y || "y", r, "y", e.unitY || "px"); else { for (a in f) !u && ~K.indexOf(a) ? u = a : !g && ~tt.indexOf(a) && (g = a); for (a in u && g ? o.push(qa(this, na(na([], i, u, 0), i, g, 1), t, u, g, c, e, l || Q(i[0][u]), h || Q(i[0][g]))) : u = g = 0, f) a !== u && a !== g && o.push(qa(this, na([], i, a, 2), t, a, 0, c, e, Q(i[0][a]))) } }, render: function render(t, e) { var n = e.rawPaths, r = n.length, a = e._pt; if (e.tween._time || !o()) { for (1 < t ? t = 1 : t < 0 && (t = 0); r--;)getPositionOnPath(n[r], t, !r && e.rotate, n[r]); for (; a;)a.set(a.t, a.p, a.path[a.pp] + a.u, a.d, t), a = a._next; e.rotate && e.rSet(e.target, e.rProp, n[0].angle * (e.radians ? i : 1) + e.rOffset + e.ru, e, t) } else e.styles.revert() }, getLength: function getLength(t) { return cacheRawPathMeasurements(getRawPath(t)).totalLength }, sliceRawPath: sliceRawPath, getRawPath: getRawPath, pointsToSegment: pointsToSegment, stringToRawPath: stringToRawPath, rawPathToString: rawPathToString, transformRawPath: transformRawPath, getGlobalMatrix: getGlobalMatrix, getPositionOnPath: getPositionOnPath, cacheRawPathMeasurements: cacheRawPathMeasurements, convertToPath: function convertToPath$1(t, e) { return W(t).map(function (t) { return convertToPath(t, !1 !== e) }) }, convertCoordinates: function convertCoordinates(t, e, n) { var r = getGlobalMatrix(e, !0, !0).multiply(getGlobalMatrix(t)); return n ? r.apply(n) : r }, getAlignMatrix: ua, getRelativePosition: function getRelativePosition(t, e, n, r) { var a = ua(t, e, n, r); return { x: a.e, y: a.f } }, arrayToRawPath: function arrayToRawPath(t, e) { var n = na(na([], t, (e = e || {}).x || "x", 0), t, e.y || "y", 1); return e.relative && pa(n), ["cubic" === e.type ? n : pointsToSegment(n, e.curviness)] } }; !function _getGSAP() { return j || "undefined" != typeof window && (j = window.gsap) && j.registerPlugin && j }() || j.registerPlugin(a), t.MotionPathPlugin = a, t.default = a; if (typeof (window) === "undefined" || window !== t) { Object.defineProperty(t, "__esModule", { value: !0 }) } else { delete t.default } });





(() => { "use strict"; var t = { 701: t => { let e = 0; t.exports = { incr: () => ++e, decr: () => --e, curr: () => e } }, 941: t => { t.exports = (t, e, r = "") => { const n = /url\(['"]?#([\w:.-]+)['"]?\)/g, a = /#([\w:.-]+)/g; return e.match(n) && (e = e.replace(n, (function (e, r) { return t[r] ? `url(#${t[r]})` : e }))), ["href", "xlink:href"].includes(r) && e.match(a) && (e = e.replace(a, (function (e, r) { return t[r] ? `#${t[r]}` : e }))), e } }, 905: t => { t.exports = (t, e, r) => { const n = new RegExp("([^\r\n,{}]+)(,(?=[^}]*{)|s*{)", "g"); return t.replace(n, (function (t, n, a) { if (n.match(/^\s*(@media|@.*keyframes|to|from|@font-face|1?[0-9]?[0-9])/)) return n + a; const o = n.match(/#(\w+)/); return o && r[o[1]] && (n = n.replace(o[0], `#${r[o[1]]}`)), (n = n.replace(/^(\s*)/, "$1" + e + " ")) + a })) } }, 678: (t, e, r) => { function n(t) { return new Promise(((e, r) => { t.oncomplete = t.onsuccess = () => e(t.result), t.onabort = t.onerror = () => r(t.error) })) } function a(t, e) { const r = indexedDB.open(t); r.onupgradeneeded = () => r.result.createObjectStore(e); const a = n(r); return (t, r) => a.then((n => r(n.transaction(e, t).objectStore(e)))) } let o; function s() { return o || (o = a("keyval-store", "keyval")), o } function i(t, e = s()) { return e("readonly", (e => n(e.get(t)))) } function c(t, e, r = s()) { return r("readwrite", (r => (r.put(e, t), n(r.transaction)))) } function l(t, e = s()) { return e("readwrite", (e => (t.forEach((t => e.put(t[1], t[0]))), n(e.transaction)))) } function u(t, e = s()) { return e("readonly", (e => Promise.all(t.map((t => n(e.get(t))))))) } function d(t, e, r = s()) { return r("readwrite", (r => new Promise(((a, o) => { r.get(t).onsuccess = function () { try { r.put(e(this.result), t), a(n(r.transaction)) } catch (t) { o(t) } } })))) } function f(t, e = s()) { return e("readwrite", (e => (e.delete(t), n(e.transaction)))) } function h(t, e = s()) { return e("readwrite", (e => (t.forEach((t => e.delete(t))), n(e.transaction)))) } function b(t = s()) { return t("readwrite", (t => (t.clear(), n(t.transaction)))) } function g(t, e) { return t.openCursor().onsuccess = function () { this.result && (e(this.result), this.result.continue()) }, n(t.transaction) } function p(t = s()) { return t("readonly", (t => { if (t.getAllKeys) return n(t.getAllKeys()); const e = []; return g(t, (t => e.push(t.key))).then((() => e)) })) } function y(t = s()) { return t("readonly", (t => { if (t.getAll) return n(t.getAll()); const e = []; return g(t, (t => e.push(t.value))).then((() => e)) })) } function m(t = s()) { return t("readonly", (e => { if (e.getAll && e.getAllKeys) return Promise.all([n(e.getAllKeys()), n(e.getAll())]).then((([t, e]) => t.map(((t, r) => [t, e[r]])))); const r = []; return t("readonly", (t => g(t, (t => r.push([t.key, t.value]))).then((() => r)))) })) } r.r(e), r.d(e, { clear: () => b, createStore: () => a, del: () => f, delMany: () => h, entries: () => m, get: () => i, getMany: () => u, keys: () => p, promisifyRequest: () => n, set: () => c, setMany: () => l, update: () => d, values: () => y }) } }, e = {}; function r(n) { var a = e[n]; if (void 0 !== a) return a.exports; var o = e[n] = { exports: {} }; return t[n](o, o.exports, r), o.exports } r.d = (t, e) => { for (var n in e) r.o(e, n) && !r.o(t, n) && Object.defineProperty(t, n, { enumerable: !0, get: e[n] }) }, r.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), r.r = t => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, (() => { const { get: t, set: e, del: n, entries: a } = r(678), o = r(905), s = r(941), i = r(701), c = [], l = {}, u = (t, e, r) => { const { enableJs: n, disableUniqueIds: a, disableCssScoping: u, spriteIconId: d } = e, f = !!d, h = (new DOMParser).parseFromString(r, "text/html"), b = f ? h.getElementById(d) : h.querySelector("svg"), g = (() => { if (c.length) return c; for (const t in document.body) t.startsWith("on") && c.push(t); return c })(), p = l[t.getAttribute("data-id")] || new Set, y = t.getAttribute("data-id") || `svg-loader_${i.incr()}`, m = {}; if (a || Array.from(b.querySelectorAll("[id]")).forEach((t => { const e = t.getAttribute("id"), r = `${e}_${i.incr()}`; t.setAttribute("id", r), m[e] = r })), Array.from(b.querySelectorAll("*")).concat(b).forEach((e => { if ("script" === e.tagName) { if (e.remove(), !n) return; { const r = document.createElement("script"); r.appendChild(e.childNodes[0]), t.appendChild(r) } } const r = []; for (let t = 0; t < e.attributes.length; t++) { const { name: a, value: o } = e.attributes[t], i = s(m, o, a); o !== i && e.setAttribute(a, i), !g.includes(a.toLowerCase()) || n ? ["href", "xlink:href"].includes(a) && o.startsWith("javascript") && !n && r.push(a) : r.push(a) } if (r.forEach((t => e.removeAttribute(t))), "style" === e.tagName && !u) { let t = o(e.innerHTML, `[data-id="${y}"]`, m); t = s(m, t), t !== e.innerHTML && (e.innerHTML = t) } })), t.innerHTML = d ? b.outerHTML : b.innerHTML, !f) for (let e = 0; e < b.attributes.length; e++) { const { name: r, value: n } = b.attributes[e]; t.getAttribute(r) && !p.has(r) || (p.add(r), t.setAttribute(r, n)) } l[y] = p, t.setAttribute("data-id", y); const v = new CustomEvent("iconload", { bubbles: !0 }); if (t.dispatchEvent(v), t.getAttribute("oniconload")) { t.setAttribute("onauxclick", t.getAttribute("oniconload")); const e = new CustomEvent("auxclick", { bubbles: !1, view: window }); t.dispatchEvent(e), t.removeAttribute("onauxclick") } }, d = {}, f = {}, h = async r => { const a = new URL(r.getAttribute("data-src"), globalThis.location), o = a.toString().replace(a.hash, ""), s = a.hash.replace("#", ""), i = r.getAttribute("data-cache"), c = "enabled" === r.getAttribute("data-js"), l = "disabled" === r.getAttribute("data-unique-ids"), b = "disabled" === r.getAttribute("data-css-scoping"), g = await (async e => { let r; try { r = await t(`loader_${e}`) } catch (t) { } if (!r) try { r = localStorage.getItem(`loader_${e}`) } catch (t) { } if (r) return r = JSON.parse(r), Date.now() < r.expiry ? r.data : void n(`loader_${e}`) })(o), p = "disabled" !== i, y = u.bind(self, r, { enableJs: c, disableUniqueIds: l, disableCssScoping: b, spriteIconId: s }); if (f[o] || p && g) { const t = f[o] || g; y(t) } else { if (d[o]) return void setTimeout((() => h(r)), 20); d[o] = !0, fetch(o).then((t => { if (!t.ok) throw Error(`Request for '${o}' returned ${t.status} (${t.statusText})`); return t.text() })).then((t => { const r = t.toLowerCase().trim(); if (!(r.startsWith("<svg") || r.startsWith("<?xml") || r.startsWith("<!doctype"))) throw Error(`Resource '${o}' returned an invalid SVG file`); p && (async (t, r, n) => { const a = parseInt(n, 10), o = JSON.stringify({ data: r, expiry: Date.now() + (Number.isNaN(a) ? 2592e6 : 1e3 * a) }); try { await e(`loader_${t}`, o) } catch (e) { try { localStorage.setItem(`loader_${t}`, o) } catch (t) { console.warn("Failed to set cache: ", t) } } })(o, t, i), f[o] = t, y(t) })).catch((t => { console.error(t) })).finally((() => { delete d[o] })) } }; let b; globalThis.IntersectionObserver && (b = new IntersectionObserver((t => { t.forEach((t => { t.isIntersecting && (h(t.target), b.unobserve(t.target)) })) }), { rootMargin: "1200px" })); const g = []; function p() { Array.from(document.querySelectorAll("svg[data-src]:not([data-id])")).forEach((t => { -1 === g.indexOf(t) && (g.push(t), "lazy" === t.getAttribute("data-loading") ? b.observe(t) : h(t)) })) } let y = !1; if (globalThis.addEventListener) { const m = setInterval((() => { p() }), 100); function v() { clearInterval(m), p(), y || (y = !0, new MutationObserver((t => { t.some((t => Array.from(t.addedNodes).some((t => t.nodeType === Node.ELEMENT_NODE && (t.getAttribute("data-src") && !t.getAttribute("data-id") || t.querySelector("svg[data-src]:not([data-id])")))))) && p(), t.forEach((t => { "attributes" === t.type && h(t.target) })) })).observe(document.documentElement, { attributeFilter: ["data-src"], attributes: !0, childList: !0, subtree: !0 })) } "interactive" === document.readyState ? v() : globalThis.addEventListener("DOMContentLoaded", (() => { v() })) } globalThis.SVGLoader = {}, globalThis.SVGLoader.destroyCache = async () => { try { const t = await a(); for (const e of t) e[0].startsWith("loader_") && await n(e[0]) } catch (t) { } Object.keys(localStorage).forEach((t => { t.startsWith("loader_") && localStorage.removeItem(t) })) } })() })();




!function (n, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : n.Splitting = t() }(this, function () {
    "use strict"
    var o = document, l = o.createTextNode.bind(o)
    function d(n, t, e) { n.style.setProperty(t, e) } function f(n, t) { return n.appendChild(t) } function p(n, t, e, r) {
        var i = o.createElement("span")
        return t && (i.className = t), e && (!r && i.setAttribute("data-" + t, e), i.textContent = e), n && f(n, i) || i
    } function h(n, t) { return n.getAttribute("data-" + t) } function m(n, t) { return n && 0 != n.length ? n.nodeName ? [n] : [].slice.call(n[0].nodeName ? n : (t || o).querySelectorAll(n)) : [] } function u(n) {
        for (var t = []; n--;)t[n] = []
        return t
    } function v(n, t) { n && n.some(t) } function c(t) { return function (n) { return t[n] } } var a = {}
    function n(n, t, e, r) { return { by: n, depends: t, key: e, split: r } } function r(n) {
        return function t(e, n, r) {
            var i = r.indexOf(e)
            if (-1 == i) {
                r.unshift(e)
                var o = a[e]
                if (!o) throw new Error("plugin not loaded: " + e)
                v(o.depends, function (n) { t(n, e, r) })
            } else {
                var u = r.indexOf(n)
                r.splice(i, 1), r.splice(u, 0, e)
            } return r
        }(n, 0, []).map(c(a))
    } function t(n) { a[n.by] = n } function g(n, r, i, o, u) {
        n.normalize()
        var c = [], a = document.createDocumentFragment()
        o && c.push(n.previousSibling)
        var s = []
        return m(n.childNodes).some(function (n) {
            if (!n.tagName || n.hasChildNodes()) {
                if (n.childNodes && n.childNodes.length) return s.push(n), void c.push.apply(c, g(n, r, i, o, u))
                var t = n.wholeText || "", e = t.trim()
                e.length && (" " === t[0] && s.push(l(" ")), v(e.split(i), function (n, t) {
                    t && u && s.push(p(a, "whitespace", " ", u))
                    var e = p(a, r, n)
                    c.push(e), s.push(e)
                }), " " === t[t.length - 1] && s.push(l(" ")))
            } else s.push(n)
        }), v(s, function (n) { f(a, n) }), n.innerHTML = "", f(n, a), c
    } var s = 0
    var i = "words", e = n(i, s, "word", function (n) { return g(n, "word", /\s+/, 0, 1) }), y = "chars", w = n(y, [i], "char", function (n, e, t) {
        var r = []
        return v(t[i], function (n, t) { r.push.apply(r, g(n, "char", "", e.whitespace && t)) }), r
    })
    function b(e) {
        var f = (e = e || {}).key
        return m(e.target || "[data-splitting]").map(function (a) {
            var s = a[""]
            if (!e.force && s) return s
            s = a[""] = { el: a }
            var n = e.by || h(a, "splitting")
            n && "true" != n || (n = y)
            var t = r(n), l = function (n, t) {
                for (var e in t) n[e] = t[e]
                return n
            }({}, e)
            return v(t, function (n) {
                if (n.split) {
                    var t = n.by, e = (f ? "-" + f : "") + n.key, r = n.split(a, l, s)
                    e && (i = a, c = (u = "--" + e) + "-index", v(o = r, function (n, t) { Array.isArray(n) ? v(n, function (n) { d(n, c, t) }) : d(n, c, t) }), d(i, u + "-total", o.length)), s[t] = r, a.classList.add(t)
                } var i, o, u, c
            }), a.classList.add("splitting"), s
        })
    } function N(n, t, e) {
        var r = m(t.matching || n.children, n), i = {}
        return v(r, function (n) { var t = Math.round(n[e]); (i[t] || (i[t] = [])).push(n) }), Object.keys(i).map(Number).sort(x).map(c(i))
    } function x(n, t) { return n - t } b.html = function (n) {
        var t = (n = n || {}).target = p()
        return t.innerHTML = n.content, b(n), t.outerHTML
    }, b.add = t
    var T = n("lines", [i], "line", function (n, t, e) { return N(n, { matching: e[i] }, "offsetTop") }), L = n("items", s, "item", function (n, t) { return m(t.matching || n.children, n) }), k = n("rows", s, "row", function (n, t) { return N(n, t, "offsetTop") }), A = n("cols", s, "col", function (n, t) { return N(n, t, "offsetLeft") }), C = n("grid", ["rows", "cols"]), M = "layout", S = n(M, s, s, function (n, t) {
        var e = t.rows = +(t.rows || h(n, "rows") || 1), r = t.columns = +(t.columns || h(n, "columns") || 1)
        if (t.image = t.image || h(n, "image") || n.currentSrc || n.src, t.image) {
            var i = m("img", n)[0]
            t.image = i && (i.currentSrc || i.src)
        } t.image && d(n, "background-image", "url(" + t.image + ")")
        for (var o = e * r, u = [], c = p(s, "cell-grid"); o--;) {
            var a = p(c, "cell")
            p(a, "cell-inner"), u.push(a)
        } return f(n, c), u
    }), H = n("cellRows", [M], "row", function (n, t, e) {
        var r = t.rows, i = u(r)
        return v(e[M], function (n, t, e) { i[Math.floor(t / (e.length / r))].push(n) }), i
    }), O = n("cellColumns", [M], "col", function (n, t, e) {
        var r = t.columns, i = u(r)
        return v(e[M], function (n, t) { i[t % r].push(n) }), i
    }), j = n("cells", ["cellRows", "cellColumns"], "cell", function (n, t, e) { return e[M] })
    return t(e), t(w), t(T), t(L), t(k), t(A), t(C), t(S), t(H), t(O), t(j), b
})






/*!
 * imagesLoaded PACKAGED v4.1.4
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */

!function (e, t) { "function" == typeof define && define.amd ? define("ev-emitter/ev-emitter", t) : "object" == typeof module && module.exports ? module.exports = t() : e.EvEmitter = t() }("undefined" != typeof window ? window : this, function () { function e() { } var t = e.prototype; return t.on = function (e, t) { if (e && t) { var i = this._events = this._events || {}, n = i[e] = i[e] || []; return n.indexOf(t) == -1 && n.push(t), this } }, t.once = function (e, t) { if (e && t) { this.on(e, t); var i = this._onceEvents = this._onceEvents || {}, n = i[e] = i[e] || {}; return n[t] = !0, this } }, t.off = function (e, t) { var i = this._events && this._events[e]; if (i && i.length) { var n = i.indexOf(t); return n != -1 && i.splice(n, 1), this } }, t.emitEvent = function (e, t) { var i = this._events && this._events[e]; if (i && i.length) { i = i.slice(0), t = t || []; for (var n = this._onceEvents && this._onceEvents[e], o = 0; o < i.length; o++) { var r = i[o], s = n && n[r]; s && (this.off(e, r), delete n[r]), r.apply(this, t) } return this } }, t.allOff = function () { delete this._events, delete this._onceEvents }, e }), function (e, t) { "use strict"; "function" == typeof define && define.amd ? define(["ev-emitter/ev-emitter"], function (i) { return t(e, i) }) : "object" == typeof module && module.exports ? module.exports = t(e, require("ev-emitter")) : e.imagesLoaded = t(e, e.EvEmitter) }("undefined" != typeof window ? window : this, function (e, t) { function i(e, t) { for (var i in t) e[i] = t[i]; return e } function n(e) { if (Array.isArray(e)) return e; var t = "object" == typeof e && "number" == typeof e.length; return t ? d.call(e) : [e] } function o(e, t, r) { if (!(this instanceof o)) return new o(e, t, r); var s = e; return "string" == typeof e && (s = document.querySelectorAll(e)), s ? (this.elements = n(s), this.options = i({}, this.options), "function" == typeof t ? r = t : i(this.options, t), r && this.on("always", r), this.getImages(), h && (this.jqDeferred = new h.Deferred), void setTimeout(this.check.bind(this))) : void a.error("Bad element for imagesLoaded " + (s || e)) } function r(e) { this.img = e } function s(e, t) { this.url = e, this.element = t, this.img = new Image } var h = e.jQuery, a = e.console, d = Array.prototype.slice; o.prototype = Object.create(t.prototype), o.prototype.options = {}, o.prototype.getImages = function () { this.images = [], this.elements.forEach(this.addElementImages, this) }, o.prototype.addElementImages = function (e) { "IMG" == e.nodeName && this.addImage(e), this.options.background === !0 && this.addElementBackgroundImages(e); var t = e.nodeType; if (t && u[t]) { for (var i = e.querySelectorAll("img"), n = 0; n < i.length; n++) { var o = i[n]; this.addImage(o) } if ("string" == typeof this.options.background) { var r = e.querySelectorAll(this.options.background); for (n = 0; n < r.length; n++) { var s = r[n]; this.addElementBackgroundImages(s) } } } }; var u = { 1: !0, 9: !0, 11: !0 }; return o.prototype.addElementBackgroundImages = function (e) { var t = getComputedStyle(e); if (t) for (var i = /url\((['"])?(.*?)\1\)/gi, n = i.exec(t.backgroundImage); null !== n;) { var o = n && n[2]; o && this.addBackground(o, e), n = i.exec(t.backgroundImage) } }, o.prototype.addImage = function (e) { var t = new r(e); this.images.push(t) }, o.prototype.addBackground = function (e, t) { var i = new s(e, t); this.images.push(i) }, o.prototype.check = function () { function e(e, i, n) { setTimeout(function () { t.progress(e, i, n) }) } var t = this; return this.progressedCount = 0, this.hasAnyBroken = !1, this.images.length ? void this.images.forEach(function (t) { t.once("progress", e), t.check() }) : void this.complete() }, o.prototype.progress = function (e, t, i) { this.progressedCount++, this.hasAnyBroken = this.hasAnyBroken || !e.isLoaded, this.emitEvent("progress", [this, e, t]), this.jqDeferred && this.jqDeferred.notify && this.jqDeferred.notify(this, e), this.progressedCount == this.images.length && this.complete(), this.options.debug && a && a.log("progress: " + i, e, t) }, o.prototype.complete = function () { var e = this.hasAnyBroken ? "fail" : "done"; if (this.isComplete = !0, this.emitEvent(e, [this]), this.emitEvent("always", [this]), this.jqDeferred) { var t = this.hasAnyBroken ? "reject" : "resolve"; this.jqDeferred[t](this) } }, r.prototype = Object.create(t.prototype), r.prototype.check = function () { var e = this.getIsImageComplete(); return e ? void this.confirm(0 !== this.img.naturalWidth, "naturalWidth") : (this.proxyImage = new Image, this.proxyImage.addEventListener("load", this), this.proxyImage.addEventListener("error", this), this.img.addEventListener("load", this), this.img.addEventListener("error", this), void (this.proxyImage.src = this.img.src)) }, r.prototype.getIsImageComplete = function () { return this.img.complete && this.img.naturalWidth }, r.prototype.confirm = function (e, t) { this.isLoaded = e, this.emitEvent("progress", [this, this.img, t]) }, r.prototype.handleEvent = function (e) { var t = "on" + e.type; this[t] && this[t](e) }, r.prototype.onload = function () { this.confirm(!0, "onload"), this.unbindEvents() }, r.prototype.onerror = function () { this.confirm(!1, "onerror"), this.unbindEvents() }, r.prototype.unbindEvents = function () { this.proxyImage.removeEventListener("load", this), this.proxyImage.removeEventListener("error", this), this.img.removeEventListener("load", this), this.img.removeEventListener("error", this) }, s.prototype = Object.create(r.prototype), s.prototype.check = function () { this.img.addEventListener("load", this), this.img.addEventListener("error", this), this.img.src = this.url; var e = this.getIsImageComplete(); e && (this.confirm(0 !== this.img.naturalWidth, "naturalWidth"), this.unbindEvents()) }, s.prototype.unbindEvents = function () { this.img.removeEventListener("load", this), this.img.removeEventListener("error", this) }, s.prototype.confirm = function (e, t) { this.isLoaded = e, this.emitEvent("progress", [this, this.element, t]) }, o.makeJQueryPlugin = function (t) { t = t || e.jQuery, t && (h = t, h.fn.imagesLoaded = function (e, t) { var i = new o(this, e, t); return i.jqDeferred.promise(h(this)) }) }, o.makeJQueryPlugin(), o });



function horizontalLoop(items, config) {
    items = gsap.utils.toArray(items);
    config = config || {};
    let tl = gsap.timeline({
        repeat: config.repeat,
        paused: config.paused,
        defaults: { ease: "none" },
        onReverseComplete: () => tl.totalTime(tl.rawTime() + tl.duration() * 100)
      }),
      length = items.length,
      startX = items[0].offsetLeft,
      times = [],
      widths = [],
      xPercents = [],
      curIndex = 0,
      pixelsPerSecond = (config.speed || 1) * 100,
      snap = config.snap === false ? (v) => v : gsap.utils.snap(config.snap || 1), // some browsers shift by a pixel to accommodate flex layouts, so for example if width is 20% the first element's width might be 242px, and the next 243px, alternating back and forth. So we snap to 5 percentage points to make things look more natural
      totalWidth,
      curX,
      distanceToStart,
      distanceToLoop,
      item,
      i;
    gsap.set(items, {
      // convert "x" to "xPercent" to make things responsive, and populate the widths/xPercents Arrays to make lookups faster.
      xPercent: (i, el) => {
        let w = (widths[i] = parseFloat(gsap.getProperty(el, "width", "px")));
        xPercents[i] = snap(
          (parseFloat(gsap.getProperty(el, "x", "px")) / w) * 100 +
            gsap.getProperty(el, "xPercent")
        );
        return xPercents[i];
      }
    });
    gsap.set(items, { x: 0 });
    totalWidth =
      items[length - 1].offsetLeft +
      (xPercents[length - 1] / 100) * widths[length - 1] -
      startX +
      items[length - 1].offsetWidth *
        gsap.getProperty(items[length - 1], "scaleX") +
      (parseFloat(config.paddingRight) || 0);
    for (i = 0; i < length; i++) {
      item = items[i];
      curX = (xPercents[i] / 100) * widths[i];
      distanceToStart = item.offsetLeft + curX - startX;
      distanceToLoop =
        distanceToStart + widths[i] * gsap.getProperty(item, "scaleX");
      tl.to(
        item,
        {
          xPercent: snap(((curX - distanceToLoop) / widths[i]) * 100),
          duration: distanceToLoop / pixelsPerSecond
        },
        0
      )
        .fromTo(
          item,
          {
            xPercent: snap(
              ((curX - distanceToLoop + totalWidth) / widths[i]) * 100
            )
          },
          {
            xPercent: xPercents[i],
            duration:
              (curX - distanceToLoop + totalWidth - curX) / pixelsPerSecond,
            immediateRender: false
          },
          distanceToLoop / pixelsPerSecond
        )
        .add("label" + i, distanceToStart / pixelsPerSecond);
      times[i] = distanceToStart / pixelsPerSecond;
    }
    function toIndex(index, vars) {
      vars = vars || {};
      Math.abs(index - curIndex) > length / 2 &&
        (index += index > curIndex ? -length : length); // always go in the shortest direction
      let newIndex = gsap.utils.wrap(0, length, index),
        time = times[newIndex];
      if (time > tl.time() !== index > curIndex) {
        // if we're wrapping the timeline's playhead, make the proper adjustments
        vars.modifiers = { time: gsap.utils.wrap(0, tl.duration()) };
        time += tl.duration() * (index > curIndex ? 1 : -1);
      }
      curIndex = newIndex;
      vars.overwrite = true;
      return tl.tweenTo(time, vars);
    }
    tl.next = (vars) => toIndex(curIndex + 1, vars);
    tl.previous = (vars) => toIndex(curIndex - 1, vars);
    tl.current = () => curIndex;
    tl.toIndex = (index, vars) => toIndex(index, vars);
    tl.times = times;
    tl.progress(1, true).progress(0, true); // pre-render for performance
    if (config.reversed) {
      tl.vars.onReverseComplete();
      tl.reverse();
    }
    return tl;
  }